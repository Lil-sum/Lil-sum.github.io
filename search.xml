<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GitHub开发者交流平台注册教程</title>
    <url>/2020/09/08/GitHub%E5%BC%80%E5%8F%91%E8%80%85%E4%BA%A4%E6%B5%81%E5%B9%B3%E5%8F%B0%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="GitHub食用教程："><a href="#GitHub食用教程：" class="headerlink" title="GitHub食用教程："></a>GitHub食用教程：</h1><p>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。<br>GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。</p>
<p>想要成为一个合格的程序员必须要掌握 GitHub 的用法！</p>
<p>由于github是半墙状态，有条件的可以开ssh，科学上网<br>优先推荐使用chrome（谷歌浏览器）或者微软edge浏览器</p>
<h3 id="注册github流程"><a href="#注册github流程" class="headerlink" title="注册github流程"></a>注册github流程</h3><p>1.首先进入github官网 <a href="https://github.com/">https://github.com/</a></p>
<p><img src="/github%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B/1.png"></p>
<p>2.点击绿色框Sign up for GitHub进行注册<br>注意：<br>Sign in，登录<br>Sign up，注册</p>
<p><img src="/github%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B/2.png"></p>
<p>3.注册页面第一栏email（邮箱），第二栏password（密码），第三栏username（用户名）</p>
<p>进行验证后即可完成注册</p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是玩转GitHub开发者社区的教程了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>教程类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Hadoop大数据技术</title>
    <url>/2021/12/18/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="关于Hadoop大数据技术"><a href="#关于Hadoop大数据技术" class="headerlink" title="关于Hadoop大数据技术:"></a>关于Hadoop大数据技术:</h1><h1 id="Hadoop-概述"><a href="#Hadoop-概述" class="headerlink" title="Hadoop 概述"></a>Hadoop 概述</h1><h2 id="1-1-Hadoop-是什么"><a href="#1-1-Hadoop-是什么" class="headerlink" title="1.1 Hadoop 是什么"></a>1.1 Hadoop 是什么</h2><p>（1）Hadoop是一个由Apache基金会所开发的分布式系统基础架构<br>（2）主要解决海量数据的存储和海量数据的分析计算问题<br>（3）广义上来说，Hadoop通常是指一个更广泛的概念——Hadoop生态圈</p>
<h2 id="1-2-Hadoop-优势"><a href="#1-2-Hadoop-优势" class="headerlink" title="1.2 Hadoop 优势"></a>1.2 Hadoop 优势</h2><p>（1）高可靠性：Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。<br>（2）高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。<br>（3）高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。<br>（4）高容错性：能够自动将失败的任务重新分配。</p>
<h2 id="1-3-Hadoop-组成★★★★★"><a href="#1-3-Hadoop-组成★★★★★" class="headerlink" title="1.3 Hadoop 组成★★★★★"></a>1.3 Hadoop 组成★★★★★</h2><p><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/1.png"></p>
<p>在Hadoop1.x 时代，Hadoop中的MapReduce同时处理业务逻辑运算和资源的调度，耦合性较大。<br>在Hadoop2.x时代，增加了Yarn。Yarn只负责资源的调度，MapReduce 只负责运算。<br>Hadoop3.x在组成上没有变化。</p>
<h3 id="1-3-1-HDFS-架构概述"><a href="#1-3-1-HDFS-架构概述" class="headerlink" title="1.3.1 HDFS 架构概述"></a>1.3.1 HDFS 架构概述</h3><p>Hadoop Distributed File System，简称HDFS，是一个分布式文件系统。</p>
<p>（1）NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。<br>（2）DataNode(dn)：在本地文件系统存储文件块数据，以及块数据的校验和。<br>（3）Secondary NameNode(2nn)：每隔一段时间对NameNode元数据备份。</p>
<h3 id="1-3-2-YARN-架构概述"><a href="#1-3-2-YARN-架构概述" class="headerlink" title="1.3.2 YARN 架构概述"></a>1.3.2 YARN 架构概述</h3><p>Yet Another Resource Negotiator 简称YARN ，另一种资源协调者，是Hadoop 的资源管理器。</p>
<p><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/2.png"></p>
<p>ResourceManager(RM)：整个集群资源（内存、CPU等）的管理者<br>NodeManager(NM)：单个节点服务器资源的管理者。<br>ApplicationMaster(AM)：单个任务运行的管理者。<br>Container：容器，相当于一台独立的服务器，里面封装了任务运行所需要的资源，如内存、CPU、磁盘、网络等。</p>
<p>说明：<br>（1）客户端可以有多个<br>（2）集群上可以运行多个ApplicationMaster<br>（3）每个NodeManager上可以有多个Container</p>
<h3 id="1-3-3-MapReduce-架构概述"><a href="#1-3-3-MapReduce-架构概述" class="headerlink" title="1.3.3 MapReduce 架构概述"></a>1.3.3 MapReduce 架构概述</h3><p>MapReduce 将计算过程分为两个阶段：Map 和Reduce<br>1）Map 阶段并行处理输入数据<br>2）Reduce 阶段对Map 结果进行汇总</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/3.png"></h3><h3 id="1-3-4-HDFS、YARN、MapReduce-三者关系"><a href="#1-3-4-HDFS、YARN、MapReduce-三者关系" class="headerlink" title="1.3.4 HDFS、YARN、MapReduce 三者关系"></a>1.3.4 HDFS、YARN、MapReduce 三者关系</h3><p>如图所示：</p>
<p><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/4.png"></p>
<h3 id="1-3-5-大数据技术生态体系"><a href="#1-3-5-大数据技术生态体系" class="headerlink" title="1.3.5 大数据技术生态体系"></a>1.3.5 大数据技术生态体系</h3><p>如图所示：</p>
<p><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/5.png"></p>
<p>图中涉及的技术名词解释如下：</p>
<p>（1）Sqoop：Sqoop 是一款开源的工具，主要用于在Hadoop、Hive 与传统的数据库（MySQL）间进行数据的传递，可以将一个关系型数据库（例如 ：MySQL，Oracle 等）中的数据导进到Hadoop 的HDFS 中，也可以将HDFS 的数据导进到关系型数据库中。<br>（2）Flume：Flume 是一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume 支持在日志系统中定制各类数据发送方，用于收集数据。<br>（3）Kafka：Kafka 是一种高吞吐量的分布式发布订阅消息系统。<br>（4）Spark：Spark 是当前最流行的开源大数据内存计算框架。可以基于Hadoop 上存储的大数据进行计算。<br>（5）Flink：Flink 是当前最流行的开源大数据内存计算框架。用于实时计算的场景较多。<br>（6）Oozie：Oozie 是一个管理Hadoop 作业（job）的工作流程调度管理系统。<br>（7）HBase：HBase 是一个分布式的、面向列的开源数据库。HBase 不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。<br>（8）Hive：Hive 是基于Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的SQL 查询功能，可以将SQL 语句转换为MapReduce 任务进行运行。其优点是学习成本低，可以通过类SQL 语句快速实现简单的MapReduce 统计，不必开发专门的MapReduce 应用，十分适合数据仓库的统计分析。<br>（9）ZooKeeper：它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。</p>
<h3 id="1-3-6-推荐系统框架图"><a href="#1-3-6-推荐系统框架图" class="headerlink" title="1.3.6 推荐系统框架图"></a>1.3.6 推荐系统框架图</h3><p>推荐系统项目框架<br><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/6.png"></p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对Hadoop的详细介绍了，</strong></p>
<p><strong>详细的环境搭建教程，可以上csdn开发者论坛，博客园或者百度进行搜索，这里就不过多演示了.</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Spark大数据开发</title>
    <url>/2022/03/18/%E5%85%B3%E4%BA%8ESpark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="关于Spark大数据开发"><a href="#关于Spark大数据开发" class="headerlink" title="关于Spark大数据开发:"></a>关于Spark大数据开发:</h1><h1 id="一、Spark概述"><a href="#一、Spark概述" class="headerlink" title="一、Spark概述"></a>一、Spark概述</h1><h2 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h2><p>Spark，是一种”One Stack to rule them all”的大数据计算框架，期望使用一个技术堆栈就完美地解决大数据领域的各种计算任务。Apache官方，对Spark的定义就是：通用的大数据快速处理引擎。<br>Spark使用Spark RDD、Spark SQL、 Spark Streaming，MLlib，GraphX成功解决了大数据领城中，离线批处理、交互式查询、实时流计算、机器学习与图计算等最重要的任务和问题。<br>Spark除了一站式的特点之外，另外一个最重要的特点，就是基于内存进行计算，从而让它的速度可以达到MapReduce、Hive的数倍甚至数十倍！<br>现在已经有很多大公司正在生产环境下深度地使用Spark作为大数据的计算框架，包括eBay.Yahool、 BAT、网易、京东、华为、大众点评、优酷土豆、搜狗等等。<br>Spark同时也获得了多个世界顶级IT厂商的支持，包括IBM、 Intel等。</p>
<p>Spark，是一种通用的大数据计算框架，I正如传统大数据技术Hadoop的MapReduce、Hive引擎，以及Storm流式实时计算引擎等，<br>Spark包含了大数据领城常见的各种计算框架：比如Spark Core用于离线计算，Spark SQL用于交互式查询，Spark Streaming用于实时流式计算，Spark MILlib用于机器学习，Spark GraphX用于图计算。<br>Spark主要用于大数据的计算，而Hadoop以后主要用于大数据的存储（比如HDFS、Hive，HBase等），以及资源调度（Yarn）。</p>
<p>Spark+Hadoop的组合，是未来大数据领域最热门的组合，也是最有前景的组合！</p>
<h2 id="（2）Spark整体架构"><a href="#（2）Spark整体架构" class="headerlink" title="（2）Spark整体架构"></a>（2）Spark整体架构</h2><p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/1.png"></p>
<h2 id="（3）Spark特性："><a href="#（3）Spark特性：" class="headerlink" title="（3）Spark特性："></a>（3）Spark特性：</h2><p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/2.png"></p>
<h4 id="（1）spark-计算速度快"><a href="#（1）spark-计算速度快" class="headerlink" title="（1）spark 计算速度快"></a>（1）spark 计算速度快</h4><p>spark将每个任务构建成DAG进行计算，内部的计算过程通过弹性式分布式数据集RDD在内存在进行计算，相比于hadoop的mapreduce效率提升了100倍。</p>
<h4 id="（2）易于使用"><a href="#（2）易于使用" class="headerlink" title="（2）易于使用"></a>（2）易于使用</h4><p>spark 提供了大量的算子，开发只需调用相关api进行实现无法关注底层的实现原理。</p>
<p>通用的大数据解决方案</p>
<p>相较于以前离线任务采用mapreduce实现，实时任务采用storm实现，目前这些都可以通过spark来实现，降低来开发的成本。同时spark 通过spark SQL降低了用户的学习使用门槛，还提供了机器学习，图计算引擎等。</p>
<h4 id="（3）支持多种的资源管理模式"><a href="#（3）支持多种的资源管理模式" class="headerlink" title="（3）支持多种的资源管理模式"></a>（3）支持多种的资源管理模式</h4><p>学习使用中可以采用local 模型进行任务的调试，在正式环境中又提供了standalone，yarn等模式，方便用户选择合适的资源管理模式进行适配。</p>
<h4 id="（4）社区支持"><a href="#（4）社区支持" class="headerlink" title="（4）社区支持"></a>（4）社区支持</h4><p>spark 生态圈丰富，迭代更新快，成为大数据领域必备的计算引擎。</p>
<h2 id="（4）Spark与MR"><a href="#（4）Spark与MR" class="headerlink" title="（4）Spark与MR"></a>（4）Spark与MR</h2><p>MapReduce能够完成的各种离线批处理功能，以及常见算法（比如二次排序、topn等），基于Spark RDD的核心编程，都可以实现，并且可以更好地、更容易地实现。而且基于Spark RDD编写的离线批处理程序，运行速度是MapReduce的数倍，速度上有非常明显的优势。</p>
<p>Spark相较于MapReduce速度快的最主要原因就在于，MapReduce的计算模型太死板，必须是map-reduce模式，有时候即使完成一些诸如过滤之类的操作，也必须经过map-reduce过程，这样就必须经过shuffle过程。而<br>MapReduce的shuffle过程是最消耗性能的，因为shuffle中间的过程必须基于磁盘来读写。而Spark的shuffle虽然也要基于磁盘，但是其大量transformation操作，比如单纯的map或者filter等操作，可以直接基于内存进行pipeline操作，速度性能自然大大提升。</p>
<p>但是Spark也有其劣势。由于Spark基于内存进行计算，虽然开发容易，但是真正面对大数据的时候（比如一次操作针对10亿以上级别），在没有进行调优的情况下，可能会出现各种各样的问题，比如OOM内存溢出等等。导致Spark程序可能都无法完全运行起来，就报错挂掉了，而MapReduce即使是运行缓慢，但是至少可以慢慢运行完。</p>
<p>此外，Spark由于是新崛起的技术新秀，因此在大数据领域的完善程度，肯定不如MapReduce，比如基于HBase、Hive作为离线批处理程序的输入输出，Spark就远没有MapReduce来的完善。实现起来非常麻烦。</p>
<h2 id="（5）Spark-Streaming与Storm"><a href="#（5）Spark-Streaming与Storm" class="headerlink" title="（5）Spark Streaming与Storm"></a>（5）Spark Streaming与Storm</h2><p>Spark Streaming 与Storm都可以用于进行实时流计算。但是他们两者的区别是非常大的。其中区别之一，就是，Spark<br>Streaming 和Storm的计算模型完全不一样，Spark Streaming是基于RDD的，因此需要将一小段时间内的，比如1秒内的数据，收集起来，作为一个RDD，然后再针对这个batch的数据进行处理。而Storm却可以做到每来一条数据，都可以立即进行处理和计算。因此，Spark Streaming实际上严格意义上来说，只能称作准实时的流计算框架；西Storm是真正意义上的实时计算框架<br>此外，Storm支持的一项高级特性，是Spark Streaming暂时不具备的，即Storm支持在分布式流式计算程序（Topolopy）在运行过程中，可以动态地调整并行度，从而动态提高并发处理能力。而Spark Streaming是无法动态调整并行度的。<br>但是Spark Streaming也有其优点，首先Spark Streaming由于是基于batch进行处理的，因此相较于Storm基于单条数据进行处理，具有数倍甚至数十倍的吞吐量。<br>此外，Spark Streaming由于也身处于Spark生态圈内，因此Spark Streaming可以与Spark Core、 Spark SQL，甚至是Spark Mllib.Spark GraphX进行无缝整合。流式处理完的数据，可以立即进行各种map、reduce转换操作，可以立即使用sql进行查询，甚至可以立即使用machine learning或者图计算算法进行处理。这种一站式的大数据处理功能和优势，是Storm无法匹敌的。<br>因此，综合上述来看，通常在对实时性要求特别高，而且实时数据量不稳定，比如在白天有高峰期的情况下，可以选择使用Storm。但是如果是对实时性要求一般，允许1秒的准实时处理，而且不要求动态调整并行度的话，选择Spark Streaming是更好的选择。</p>
<h2 id="（6）Spark-SQL与Hive"><a href="#（6）Spark-SQL与Hive" class="headerlink" title="（6）Spark SQL与Hive"></a>（6）Spark SQL与Hive</h2><p>Spark SQL实际上并不能完全替代Hive,因为Hive是一种基于HDFS的数据仓库,并且提供了基于SQL模型的,针对存储了大数据的数据仓库,进行分布式交互查询的查询引擎。<br>严格的来说, Spark SQL能够替代的,是ive的查询引擎,而不是Hive本身,实际上即使在生产环境下, SparkSQL也是针对Hive数据仓库中的数据进行查询, Spark本身自己是不提供存储的,自然也不可能替代Hive作为数据仓库的这个功能。<br>Spark SQL的一个优点,相较于Hive查询引擎来说,就是速度快,同样的SQL语句,可能使用Hive的查询引擎,由于其底层基于 MapReduce,必须经过 shuffle过程走磁盘,因此速度是非常缓慢的。很多复杂的SQL语句,在hive中执行都需要一个小时以上的时间。而 Spark SQLSpark由于其底层基于自身的基于内存的特点,因此速度达到了Hive查询引擎的数倍以上。<br>而 Spark SQL相较于Hive的另外一个优点,就是支持大量不同的数据源,包括ive、json、 parquet、jdbc等等此外, Spark SQLSpark由于身处技术堆栈内,也是基于RDD来工作,因此可以与 Spark的其他组件无缝整合使用,配合起来实现许多复杂的功能。比如 Spark SQL支持可以直接针对hdfs文件执行sq语句!</p>
<h1 id="二、Spark基本原理"><a href="#二、Spark基本原理" class="headerlink" title="二、Spark基本原理"></a>二、Spark基本原理</h1><h2 id="（1）Spark-Core"><a href="#（1）Spark-Core" class="headerlink" title="（1）Spark Core"></a>（1）Spark Core</h2><p>Spark Core是Spark的核心，其包含如下几个部分：</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/3.png"></p>
<h3 id="（1）spark-基础配置"><a href="#（1）spark-基础配置" class="headerlink" title="（1）spark 基础配置"></a>（1）spark 基础配置</h3><p>sparkContext是spark应用程序的入口，spark应用程序的提交和执行离不开sparkContext，它隐藏了网络通信，分布式部署，消息通信，存储体系，计算存储等，开发人员只需要通过sparkContext等api进行开发即可。</p>
<p>sparkRpc 基于netty实现，分为异步和同步两种方式。事件总线主要用于sparkContext组件间的交换，它属于监听者模式，采用异步调用。度量系统主要用于系统的运行监控。</p>
<p>（2）spark 存储系统</p>
<p>它用于管理spark运行中依赖的数据存储方式和存储位置，spark的存储系统优先考虑在各节点以内存的方式存储数据，内存不足时将数据写入磁盘中，这也是spark计算性能高的重要原因。</p>
<p>我们可以灵活的控制数据存储在内存还是磁盘中，同时可以通过远程网络调用将结果输出到远程存储中，比如hdfs，hbase等。</p>
<p>（3）spark 调度系统</p>
<p>spark 调度系统主要由DAGScheduler和TaskScheduler组成。</p>
<p>DAGScheduler 主要是把一个Job根据RDD间的依赖关系，划分为多个Stage，对于划分后的每个Stage都抽象为一个或多个Task组成的任务集，并交给TaskScheduler来进行进一步的任务调度。而TaskScheduler 负责对每个具体的Task进行调度。</p>
<p>具体调度算法有FIFO，FAIR：</p>
<p>FIFO调度：先进先出，这是Spark默认的调度模式。<br>FAIR调度：支持将作业分组到池中，并为每个池设置不同的调度权重，任务可以按照权重来决定执行顺序。</p>
<h2 id="（2）Spark-SQL"><a href="#（2）Spark-SQL" class="headerlink" title="（2）Spark SQL"></a>（2）Spark SQL</h2><p>spark sql提供了基于sql的数据处理方法，使得分布式的数据集处理变的更加简单，这也是spark 广泛使用的重要原因。</p>
<p>目前大数据相关计算引擎一个重要的评价指标就是：是否支持sql，这样才会降低使用者的门槛。spark sql提供了两种抽象的数据集合DataFrame和DataSet。</p>
<p>DataFrame 是spark Sql 对结构化数据的抽象，可以简单的理解为spark中的表，相比较于RDD多了数据的表结构信息(schema).DataFrame = Data + schema</p>
<p>RDD是分布式对象集合，DataFrame是分布式Row的集合，提供了比RDD更丰富的算子，同时提升了数据的执行效率。</p>
<p>DataSet 是数据的分布式集合 ，它具有RDD强类型的优点 和Spark SQL优化后执行的优点。DataSet可以由jvm对象构建，然后使用map，filter，flatmap等操作函数操作。</p>
<h2 id="（3）Spark-Streaming"><a href="#（3）Spark-Streaming" class="headerlink" title="（3）Spark Streaming"></a>（3）Spark Streaming</h2><p>这个模块主要是对流数据的处理，支持流数据的可伸缩和容错处理，可以与Flume和Kafka等已建立的数据源集成。Spark Streaming的实现，也使用RDD抽象的概念，使得在为流数据编写应用程序时更为方便。</p>
<h2 id="（4）Spark基本工作原理"><a href="#（4）Spark基本工作原理" class="headerlink" title="（4）Spark基本工作原理"></a>（4）Spark基本工作原理</h2><p>Spark基本工作原理的理解，其最主要的是要搞清楚什么是RDD以及RDD的特性。深刻理解了RDD的特性，也就理解了数据在spark中是如何被处理的（spark的基本工作原理）</p>
<p>那么RDD是什么，官方说法：<br>RDD是Spark提供的核心抽象，全称为Resillient Distributed Dataset，即弹性分布式数据集。</p>
<p>最简单的理解：<br>RDD就是源数据的抽象，或者叫映射，或者就代表。也就是说，数据要被spark进行处理，在处理之前的首要任务就是要将数据映射成RDD，对于spark来说，RDD才是我们处理数据的规则，我只认RDD，只有RDD，通过我spark的计算引擎，才能发挥巨大的威力！</p>
<h3 id="（1）分布式数据集"><a href="#（1）分布式数据集" class="headerlink" title="（1）分布式数据集"></a>（1）分布式数据集</h3><p>RDD是Spark提供的核心抽象，全称为Resillient Distributed Dataset，即弹性分布式数据集。</p>
<p>RDD在抽象上来说是一种元素集合，包含了数据。它是被分区的，分为多个分区，每个分区分布在集群中的不同节点上，从而让RDD中的数据可以被并行操作。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/4.png"></p>
<h3 id="（2）弹性"><a href="#（2）弹性" class="headerlink" title="（2）弹性"></a>（2）弹性</h3><p>RDD的数据默认情况下存放在内存中的，但是在内存资源不足时，Spark会自动将RDD数据写入磁盘。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/5.png"></p>
<h3 id="（3）迭代式处理"><a href="#（3）迭代式处理" class="headerlink" title="（3）迭代式处理"></a>（3）迭代式处理</h3><p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/6.png"></p>
<p>对节点1、2、3、4上的数据进行处理完成之后，可能会移动到其他的节点内存中继续处理！Spark 与Mr最大的不同在与迭代式计算模型：Mr分为两个阶段，map和reduce，两个阶段处理完了就结束了，所以我们在一个job中能做的处理很有限，只能在map和reduce中处理；而spark计算过程可以分为n个阶段，因为他是内存迭代式的，我们在处理完一个阶段之后，可以继续往下处理很多阶段，而不是两个阶段。所以Spark相较于MR，计算模型可以提供更强大的功能。</p>
<h3 id="（4）容错性"><a href="#（4）容错性" class="headerlink" title="（4）容错性"></a>（4）容错性</h3><p>RDD最重要的特性就是，提供了容错性，可以自动从节点失败中恢复过来。即如果某个节点上的RDD partition，因为节点故障，导致数据丢了，那么RDD会自动通过自己的数据来源重新计算该partition。这一切对使用者是透明的。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/7.png"></p>
<h1 id="三、Spark-运行模式及集群角色"><a href="#三、Spark-运行模式及集群角色" class="headerlink" title="三、Spark 运行模式及集群角色"></a>三、Spark 运行模式及集群角色</h1><h2 id="（1）Spark运行模式"><a href="#（1）Spark运行模式" class="headerlink" title="（1）Spark运行模式"></a>（1）Spark运行模式</h2><table>
<thead>
<tr>
<th align="center"><strong>运行模式</strong></th>
<th align="center"><strong>运行类型</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">local</td>
<td align="center">本地模式</td>
<td align="center">常用于本地开发测试，分为local单线程和local-cluster多线程模式</td>
</tr>
<tr>
<td align="center">standalone</td>
<td align="center">集群模式</td>
<td align="center">独立模式，在spark自己的资源调度管理框架上运行，该框架采用master/salve结构</td>
</tr>
<tr>
<td align="center">yarn</td>
<td align="center">集群模式</td>
<td align="center">在yarn资源管理器框架上运行，由yarn负责资源管理，spark负责任务调度和计算</td>
</tr>
<tr>
<td align="center">mesos</td>
<td align="center">集群模式</td>
<td align="center">在mesos资源管理器框架上运行，由mesos负责资源管理，spark负责任务调度和计算</td>
</tr>
<tr>
<td align="center">k8s</td>
<td align="center">集群模式</td>
<td align="center">在k8s上运行</td>
</tr>
</tbody></table>
<h2 id="（2）Spark集群角色"><a href="#（2）Spark集群角色" class="headerlink" title="（2）Spark集群角色"></a>（2）Spark集群角色</h2><p>下图是spark的集群角色图，主要有集群管理节点cluster manager，工作节点worker，执行器executor，驱动器driver和应用程序application 五部分组成，下面详细说明每部分的特点。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/8.png"></p>
<h3 id="（1）Cluster-Manager"><a href="#（1）Cluster-Manager" class="headerlink" title="（1）Cluster Manager"></a>（1）Cluster Manager</h3><p>集群管理器，它存在于Master进程中，主要用来对应用程序申请的资源进行管理，根据其部署模式的不同，可以分为local，standalone，yarn，mesos等模式。</p>
<h3 id="（2）worker"><a href="#（2）worker" class="headerlink" title="（2）worker"></a>（2）worker</h3><p>worker是spark的工作节点，用于执行任务的提交，主要工作职责有下面四点：</p>
<p>worker节点通过注册机向cluster manager汇报自身的cpu，内存等信息。<br>worker 节点在spark master作用下创建并启用executor，executor是真正的计算单元。<br>spark master将任务Task分配给worker节点上的executor并执行运用。<br>worker节点同步资源信息和executor状态信息给cluster manager。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/9.png"></p>
<p>在yarn 模式下运行worker节点一般指的是NodeManager节点，standalone模式下运行一般指的是slave节点。</p>
<h3 id="（3）executor"><a href="#（3）executor" class="headerlink" title="（3）executor"></a>（3）executor</h3><p>executor 是真正执行计算任务的组件，它是application运行在worker上的一个进程。这个进程负责Task的运行，它能够将数据保存在内存或磁盘存储中，也能够将结果数据返回给Driver。</p>
<h3 id="（4）Application"><a href="#（4）Application" class="headerlink" title="（4）Application"></a>（4）Application</h3><p>application是Spark API 编程的应用程序，它包括实现Driver功能的代码和在程序中各个executor上要执行的代码，一个application由多个job组成。其中应用程序的入口为用户所定义的main方法。</p>
<h3 id="（5）Driver"><a href="#（5）Driver" class="headerlink" title="（5）Driver"></a>（5）Driver</h3><p>驱动器节点，它是一个运行Application中main函数并创建SparkContext的进程。application通过Driver 和Cluster Manager及executor进行通讯。它可以运行在application节点上，也可以由application提交给Cluster Manager，再由Cluster Manager安排worker进行运行。</p>
<p>Driver节点也负责提交Job，并将Job转化为Task，在各个Executor进程间协调Task的调度。</p>
<h3 id="（6）sparkContext"><a href="#（6）sparkContext" class="headerlink" title="（6）sparkContext"></a>（6）sparkContext</h3><p>sparkContext是整个spark应用程序最关键的一个对象，是Spark所有功能的主要入口点。核心作用是初始化spark应用程序所需要的组件，同时还负责向master程序进行注册等。</p>
<h2 id="（3）Spark其他核心概念"><a href="#（3）Spark其他核心概念" class="headerlink" title="（3）Spark其他核心概念"></a>（3）Spark其他核心概念</h2><h3 id="（1）RDD"><a href="#（1）RDD" class="headerlink" title="（1）RDD"></a>（1）RDD</h3><p>它是Spark中最重要的一个概念，是弹性分布式数据集，是一种容错的、可以被并行操作的元素集合，是Spark对所有数据处理的一种基本抽象。可以通过一系列的算子对rdd进行操作，主要分为Transformation和Action两种操作。</p>
<p>‍‍‍‍‍Transformation(转换)：是对已有的RDD进行换行生成新的RDD，对于转换过程采用惰性计算机制，不会立即计算出结果。常用的方法有map，filter，flatmap等。<br>Action(执行)：对已有对RDD对数据执行计算产生结果，并将结果返回Driver或者写入到外部存储中。常用到方法有reduce，collect，saveAsTextFile等。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/10.png"></p>
<h3 id="（2）DAG"><a href="#（2）DAG" class="headerlink" title="（2）DAG"></a>（2）DAG</h3><p>DAG是一个有向无环图，在Spark中， 使用 DAG 来描述我们的计算逻辑。主要分为DAG Scheduler 和Task Scheduler。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/11.png"></p>
<h3 id="（3）DAG-Scheduler"><a href="#（3）DAG-Scheduler" class="headerlink" title="（3）DAG Scheduler"></a>（3）DAG Scheduler</h3><p>DAG Scheduler 是面向stage的高层级的调度器，DAG Scheduler把DAG拆分为多个Task，每组Task都是一个stage，解析时是以shuffle为边界进行反向构建的，每当遇见一个shuffle，spark就会产生一个新的stage，接着以TaskSet的形式提交给底层的调度器（task scheduler），每个stage封装成一个TaskSet。DAG Scheduler需要记录RDD被存入磁盘物化等动作，同时会需要Task寻找最优等调度逻辑，以及监控因shuffle跨节点输出导致的失败。<br><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/12.png"></p>
<h3 id="（4）Task-Scheduler"><a href="#（4）Task-Scheduler" class="headerlink" title="（4）Task Scheduler"></a>（4）Task Scheduler</h3><p>Task Scheduler 负责每一个具体任务的执行。它的主要职责包括</p>
<p>任务集的调度管理<br>状态结果跟踪<br>物理资源调度管理<br>任务执行<br>获取结果</p>
<h3 id="（5）Job"><a href="#（5）Job" class="headerlink" title="（5）Job"></a>（5）Job</h3><p>job是有多个stage构建的并行的计算任务，job是由spark的action操作来触发的，在spark中一个job包含多个RDD以及作用在RDD的各种操作算子。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/13.png"></p>
<h3 id="（6）stage"><a href="#（6）stage" class="headerlink" title="（6）stage"></a>（6）stage</h3><p>DAG Scheduler会把DAG切割成多个相互依赖的Stage，划分Stage的一个依据是RDD间的宽窄依赖。</p>
<p>在对Job中的所有操作划分Stage时，一般会按照倒序进行，即从Action开始，遇到窄依赖操作，则划分到同一个执行阶段，遇到宽依赖操作，则划分一个新的执行阶段，且新的阶段为之前阶段的parent，然后依次类推递归执行。</p>
<p>child Stage需要等待所有的parent Stage执行完之后才可以执行，这时Stage之间根据依赖关系构成了一个大粒度的DAG。在一个Stage内，所有的操作以串行的Pipeline的方式，由一组Task完成计算。</p>
<h3 id="（7）TaskSet-Task"><a href="#（7）TaskSet-Task" class="headerlink" title="（7）TaskSet Task"></a>（7）TaskSet Task</h3><p>TaskSet 可以理解为一种任务，对应一个stage，是Task组成的任务集。一个TaskSet中的所有Task没有shuffle依赖可以并行计算。</p>
<p>Task是spark中最独立的计算单元，由Driver Manager发送到executer执行，通常情况一个task处理spark RDD一个partition。Task分为ShuffleMapTask和ResultTask两种，位于最后一个Stage的Task为ResultTask，其他阶段的属于ShuffleMapTask。</p>
<h1 id="四、Spark作业运行流程"><a href="#四、Spark作业运行流程" class="headerlink" title="四、Spark作业运行流程"></a>四、Spark作业运行流程</h1><h2 id="1-Spark作业运行流程"><a href="#1-Spark作业运行流程" class="headerlink" title="(1)Spark作业运行流程"></a>(1)Spark作业运行流程</h2><p>spark应用程序以进程集合为单位在分布式集群上运行，通过driver程序的main方法创建sparkContext的对象与集群进行交互。具体运行流程如下：</p>
<p>sparkContext向cluster Manager申请CPU，内存等计算资源。<br>cluster Manager分配应用程序执行所需要的资源，在worker节点创建executor。<br>sparkContext将程序代码和task任务发送到executor上进行执行，代码可以是编译成的jar包或者python文件等。接着sparkContext会收集结果到Driver端。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/14.png"></p>
<h2 id="（2）-Spark-RDD迭代过程"><a href="#（2）-Spark-RDD迭代过程" class="headerlink" title="（2） Spark RDD迭代过程"></a>（2） Spark RDD迭代过程</h2><p>sparkContext创建RDD对象，计算RDD间的依赖关系，并组成一个DAG有向无环图。<br>DAGScheduler将DAG划分为多个stage，并将stage对应的TaskSet提交到集群的管理中心，stage的划分依据是RDD中的宽窄依赖，spark遇见宽依赖就会划分为一个stage，每个stage中包含来一个或多个task任务，避免多个stage之间消息传递产生的系统开销。<br>taskScheduler 通过集群管理中心为每一个task申请资源并将task提交到worker的节点上进行执行。<br>worker上的executor执行具体的任务。<br><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/15.png"></p>
<h2 id="（3）Yarn资源管理器介绍"><a href="#（3）Yarn资源管理器介绍" class="headerlink" title="（3）Yarn资源管理器介绍"></a>（3）Yarn资源管理器介绍</h2><p>spark 程序一般是运行在集群上的，spark on yarn是工作或生产上用的非常多的一种运行模式。</p>
<p>没有yarn模式前，每个分布式框架都要跑在一个集群上面，比如说Hadoop要跑在一个集群上，Spark用集群的时候跑在standalone上。这样的话整个集群的资源的利用率低，且管理起来比较麻烦。</p>
<p>yarn是分布式资源管理和任务管理管理，主要由ResourceManager，NodeManager和ApplicationMaster三个模块组成。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/16.png"></p>
<p>ResourceManager 主要负责集群的资源管理，监控和分配。对于所有的应用它有绝对的控制权和资源管理权限。</p>
<p>NodeManager 负责节点的维护，执行和监控task运行状况。会通过心跳的方式向ResourceManager汇报自己的资源使用情况。</p>
<p>yarn资源管理器的每个节点都运行着一个NodeManager，是ResourceManager的代理。如果主节点的ResourceManager宕机后，会连接ResourceManager的备用节点。</p>
<p>ApplicationMaster 负责具体应用程序的调度和资源的协调，它会与ResourceManager协商进行资源申请。ResourceManager以container容器的形式将资源分配给application进行运行。同时负责任务的启停。</p>
<p>container 是资源的抽象，它封装着每个节点上的资源信息(cpu,内存，磁盘，网络等)，yarn将任务分配到container上运行，同时该任务只能使用container描述的资源，达到各个任务间资源的隔离。</p>
<h2 id="（4）Spark程序在Yarn上执行流程"><a href="#（4）Spark程序在Yarn上执行流程" class="headerlink" title="（4）Spark程序在Yarn上执行流程"></a>（4）Spark程序在Yarn上执行流程</h2><p>spark on yarn分为两种模式yarn-client模式，和yarn—cluster模式，一般线上采用的是yarn-cluster模式。</p>
<h3 id="（1）yarn-client模式"><a href="#（1）yarn-client模式" class="headerlink" title="（1）yarn-client模式"></a>（1）yarn-client模式</h3><p>driver在客户端本地执行，这种模式可以使得spark application和客户端进行交互，因为driver在客户端可以通过webUI访问driver的状态。同时Driver会与yarn集群中的Executor进行大量的通信，会造成客户机网卡流量的大量增加。</p>
<h3 id="（2）yarn-cluster模式"><a href="#（2）yarn-cluster模式" class="headerlink" title="（2）yarn-cluster模式"></a>（2）yarn-cluster模式</h3><p>Yarn-Cluster主要用于生产环境中，因为Driver运行在Yarn集群中某一台NodeManager中，每次提交任务的Driver所在的机器都是随机的，不会产生某一台机器网卡流量激增的现象，缺点是任务提交后不能看到日志。只能通过yarn查看日志。</p>
<p>下图是yarn-cluster运行模式：<br><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/17.png"></p>
<p>client 向yarn提交应用程序，包含ApplicationMaster程序、启动ApplicationMaster的命令、需要在Executor中运行的程序等。<br>ApplicationMaster程序启动ApplicationMaster的命令、需要在Executor中运行的程序等。<br>ApplicationMaster向ResourceManager注册，这样用户可以直接通过ResourceManage查看应用程序的运行状态。<br>ApplicationMaster申请到资源（也就是Container）后，便与对应的NodeManager通信，启动Task。<br>Task向ApplicationMaster汇报运行的状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。<br>应用程序运行完成后，ApplicationMaster向ResourceManager申请注销并关闭自己。</p>
<h1 id="五、基于WordCount程序开发"><a href="#五、基于WordCount程序开发" class="headerlink" title="五、基于WordCount程序开发"></a>五、基于WordCount程序开发</h1><p>下面使用Java和Scala语言编写WordCount程序</p>
<h2 id="（1）Java开发WordCount程序"><a href="#（1）Java开发WordCount程序" class="headerlink" title="（1）Java开发WordCount程序"></a>（1）Java开发WordCount程序</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">package com.kfk.spark;</span><br><span class="line"></span><br><span class="line">import org.apache.spark.SparkConf;</span><br><span class="line">import org.apache.spark.api.java.JavaPairRDD;</span><br><span class="line">import org.apache.spark.api.java.JavaRDD;</span><br><span class="line">import org.apache.spark.api.java.JavaSparkContext;</span><br><span class="line">import org.apache.spark.api.java.function.FlatMapFunction;</span><br><span class="line">import org.apache.spark.api.java.function.Function2;</span><br><span class="line">import org.apache.spark.api.java.function.PairFunction;</span><br><span class="line">import org.apache.spark.api.java.function.VoidFunction;</span><br><span class="line">import scala.Tuple2;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : </span><br><span class="line"> * @email :</span><br><span class="line"> * @date : </span><br><span class="line"> * @time : </span><br><span class="line"> */</span><br><span class="line">public class WordCountJava {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        SparkConf sparkConf = new SparkConf().setAppName("wordCountApp").setMaster("local");</span><br><span class="line"></span><br><span class="line">        JavaSparkContext sc = new JavaSparkContext(sparkConf);</span><br><span class="line"></span><br><span class="line">        JavaRDD lines = sc.textFile("hdfs://bigdata-pro-m04:9000/user/caizhengjie/datas/wordcount.txt");</span><br><span class="line"></span><br><span class="line">        JavaRDD words = lines.flatMap(new FlatMapFunction&lt;String,String&gt;() {</span><br><span class="line">            public Iterator call(String line) throws Exception {</span><br><span class="line">                return Arrays.asList(line.split(" ")).iterator();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        JavaPairRDD word = words.mapToPair(new PairFunction&lt;String,String,Integer&gt;() {</span><br><span class="line">            public Tuple2 call(String word) throws Exception {</span><br><span class="line">                return new Tuple2(word,1);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        JavaPairRDD wordcount = word.reduceByKey(new Function2&lt;Integer,Integer,Integer&gt;() {</span><br><span class="line">            public Integer call(Integer v1, Integer v2) throws Exception {</span><br><span class="line">                return v1+ v2;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        wordcount.foreach(new VoidFunction&lt;Tuple2&lt;String,Integer&gt;&gt;() {</span><br><span class="line">            public void call(Tuple2&lt;String,Integer&gt; o) throws Exception {</span><br><span class="line">                System.out.println(o._1 + " : " + o._2);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">spark : 1</span><br><span class="line">hive : 3</span><br><span class="line">hadoop : 3</span><br><span class="line">python : 1</span><br><span class="line">flink : 2</span><br><span class="line">java : 5</span><br><span class="line">storm : 1</span><br><span class="line">hbase : 1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="（2）Scala开发WordCount程序"><a href="#（2）Scala开发WordCount程序" class="headerlink" title="（2）Scala开发WordCount程序"></a>（2）Scala开发WordCount程序</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">package com.kfk.spark</span><br><span class="line"></span><br><span class="line">import org.apache.spark.{SparkConf, SparkContext}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : </span><br><span class="line"> * @email :</span><br><span class="line"> * @date : </span><br><span class="line"> * @time : </span><br><span class="line"> */</span><br><span class="line">object WordCountScala {</span><br><span class="line">    def main(args: Array[String]): Unit = {</span><br><span class="line">        val sparkConf = new SparkConf().setAppName("wordCountApp").setMaster("local")</span><br><span class="line">        val sc = new SparkContext(sparkConf)</span><br><span class="line">        val lines = sc.textFile("hdfs://bigdata-pro-m04:9000/user/caizhengjie/datas/wordcount.txt")</span><br><span class="line"></span><br><span class="line">        // val wordcount = lines.flatMap(line =&gt; line.split(" ")).map(word =&gt; (word,1)).reduceByKey((x,y) =&gt; (x+y)).foreach((_wordcount =&gt; println(_wordcount._1 + " : " + _wordcount._2))</span><br><span class="line"></span><br><span class="line">        val words = lines.flatMap(line =&gt; line.split(" "))</span><br><span class="line">        val word = words.map(word =&gt; (word,1))</span><br><span class="line">        val wordcount = word.reduceByKey((x,y) =&gt; (x+y))</span><br><span class="line"></span><br><span class="line">        // println(wordcount.collect().toList)</span><br><span class="line"></span><br><span class="line">        wordcount.foreach(_wordcount =&gt; println(_wordcount._1 + " : " + _wordcount._2))</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">spark : 1</span><br><span class="line">hive : 3</span><br><span class="line">hadoop : 3</span><br><span class="line">python : 1</span><br><span class="line">flink : 2</span><br><span class="line">java : 5</span><br><span class="line">storm : 1</span><br><span class="line">hbase : 1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="（3）程序打包提交Spark集群测试"><a href="#（3）程序打包提交Spark集群测试" class="headerlink" title="（3）程序打包提交Spark集群测试"></a>（3）程序打包提交Spark集群测试</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">bin/spark-submit --class com.kfk.spark.WordCountJava --master local[2] /opt/jars/wordcountjava.jar </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">spark : 1</span><br><span class="line">hive : 3</span><br><span class="line">hadoop : 3</span><br><span class="line">python : 1</span><br><span class="line">flink : 2</span><br><span class="line">java : 5</span><br><span class="line">storm : 1</span><br><span class="line">hbase : 1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对Spark大数据技术的详细介绍了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于二叉树的定义</title>
    <url>/2020/11/18/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h2 id="关于二叉树的种类"><a href="#关于二叉树的种类" class="headerlink" title="关于二叉树的种类:"></a>关于二叉树的种类:</h2><hr>
<h3 id="一、满二叉树"><a href="#一、满二叉树" class="headerlink" title="一、满二叉树"></a>一、满二叉树</h3><hr>
<p>满二叉树：<br>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。深度为k，有2^k-1个节点的二叉树。</p>
<h3 id="二、完全二叉树"><a href="#二、完全二叉树" class="headerlink" title="二、完全二叉树"></a>二、完全二叉树</h3><hr>
<p>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1 个节点。</p>
<p>我们可以给完全二叉树编号，这样父子之间就可以通过编号轻松求出。<br>比如我给所有节点从左到右从上到下依次从 1 开始编号。</p>
<p>那么已知一个节点的编号是 i，那么其左子节点就是 2 i，右子节点就是 2 1 + 1，父节点就是 (i + 1) / 2。</p>
<hr>
<h2 id="2-二叉树的最大宽度"><a href="#2-二叉树的最大宽度" class="headerlink" title="(2)二叉树的最大宽度"></a>(2)二叉树的最大宽度</h2><h3 id="一、序列化二叉树"><a href="#一、序列化二叉树" class="headerlink" title="一、序列化二叉树"></a>一、序列化二叉树</h3><h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><p>二叉搜索树是有数值的了，二叉搜索树是一个有序树。</p>
<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>它的左、右子树也分别为二叉排序树</p>
<h3 id="二、平衡二叉搜索树"><a href="#二、平衡二叉搜索树" class="headerlink" title="二、平衡二叉搜索树"></a>二、平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：</p>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>对于一个二叉查找树，常规操作有插入，查找，删除，找父节点，求最大值，求最小值。</p>
<h5 id="核心：二叉搜索树的中序遍历的结果是一个有序数组"><a href="#核心：二叉搜索树的中序遍历的结果是一个有序数组" class="headerlink" title="核心：二叉搜索树的中序遍历的结果是一个有序数组"></a>核心：二叉搜索树的中序遍历的结果是一个有序数组</h5><h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><h6 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h6><h6 id="二叉搜索树迭代器"><a href="#二叉搜索树迭代器" class="headerlink" title="二叉搜索树迭代器"></a>二叉搜索树迭代器</h6><h6 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h6><h6 id="一个中心"><a href="#一个中心" class="headerlink" title="一个中心"></a>一个中心</h6><h3 id="三、树的遍历："><a href="#三、树的遍历：" class="headerlink" title="三、树的遍历："></a>三、树的遍历：</h3><p>遍历不是目的，遍历是为了更好地做处理，这里的处理包括搜索，修改树等。</p>
<p>树虽然只能从根开始访问，但是可以选择在访问完毕回来的时候做处理，</p>
<p>还是在访问回来之前做处理，这两种不同的方式就是后序遍历和先序遍历。</p>
<h5 id="其中有两个重要知识点："><a href="#其中有两个重要知识点：" class="headerlink" title="其中有两个重要知识点："></a>其中有两个重要知识点：</h5><h6 id="DFS（深度优先遍历）"><a href="#DFS（深度优先遍历）" class="headerlink" title="DFS（深度优先遍历）"></a>DFS（深度优先遍历）</h6><h6 id="BFS（宽度优先遍历）"><a href="#BFS（宽度优先遍历）" class="headerlink" title="BFS（宽度优先遍历）"></a>BFS（宽度优先遍历）</h6><h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对二叉树的详细介绍了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数据库</title>
    <url>/2021/03/18/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="关于数据库"><a href="#关于数据库" class="headerlink" title="关于数据库:"></a>关于数据库:</h1><h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><h3 id="数据库管理系统DBMS"><a href="#数据库管理系统DBMS" class="headerlink" title="数据库管理系统DBMS"></a>数据库管理系统DBMS</h3><ul>
<li>是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。<br>它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。<br>用户通过DBMS访问数据库中的数据，数据库管理员也通过dbms进行数据库的维护工作。<br>数据库管理系统是数据库系统的核心，是管理数据库的软件。<br>我们一般说的数据库,就是指的DBMS: 数据库管理系统</li>
</ul>
<h3 id="常见的数据库"><a href="#常见的数据库" class="headerlink" title="常见的数据库"></a>常见的数据库</h3><ul>
<li><p>Oracle</p>
<ul>
<li>运行稳定，可移植性高，功能齐全，性能超群！适用于大型企业领域。</li>
</ul>
</li>
<li><p>DB2</p>
<ul>
<li>速度快、可靠性好，适于海量数据，恢复性极强。适用于大中型企业领域。</li>
</ul>
</li>
<li><p>MySQL</p>
<ul>
<li>开源，跨平台、体积小，速度快。适用于于中小型企业领域。</li>
</ul>
</li>
<li><p>SQL Server</p>
<ul>
<li>全面，效率高，界面友好，操作容易，但是不跨平台。适用于于中小型企业领域。</li>
</ul>
</li>
</ul>
<h3 id="结构化查询语言SQL"><a href="#结构化查询语言SQL" class="headerlink" title="结构化查询语言SQL"></a>结构化查询语言SQL</h3><ul>
<li>SQL语言的功能包括查询、操纵、定义和控制，是一个综合的、通用的关系数据库语言，同时又是一种高度非过程化的语言，只要求用户指出做什么而不需要指出怎么做。</li>
</ul>
<h3 id="非关系型数据库NoSql"><a href="#非关系型数据库NoSql" class="headerlink" title="非关系型数据库NoSql"></a>非关系型数据库NoSql</h3><ul>
<li>MongoDB,Redis,HBase…</li>
</ul>
<h2 id="RDBMS专业术语"><a href="#RDBMS专业术语" class="headerlink" title="RDBMS专业术语"></a>RDBMS专业术语</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul>
<li>具有固定的列数,和任意的行数</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>数据库是一些关联表的集合</li>
</ul>
<h3 id="列"><a href="#列" class="headerlink" title="列"></a>列</h3><ul>
<li>一个数据项 Field   字段</li>
</ul>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><ul>
<li>一条记录  row</li>
</ul>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><ul>
<li>主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
</ul>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><ul>
<li>外键用于关联两个表</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
</ul>
<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><h3 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h3><ul>
<li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</li>
<li>MySQL是开源的，所以你不需要支付额外的费用。</li>
<li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>MySQL使用标准的SQL数据语言形式。</li>
<li>MySQL可以安装在多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。</li>
</ul>
<h3 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h3><ul>
<li>windows安装</li>
<li>Mac安装</li>
</ul>
<h3 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h3><ul>
<li><p>什么是存储引擎</p>
<ul>
<li>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</li>
<li>不同的存储引擎性能是不一样的</li>
</ul>
</li>
<li><p>什么是事务</p>
<ul>
<li>是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</li>
</ul>
</li>
<li><p>存储引擎分类</p>
<ul>
<li><p>MYISAM</p>
<ul>
<li><p>它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。</p>
</li>
<li><p>每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：</p>
<ul>
<li>.frm(存储表定义)</li>
<li>MYD(MYData，存储数据)</li>
<li>MYI(MYIndex，存储索引)</li>
</ul>
</li>
</ul>
</li>
<li><p>INNODB</p>
<ul>
<li>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</li>
</ul>
</li>
<li><p>MEMORY</p>
<ul>
<li>memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm</li>
<li>MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用数据库命令"><a href="#常用数据库命令" class="headerlink" title="常用数据库命令"></a>常用数据库命令</h2><h3 id="MySQL数据库分为两种"><a href="#MySQL数据库分为两种" class="headerlink" title="MySQL数据库分为两种"></a>MySQL数据库分为两种</h3><h4 id="一、系统数据库-数据库服务器自带的-自带的4个"><a href="#一、系统数据库-数据库服务器自带的-自带的4个" class="headerlink" title="一、系统数据库(数据库服务器自带的,自带的4个)"></a>一、系统数据库(数据库服务器自带的,自带的4个)</h4><ul>
<li><p>information_schema</p>
<ul>
<li>存储数据库对象信息</li>
</ul>
</li>
</ul>
<p>如用户表信息,列信息,根除,字符,分区<br>里面的内容我们不能动.</p>
<ul>
<li><p>performance_schema</p>
<ul>
<li>存储数据库服务器性能参数信息</li>
</ul>
</li>
<li><p>MySQL</p>
<ul>
<li>存储数据库用户权限信息</li>
</ul>
</li>
<li><p>test</p>
<ul>
<li>一个空的数据库，用户可以使用它也可以不使用它</li>
</ul>
</li>
</ul>
<h4 id="二、用户数据库"><a href="#二、用户数据库" class="headerlink" title="二、用户数据库"></a>二、用户数据库</h4><ul>
<li>用户自己创建的数据库,一个项目用一个数据库</li>
</ul>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul>
<li>create database 数据库名称;</li>
</ul>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul>
<li>drop database 数据库名称;</li>
</ul>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><ul>
<li>show databases;</li>
</ul>
<h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><ul>
<li>use 数据库名;</li>
</ul>
<h3 id="查看数据库当中有多少张表"><a href="#查看数据库当中有多少张表" class="headerlink" title="查看数据库当中有多少张表"></a>查看数据库当中有多少张表</h3><ul>
<li>show  tables;</li>
</ul>
<p><strong>请注意”写的顺序,先使用数据库,再去查有多少张表”</strong></p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对MySQL数据库的详细介绍了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于SQL语言</title>
    <url>/2021/09/18/%E5%85%B3%E4%BA%8ESQL%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="关于SQL语言"><a href="#关于SQL语言" class="headerlink" title="关于SQL语言:"></a>关于SQL语言:</h1><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h3 id="字符集的由来"><a href="#字符集的由来" class="headerlink" title="字符集的由来"></a>字符集的由来</h3><ul>
<li>计算机只能识别二进制代码无论是计算机程序还是数据，最终都会转换成二进制，计算机才能认识。</li>
<li>为了计算机不只能做科学计算，也能处理文字信息。<br>人们想出了给每一个文字符号编码以便于计算识别处理的办法，这就是计算机字符集的由来。</li>
</ul>
<h3 id="ASSCII"><a href="#ASSCII" class="headerlink" title="ASSCII"></a>ASSCII</h3><ul>
<li><p>一套文字符号及其编码,比较规则 的集合。</p>
<ul>
<li>20世纪60年代初。美国标准化组织ANSI发布了第一个字符集。ASCII</li>
<li>后来又进一步变成了国际标准ISO-646</li>
</ul>
</li>
<li><p>各大字符集</p>
<ul>
<li><p>自ASCII后。为了处理不同的文字。各大计算机公司，各国，标准化政府，组织先后发明了几百种字符集。</p>
<ul>
<li>ISO-8859</li>
<li>GB2312-80</li>
<li>GBK</li>
<li>BIG5</li>
</ul>
</li>
<li><p>这些五花八门的字符集从收录的字符集到编码规则各不相同。给计算机软件开发和移值带来了很大的困难。</p>
</li>
</ul>
</li>
</ul>
<p>一个软件要在使用不同文字的国家和地区发布，必须得要做本地化开发。<br>    - 基于这个原因，要统一字符编码。</p>
<h3 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h3><ul>
<li>为了统一字符编码。国际标准化组织ISO的一些成员国于1984年发起制定了新的国际字符集标准。容纳全世界各种语言，文字，和  符号。最后产生了这个标准ISO-10646</li>
<li>ISO-10646发布后，遭到了美国计算机公司的反对。</li>
<li>1988年，Xerox公司提议制定了新的以16位编码人统一字符集。并联合了Apple,IBM,SUN，Microsoft等公司成立了Unicode技术委员会。专门负责收集，整理，和编码。于1991年推出了Unicode1.0</li>
<li>针对字符编码统一问题，ISO和Unicode协会推出了各自不同的标准。这显然是不利的。后来双方开始谈判。1991年10月达成协议。ISO将Unicode收编。起了个名BMP</li>
</ul>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><ul>
<li>ISO-10646编码空间足以容纳从古自今使用过的文字和字符。但很多文字字符已经很少用了。<br>超过99%的在用文字字符都编入了BMP.因此，绝大部分情况下，Unicode双字节方式都能满足需求。<br>而且比双字节编码方式4字节原始编码来说，更节省内存和处理时间 。这也是Unicode流行的原因。</li>
<li>万一使用了BMP以外的文字怎么办？<br>Unicode提出了UTF-16的解决办法。</li>
</ul>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><ul>
<li>虽然UTF-16解决了上面问题。但当时的计算机和网络世界还是ASCII的天下。只能处理单字节数据流。UTF-16离开了Unicode环境后。在传输和处理中，都存在问题。</li>
<li>于是又提出了UTF-8的解决文案，</li>
<li>UTF-8按一定的规则，将一个ISO10646或Unicode转换成1至4个字节的编码</li>
<li>其中ASCII转成单字节编码。也就严格兼容了ASCII字符集。</li>
<li>UTF-8的2，3，4字节用以转换ISO-10646标准的UCS-4原始码。</li>
</ul>
<h3 id="汉字的一些常见字符集"><a href="#汉字的一些常见字符集" class="headerlink" title="汉字的一些常见字符集"></a>汉字的一些常见字符集</h3><ul>
<li>GB2312</li>
<li>GB13000</li>
<li>GBK</li>
<li>GB18030</li>
</ul>
<h2 id="MySql存储引擎"><a href="#MySql存储引擎" class="headerlink" title="MySql存储引擎"></a>MySql存储引擎</h2><h3 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h3><ul>
<li>存储，管理和使用数据的不同结构形式，如：表、视图、存储过程、函数、触发器、事件等。</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>存储数据库对象的容器。</li>
</ul>
<h3 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h3><ul>
<li>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。</li>
<li>每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。</li>
<li>通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</li>
<li>不同的存储引擎性能是不一样的</li>
</ul>
<h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul>
<li>是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</li>
</ul>
<h3 id="存储引擎分类"><a href="#存储引擎分类" class="headerlink" title="存储引擎分类"></a>存储引擎分类</h3><ul>
<li><p>MYISAM</p>
<ul>
<li><p>它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。</p>
</li>
<li><p>每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：</p>
<ul>
<li>.frm(存储表定义)</li>
<li>MYD(MYData，存储数据)</li>
<li>MYI(MYIndex，存储索引)</li>
</ul>
</li>
</ul>
</li>
<li><p>INNODB</p>
<ul>
<li>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</li>
</ul>
</li>
<li><p>MEMORY</p>
<ul>
<li>memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm</li>
<li>MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。</li>
</ul>
</li>
</ul>
<h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><h3 id="SQL是Structured-Quevy-Language-结构化查询语言-的缩写。"><a href="#SQL是Structured-Quevy-Language-结构化查询语言-的缩写。" class="headerlink" title="SQL是Structured Quevy Language(结构化查询语言)的缩写。"></a>SQL是Structured Quevy Language(结构化查询语言)的缩写。</h3><h3 id="SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。"><a href="#SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。" class="headerlink" title="SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。"></a>SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。</h3><h3 id="在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。"><a href="#在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。" class="headerlink" title="在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。"></a>在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。</h3><h3 id="SQL语言功能很强，其核心功能只用了6个命令，分别是SELECT、CREATE、INSERT、DELETE、UPDATE、和GRANT-REVOKE-。"><a href="#SQL语言功能很强，其核心功能只用了6个命令，分别是SELECT、CREATE、INSERT、DELETE、UPDATE、和GRANT-REVOKE-。" class="headerlink" title="SQL语言功能很强，其核心功能只用了6个命令，分别是SELECT、CREATE、INSERT、DELETE、UPDATE、和GRANT(REVOKE)。"></a>SQL语言功能很强，其核心功能只用了6个命令，分别是SELECT、CREATE、INSERT、DELETE、UPDATE、和GRANT(REVOKE)。</h3><h2 id="sql功能分类"><a href="#sql功能分类" class="headerlink" title="sql功能分类"></a>sql功能分类</h2><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL:数据定义语言"></a>DDL:数据定义语言</h3><ul>
<li>用来定义数据库对象：创建库，表，列等。</li>
</ul>
<h3 id="DML：数据操作语言"><a href="#DML：数据操作语言" class="headerlink" title="DML：数据操作语言"></a>DML：数据操作语言</h3><ul>
<li>用来操作数据库表中的记录</li>
</ul>
<h3 id="DQL：数据查询语言"><a href="#DQL：数据查询语言" class="headerlink" title="DQL：数据查询语言"></a>DQL：数据查询语言</h3><ul>
<li>用来查询数据</li>
</ul>
<h3 id="DCL：数据控制语言"><a href="#DCL：数据控制语言" class="headerlink" title="DCL：数据控制语言"></a>DCL：数据控制语言</h3><ul>
<li>用来定义访问权限和安全级别</li>
</ul>
<h2 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h2><h3 id="MySQL中定义数据字段的类型对你数据库的优化是非常重要的。"><a href="#MySQL中定义数据字段的类型对你数据库的优化是非常重要的。" class="headerlink" title="MySQL中定义数据字段的类型对你数据库的优化是非常重要的。"></a>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。</h3><h3 id="MySQL支持所有标准SQL数值数据类型。"><a href="#MySQL支持所有标准SQL数值数据类型。" class="headerlink" title="MySQL支持所有标准SQL数值数据类型。"></a>MySQL支持所有标准SQL数值数据类型。</h3><h3 id="MySQL支持多种类型，大致可以分为三类"><a href="#MySQL支持多种类型，大致可以分为三类" class="headerlink" title="MySQL支持多种类型，大致可以分为三类"></a>MySQL支持多种类型，大致可以分为三类</h3><ul>
<li><p>数值类型</p>
</li>
<li><p>字符串类型</p>
</li>
<li><p>日期和时间类型</p>
</li>
</ul>
<h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><ul>
<li>double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；</li>
<li>char：固定长度字符串类型； char(10)  ‘abc       ‘</li>
<li>varchar：可变长度字符串类型；varchar(10) ‘abc’</li>
<li>text：字符串类型;</li>
<li>blob：二进制类型；</li>
<li>date：日期类型，格式为：yyyy-MM-dd；</li>
<li>time：时间类型，格式为：hh:mm:ss</li>
<li>datetime:日期时间类型 yyyy-MM-dd hh:mm:ss</li>
</ul>
<h3 id="在mysql中，字符串类型和日期类型都要用单引号括起来。"><a href="#在mysql中，字符串类型和日期类型都要用单引号括起来。" class="headerlink" title="在mysql中，字符串类型和日期类型都要用单引号括起来。"></a>在mysql中，字符串类型和日期类型都要用单引号括起来。</h3><p>‘Myxq’  ‘2020-01-01’</p>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul>
<li>create database 数据库名  character set utf8;</li>
</ul>
<h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><ul>
<li>alter database 数据库名 charactor set gbk;</li>
</ul>
<h3 id="显示当前数据库"><a href="#显示当前数据库" class="headerlink" title="显示当前数据库"></a>显示当前数据库</h3><ul>
<li>select  database( );</li>
</ul>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul>
<li>drop  database  数据库名；</li>
</ul>
<h3 id="创建学生表"><a href="#创建学生表" class="headerlink" title="创建学生表"></a>创建学生表</h3><h3 id="添加一列"><a href="#添加一列" class="headerlink" title="添加一列"></a>添加一列</h3><ul>
<li>ALTER TABLE 表名 ADD 列名 数据类型;</li>
</ul>
<h3 id="查看表的字段信息"><a href="#查看表的字段信息" class="headerlink" title="查看表的字段信息"></a>查看表的字段信息</h3><ul>
<li>DESC 表名;</li>
</ul>
<h3 id="修改一个表的字段类型"><a href="#修改一个表的字段类型" class="headerlink" title="修改一个表的字段类型"></a>修改一个表的字段类型</h3><ul>
<li>ALTER TABLE 表名 MODIFY 字段名  数据类型;</li>
</ul>
<h3 id="删除一列"><a href="#删除一列" class="headerlink" title="删除一列"></a>删除一列</h3><ul>
<li>ALTER TABLE 表名 DROP 字段名;</li>
</ul>
<h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><ul>
<li>RENAME TABLE 原始表名 TO  要修改的表名;</li>
</ul>
<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><ul>
<li>create table 新表名 like 参照表名；</li>
</ul>
<h3 id="查看表的创建细节"><a href="#查看表的创建细节" class="headerlink" title="查看表的创建细节"></a>查看表的创建细节</h3><ul>
<li>SHOW CREATE TABLE 表名;</li>
</ul>
<h3 id="修改表的字符集为gbk"><a href="#修改表的字符集为gbk" class="headerlink" title="修改表的字符集为gbk"></a>修改表的字符集为gbk</h3><ul>
<li>ALTER TABLE 表名 CHARACTER SET 字符集名称;</li>
</ul>
<h3 id="修改表的列名"><a href="#修改表的列名" class="headerlink" title="修改表的列名"></a>修改表的列名</h3><ul>
<li>ALTER TABLE 表名 CHANGE 原始列名 新列名 数据类型;</li>
</ul>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ul>
<li>DROP TABLE 表名;</li>
</ul>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="查询表中的所有数据"><a href="#查询表中的所有数据" class="headerlink" title="查询表中的所有数据"></a>查询表中的所有数据</h3><ul>
<li>SELECT * FROM 表名;</li>
</ul>
<h3 id="DML是对表中的数据进行增、删、改的操作"><a href="#DML是对表中的数据进行增、删、改的操作" class="headerlink" title="DML是对表中的数据进行增、删、改的操作"></a>DML是对表中的数据进行增、删、改的操作</h3><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ul>
<li><p>INSERT INTO 表名（列名1，列名2 …）VALUES  (列值1，列值2…);</p>
</li>
<li><p>注意事项</p>
<ul>
<li>列名与列值的类型、个数、顺序要一一对应。</li>
<li>值不要超出列定义的长度。</li>
<li>插入的日期和字符一样，都使用引号括起来。</li>
</ul>
</li>
<li><p>批量插入</p>
<ul>
<li>INSERT INTO 表名（列名1，列名2 …）VALUES (列值1，列值2…)，(列值1，列值2…);</li>
</ul>
</li>
</ul>
<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><ul>
<li><p>UPDATE 表名 SET 列名1=列值1，列名2=列值2 。。。 WHERE 列名=值</p>
</li>
<li><p>把所有学生的分数改为90</p>
<ul>
<li>update students set  score=90</li>
</ul>
</li>
<li><p>把姓名为张三的学生分数改为60</p>
<ul>
<li>update student set score=60 where name=’张三’;</li>
</ul>
</li>
<li><p>把姓名为李四的年龄改为20和分数改为70</p>
<ul>
<li>update student set age=20,score=70 where name=’李四’;</li>
</ul>
</li>
<li><p>把赵六的年龄在原来基础上加1岁</p>
<ul>
<li>update students set age=age+1 where name=’赵六’;</li>
</ul>
</li>
<li><p>修改数据库密码</p>
<ul>
<li>use mysql;</li>
<li>update user set password=password(‘abc’) WHERE User=’root’;</li>
<li>flush privileges;刷新MySQL的系统权限相关表</li>
<li>mysqladmin -u root -p password 12356</li>
</ul>
</li>
</ul>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li><p>DELETE FROM 表名 【WHERE 列名=值】</p>
</li>
<li><p>TRUNCATE TABLE 表名;</p>
</li>
<li><p>DELETED 与TRUNCATE的区别</p>
<ul>
<li>DELETE 删除表中的数据，表结构还在;删除后的数据可以找回</li>
<li>TRUNCATE 删除是把表直接DROP掉，然后再创建一个同样的新表。</li>
</ul>
</li>
</ul>
<p>删除的数据不能找回。执行速度比DELETE快。</p>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="查询所有列"><a href="#查询所有列" class="headerlink" title="查询所有列"></a>查询所有列</h3><ul>
<li>SELECT * FROM 表名;</li>
</ul>
<h3 id="结果集"><a href="#结果集" class="headerlink" title="结果集"></a>结果集</h3><ul>
<li><p>数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。</p>
</li>
<li><p>结果集</p>
<ul>
<li>通过查询语句查询出来的数据以表的形式展示我们称这个表为虚拟结果集。存放在内存中。</li>
<li>查询返回的结果集是一张虚拟表。</li>
</ul>
</li>
</ul>
<h3 id="查询指定列的数据"><a href="#查询指定列的数据" class="headerlink" title="查询指定列的数据"></a>查询指定列的数据</h3><ul>
<li>SELECT 列名1，列表2… FROM 表名;</li>
</ul>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul>
<li><p>条件查询就是在查询时给出WHERE子句，在WHERE子句中可以使用一些运算符及关键字：</p>
</li>
<li><p>条件查询运行符及关键字</p>
<ul>
<li><p>=（等于）、!=（不等于）、&lt;&gt;（不等于）、&lt;（小于）、&lt;=（小于等于）、&gt;（大于）、&gt;=（大于等于）；</p>
</li>
<li><p>BETWEEN…AND；值在什么范围</p>
</li>
<li><p>IN(set)；</p>
<ul>
<li>固定的范围值</li>
</ul>
</li>
<li><p>IS NULL；（为空） IS NOT NULL（不为空）   </p>
</li>
<li><p>AND；与</p>
</li>
<li><p>OR；或</p>
</li>
<li><p>NOT； 非</p>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>查询性别为男，并且年龄为20的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE gender=’男’ AND age=20;</li>
</ul>
</li>
<li><p>查询学号为1 或者 名为zs的记录</p>
<ul>
<li>SELECT * FROM students WHERE id =1 OR name=’zs’;</li>
</ul>
</li>
<li><p>查询学号为1，2，3的记录</p>
<ul>
<li>SELECT * FROM students WHERE id=’1001’ OR id=’1002’ OR 1001=’1003’;</li>
<li>SELECT * FROM students WHERE id  IN(‘1001’,’1002’,’1003’);</li>
<li>SELECT * FROM students WHERE id NOT IN (‘1001’,’1002’,’1003’);</li>
</ul>
</li>
<li><p>查询年龄为null的记录</p>
<ul>
<li>SELECT * FROM students WHERE age IS NULL;</li>
</ul>
</li>
<li><p>查询年龄在18到20之间的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE age&gt;=18 AND age&lt;=20;</li>
<li>SELECT * FROM students WHERE age BETWEEN 18 AND 20;</li>
</ul>
</li>
<li><p>查询性别非男的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE gender !=’男’;</li>
</ul>
</li>
<li><p>查询姓名不为null的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE  name IS NOT  NULL;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><ul>
<li><p>根据指定的关键进行查询</p>
</li>
<li><p>使用LIKE关键字后跟通配符</p>
</li>
<li><p>通配符</p>
<ul>
<li>_  ：任意一个字符</li>
<li>%：任意0~n个字符</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>查询姓名由5个字母构成的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE name LIKE ‘_____’;</li>
<li>模糊查询必须使用LIKE关键字。其中 “_”匹配任意一个字母，5个“_”表示5个任意字母。</li>
</ul>
</li>
<li><p>查询姓名由5个字母构成，并且第5个字母为“s”的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE name LIKE ‘____s’;</li>
</ul>
</li>
<li><p>查询姓名以“m”开头的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE name LIKE ‘m%’;</li>
<li>其中“%”匹配0~n个任何字母。</li>
</ul>
</li>
<li><p>查询姓名中第2个字母为“u”的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE name LIKE ‘_u%’;</li>
</ul>
</li>
<li><p>查询姓名中包含“s”字母的学生记录</p>
<ul>
<li>SELECT * FROM stu WHERE name LIKE ‘%s%’;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字段控制查询"><a href="#字段控制查询" class="headerlink" title="字段控制查询"></a>字段控制查询</h3><ul>
<li><p>去除重复字段</p>
<ul>
<li>SELECT DISTINCT name FROM students;</li>
</ul>
</li>
<li><p>把查询字段的结果进行运算，必须都要是数据型</p>
<ul>
<li>SELECT *,字段1+字段2 FROM 表名;</li>
<li>列有很多记录的值为NULL，</li>
</ul>
</li>
</ul>
<p>因为任何东西与NULL相加结果还是NULL，所以结算结果可能会出现NULL。<br>下面使用了把NULL转换成数值0的函数IFNULL：<br>    - SELECT *,age+IFNULL(score,0) FROM students;</p>
<ul>
<li><p>对查询结果起别名</p>
<ul>
<li>在上面查询中出现列名为sx+IFNULL(yw,0)，这很不美观，现在我们给这一列给出一个别名，为total：</li>
<li>SELECT *, yw+IFNULL(sx,0) AS total FROM score;</li>
<li>省略 AS SELECT *, yw+IFNULL(sx,0)  total FROM score;</li>
</ul>
</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li><p>创建表</p>
<ul>
<li><p>CREATE TABLE <code>employee</code> (<br><code>id</code> int(11) NOT NULL,<br><code>name</code> varchar(50) DEFAULT NULL,<br><code>gender</code> varchar(1) DEFAULT NULL,<br><code>hire_date</code> date DEFAULT NULL,<br><code>salary</code> decimal(10,0) DEFAULT NULL,<br><code>performance</code> double(255,0) DEFAULT NULL,<br><code>manage</code> double(255,0) DEFAULT NULL,<br><code>department</code> varchar(255) DEFAULT NULL<br>  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1001, ‘张三’, ‘男’, ‘1991-7-25’, 2000, 200, 500, ‘营销部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1002, ‘李四’, ‘男’, ‘2017-7-5’, 4000, 500, NULL, ‘营销部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1003, ‘王五’, ‘女’, ‘2018-5-1’, 6000, 100, 5000, ‘研发部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1004, ‘赵六’, ‘男’, ‘1991-6-1’, 1000, 3000, 4000, ‘财务部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1005, ‘孙七’, ‘女’, ‘2018-3-23’, 8000, 1000, NULL, ‘研发部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1006, ‘周八’, ‘男’, ‘2010-9-8’, 5000, 500, 1000, ‘人事部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1007, ‘吴九’, ‘女’, ‘2017-7-5’, 8000, 601, NULL, ‘研发部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1008, ‘郑十’, ‘女’, ‘2014-4-6’, 4000, 1801, NULL, ‘人事部’);</p>
</li>
</ul>
</li>
<li><p>对查询的结果进行排序</p>
</li>
<li><p>使用关键字ORDER BY</p>
</li>
<li><p>排序类型</p>
<ul>
<li><p>升序ASC</p>
<ul>
<li>从小到大  默认</li>
</ul>
</li>
<li><p>降序DESC</p>
<ul>
<li>从大到小</li>
</ul>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>对所有员工的薪水进行排序</p>
<ul>
<li>SELECT *FROM employee ORDER BY salary ASC;</li>
</ul>
</li>
<li><p>查询所有员工记录，按年龄降序排序</p>
<ul>
<li>SELECT * FROM employee ORDER BY salary DESC;</li>
</ul>
</li>
<li><p>查询所有雇员，按月薪降序排序，如果月薪相同时，按编号升序排序</p>
<ul>
<li>SELECT * FROM employee ORDER BY salary DESC, id ASC;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul>
<li><p>对查询的结果进行统计计算</p>
</li>
<li><p>常用聚合函数</p>
<ul>
<li>COUNT()：统计指定列不为NULL的记录行数；</li>
<li>MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</li>
<li>MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</li>
<li>SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</li>
<li>AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>COUNT</p>
<ul>
<li><p>查询employee表中记录数：</p>
<ul>
<li>SELECT COUNT(*) AS total_record FROM employee;</li>
</ul>
</li>
<li><p>查询员工表中有绩效的人数</p>
<ul>
<li>SELECT COUNT(performance)  FROM employee;</li>
</ul>
</li>
<li><p>查询员工表中月薪大于2500的人数：</p>
<ul>
<li>SELECT COUNT(*) FROM employee WHERE salary &gt; 2500;</li>
</ul>
</li>
<li><p>统计月薪与管理费之和大于5000元的人数：</p>
<ul>
<li>SELECT COUNT(*)  FROM employee WHERE salary+IFNULL(manage,0) &gt; 5000;</li>
</ul>
</li>
<li><p>查询有绩效的人数，和有管理费的人数：</p>
<ul>
<li>SELECT COUNT(performance), COUNT(manage) FROM employee;</li>
</ul>
</li>
</ul>
</li>
<li><p>SUM和AVG</p>
<ul>
<li><p>查询所有雇员月薪和：</p>
<ul>
<li>SELECT SUM(salary) FROM employee;</li>
</ul>
</li>
<li><p>查询所有雇员月薪和，以及所有雇员绩效和</p>
<ul>
<li>SELECT SUM(salary), SUM(performance) FROM employee;</li>
</ul>
</li>
<li><p>查询所有雇员月薪+绩效和：</p>
<ul>
<li>SELECT SUM(salary+IFNULL(performance,0)) FROM employee;</li>
</ul>
</li>
<li><p>统计所有员工平均工资：</p>
<ul>
<li>SELECT AVG(salary) FROM employee;</li>
</ul>
</li>
</ul>
</li>
<li><p>MAX和MIN</p>
<ul>
<li><p>查询最高工资和最低工资：</p>
<ul>
<li>SELECT MAX(salary), MIN(salary) FROM employee;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对sql语句使用的详细操作说明了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>前端网页开发工具之Typora使用教程</title>
    <url>/2020/12/18/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BTypora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Typora开发工具安装教程"><a href="#Typora开发工具安装教程" class="headerlink" title="Typora开发工具安装教程:"></a>Typora开发工具安装教程:</h1><h1 id="一、Markdown与Typora介绍"><a href="#一、Markdown与Typora介绍" class="headerlink" title="一、Markdown与Typora介绍"></a>一、Markdown与Typora介绍</h1><h2 id="1-1-Markdown介绍"><a href="#1-1-Markdown介绍" class="headerlink" title="1.1 Markdown介绍"></a>1.1 Markdown介绍</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 .md, .markdown。</p>
<h2 id="1-2-Typora介绍与下载"><a href="#1-2-Typora介绍与下载" class="headerlink" title="1.2 Typora介绍与下载"></a>1.2 Typora介绍与下载</h2><p>Typora编辑器让人们能更简单地用Markdown语言书写文字，解决了使用传统的Markdown编辑器写文的痛点，并且界面简洁优美，实现了实时预览等功能。</p>
<p>Typora官网： <a href="https://typora.io/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8E%BB%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E4%B8%8B%E8%BD%BD%E4%B8%AD%E6%96%87%E7%A0%B4%E8%A7%A3%E7%89%88%EF%BC%8C%E5%96%84%E7%94%A8%E6%90%9C%E7%B4%A2">https://typora.io/，可以去吾爱破解下载中文破解版，善用搜索</a></p>
<p>windos版本下载地址：<a href="https://typora.io/#windows">https://typora.io/#windows</a></p>
<p>请根据自己的电脑配置自行下载安装，过程简单，在此不多做介绍。</p>
<h1 id="二、Markdown语法"><a href="#二、Markdown语法" class="headerlink" title="二、Markdown语法"></a>二、Markdown语法</h1><h2 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h2><p>使用 # 可以表示标题，一级标题对应一个 # ，二级标题对应两个 # 号，最多至六级标题。在Typora中，# 后要紧接着一个空格才能表示标题，否则就是普通字符。</p>
<p>在Typora中，也可以使用快捷键Ctrl+1（2，3，4，5，6）表示相对应的标题。Ctrl+0表示段落。标题快捷键信息可在菜单栏中的段落选项下查看。</p>
<h2 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h2><p>用一对星号<em>括住的文本表示斜体文本，如：</em>要变斜体的文本*，斜体文本 ；<br>也可以用一对下划线_括住文本来表示斜体文本，如：_要变斜体的文本_，斜体文本 ；<br>也可以使用Typora的快捷键Ctrl+I来表示斜体文本。</p>
<p>用一对<strong>括住的文本表示粗体文本，如：</strong>要变粗体的文本**，粗体文本；<br>也可以用一对__括住的文本来表示粗体文本，如：__要变粗体的文本__，粗体文本；<br>也可以使用Typora的快捷键Ctrl+B来表示粗体文本。</p>
<p>用一对<em><strong>括住的文本表示粗斜体文本，如：</strong></em>要变粗斜体的文本***，粗斜体文本；<br>也可以用一对___括住的文本来表示粗斜体文本，如：___要变粗斜体的文本___，粗斜体文本；</p>
<h2 id="2-3-各种线"><a href="#2-3-各种线" class="headerlink" title="2.3 各种线"></a>2.3 各种线</h2><p>分割线，可以使用三个及以上的 + 号或 * 号或 - 来表示一条分割线；<br>由三个*号表示的分割线：</p>
<p>由三个+号表示的分割线：</p>
<p>+++(可能不代表分割线）</p>
<p>由三个-号表示的分割线：</p>
<p>删除线，可以使用一对<del>括住的文本来表示删除文本，如：</del>要加删除线的文本~~，删除文本；在Typora中，也可以使用快捷键Alt+Shift+5来加删除线，语法相同，删除线。<br>下划线，可以使用HTML的标签<u>和</u>表示增加下划线的文本，如：<u>要增加下划线的文本</u>，下划线；在Typora中，也可以使用快捷键Ctrl+U来增加下划线，语法也是相同的，下划线。</p>
<h2 id="2-4-列表"><a href="#2-4-列表" class="headerlink" title="2.4 列表"></a>2.4 列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>可以使用*，+或-标记符号来表示无序列表项，记住要在标记符号后添加一个空格，显示如下：</p>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>可以使用数字加上.再加上空格来表示有序列表</p>
<p>结果如下：</p>
<p>第一项<br>第二项<br>第三项<br>从结果可以看出，数字并不重要。</p>
<h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>一<br>1.1<br>1.1.1<br>1.1.1.2<br>1.1.1.3<br>二<br>2.1<br>2.1.1<br>有序列表第一项<br>有序列表第二项<br>首先使用*、+或-进入列表，然后回车换行，会发现系统自动生成列表第二项，此时按下Tab键，列表第二项变为第一项的子列表。按回车退出当前列表。可以在无序列表中嵌套有序列表。</p>
<p>一<br>一、一<br>一、一、一<br>一、一、一、一<br>一、一、一、二<br>二<br>二、一<br>无序列表第一项<br>无序列表第二项<br>也可以在有序列表中嵌套无序列表。</p>
<h2 id="2-5-区块"><a href="#2-5-区块" class="headerlink" title="2.5 区块"></a>2.5 区块</h2><p>当我们想要引用别人的文章内容时，可以将其放在区块内。</p>
<p>可以使用&gt;加空格来表示区块。</p>
<p>这是区块</p>
<p>区块也可以嵌套</p>
<p>二级区块</p>
<p>三级区块</p>
<p>要退出区块，同样使用Enter键即可。</p>
<h2 id="2-6-代码"><a href="#2-6-代码" class="headerlink" title="2.6 代码"></a>2.6 代码</h2><p>如果是一行代码，可以使用段内代码块来表示，用一对 `（数字1旁边的符号）括住代码。</p>
<p>比如printf(“Hello World!”)</p>
<p>如果是代码段，那么可以使用三个 ` 加Enter/空格+编程语言来表示。如：</p>
<p>include &lt;stdio.h&gt;</p>
<p>void main(){<br>    printf(“Hello world!\n”);<br>}</p>
<p>可以在代码块的右下角选择编程语言。</p>
<h2 id="2-7-链接"><a href="#2-7-链接" class="headerlink" title="2.7 链接"></a>2.7 链接</h2><p>链接的使用方式有两种语法，如下：</p>
<p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接文字</a><br>或<br>&lt;链接地址&gt;</p>
<p>我们可以使用链接打开网页，示例如下：</p>
<p><a href="https://www.baidu.com/">百度</a><br><a href="https://www.baidu.com/">https://www.baidu.com/</a><br>显示效果如下：</p>
<p>百度<br><a href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<p>当鼠标移到相应的链接文字时，按住Ctrl+鼠标左键点击访问。</p>
<p>链接除了可以打开相应的网页外，还可以打开本地文件，使用方式类似，不过链接地址需要使用本地文件的地址，相对地址、绝对地址均可：</p>
<p>示例：</p>
<p><a href="./LinkTest.md">打开LinkTest.md文档</a><br><a href="./img/LinkTest.png">打开LinkTest.png照片</a><br>1<br>2<br>结果如下：</p>
<p>打开LinkTest.md文档</p>
<p>打开LinkTest.png照片</p>
<p>经测试可以打开相应的文件。但是不能使用&lt;要打开的文件地址&gt;来打开相应的文件，比如&lt;./LinkTest.md&gt;并没有表现为可链接状态。</p>
<p>补充知识：</p>
<p>一个小圆点.表示当前目录，故./LinkTest.md表示当前目录下的LinkTest.md文件，./img/LinkTest.png表示当前目录下的img文件下的LinkTest.png文件。</p>
<p>两个小圆点..表示上一级目录。</p>
<p>我们也可以使用链接来实现页内跳转，语法为：</p>
<p><a href="#%E6%A0%87%E9%A2%98%E6%96%87%E5%AD%97">链接文字</a><br>1<br>示例：</p>
<p>[跳转到第一章第一节](#1.1 Markdown介绍)<br>1<br>结果如下：<br>[跳转到第一章第一节](#1.1 Markdown介绍)</p>
<p>经测试，可以成功跳转。</p>
<h2 id="2-8-图片"><a href="#2-8-图片" class="headerlink" title="2.8 图片"></a>2.8 图片</h2><p>我们也可以在Markdown文档中插入图片，语法如下：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"></p>
<p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"></p>
<p>首先一个感叹号<br>然后中括号里面写属性文本<br>小括号里面写图片地址，后可接标题</p>
<p>示例语法：</p>
<p><img src="/./img/PictureTest.png" alt="本地png图片PictureTest.png"></p>
<p><img src="/./img/PictureTest.jpg" alt="本地jpg图片"></p>
<p>结果如下：</p>
<p><img src="http://static.runoob.com/images/runoob-logo.png" alt="网络图片" title="菜鸟教程"></p>
<p>在Typora中，也可以直接使用Ctrl+C，Ctrl+V来直接进行复制粘贴图片，但是，由于Markdown是需要图片的地址的，所以需要简单设置一下Typora。</p>
<p>点击文件 –&gt; 偏好设置 –&gt; 图像，如下：</p>
<p>可以自行设置选择将图片复制到哪个文件夹。</p>
<p>这里选择复制到指定路径，然后在下面一栏中填写./img，表示将图片复制到你正在编辑的文档同一级的img文件夹下。在下面的选项中，勾选第一、二、三项。正因为勾选了第二项，所以当我们在插入网络图片时，Typora会自动帮我们将网络图片下载到指定的路径下，前面的”菜鸟教程”图片便是如此。</p>
<p>由于Markdown的特殊语法，故经常会出现图片加载失败的情况，很大的可能就是因为在指定的路径上找不到相应的图片，当然，有时候也是由于Typora的原因，重启Typora即可。</p>
<h2 id="2-9-表格"><a href="#2-9-表格" class="headerlink" title="2.9 表格"></a>2.9 表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p>
<p>结果如下：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<p>我们可以设置对齐方式：</p>
<p>:-表示左对齐<br>-:表示右对齐<br>:-:表示中间对齐<br>示例如下：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">中间对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<p>在Typora中，我们可以使用快捷键Ctrl+T来插入表格，并选择行列，当选中表格某一单元格时，可以在表格左上角手动设置对齐方式，右上角选择更多操作。</p>
<h1 id="三、Typora与数学公式"><a href="#三、Typora与数学公式" class="headerlink" title="三、Typora与数学公式"></a>三、Typora与数学公式</h1><p>在本章中，重点不在于介绍如何插入数学公式，而在于如何表示数学符号。</p>
<h3 id="3-1-如何插入数学公式"><a href="#3-1-如何插入数学公式" class="headerlink" title="3.1 如何插入数学公式"></a>3.1 如何插入数学公式</h3><p>在Typora中，有两种方法插入数学公式，语法为：</p>
<p>第一种方法：$数学公式$<br>第二种方法：<br>$$<br>数学公式<br>$$<br>1<br>2<br>3<br>4<br>5<br>第一种方法表示插入行内公式（内联公式），即可以将公式插入到一行中，比如1 + 2 = 3 1+2=31+2=3这样的公式。</p>
<p>第二种方法表示插入行间公式（外联公式），即可以将公式插入到行与行之间，单独占据一行或者数行的空间，并且居中放置。<br>1 + 2 = 3 1+2=3<br>1+2=3</p>
<p>如果要在行间公式内换行，在换行的位置使用\。</p>
<p>接下来重点介绍如何表示数学符号。</p>
<h3 id="3-2-上标下标"><a href="#3-2-上标下标" class="headerlink" title="3.2 上标下标"></a>3.2 上标下标</h3><p>上下标可以使用^，_后跟相应的符号来实现。如：</p>
<p>上 标 ： a 1 ， 下 标 ： a 1 上标：a^1，下标：a_1上标：a<br>1<br> ，下标：a<br>1</p>
<p>如果作为上标、下标的符号不止一个，则需要用花括号{}将其括起来。如：</p>
<p>上 标 为 12 ： a 12 , 下 标 为 34 ： a 34 上标为12：a^{12},下标为34：a_{34}上标为12：a<br>12<br> ,下标为34：a<br>34</p>
<p>更多例子：<br>f ( x ) = x x x e x 2 e x 2 f(x)=x^{x^x}\ e^{x2}\ e^{x^2}\<br>f(x)=x<br>x<br>x</p>
<p>e<br>x2</p>
<p>e<br>x<br>2</p>
<h3 id="3-3-根号"><a href="#3-3-根号" class="headerlink" title="3.3 根号"></a>3.3 根号</h3><p>我们可以使用\sqrt{}来表示根号。如：</p>
<p>\sqrt{2},\sqrt{5}<br>1<br>结果为：</p>
<p>2 , 5 \sqrt{2},\sqrt{5}<br>2</p>
<p> ,<br>5</p>
<p>我们也可以使用\sqrt[]{}来表示更具体的根号信息：</p>
<p>\sqrt[3]{4}，\sqrt[4]{10}<br>1<br>4 3 ， 10 4 \sqrt[3]{4}，\sqrt[4]{10}<br>3</p>
<p>4</p>
<p> ，<br>4</p>
<p>10</p>
<h3 id="3-4-上下水平线"><a href="#3-4-上下水平线" class="headerlink" title="3.4 上下水平线"></a>3.4 上下水平线</h3><p>我们可以使用\underline{},\overline{}来表示上下水平线，如：</p>
<p>$下水平线：\underline{a+b}$<br>$上水平线：\overline{a+b}$<br>1<br>2<br>结果为：</p>
<p>下 水 平 线 ： a + b ‾ 下水平线：\underline{a+b}下水平线：<br>a+b</p>
<p>上 水 平 线 ： a + b ‾ 上水平线：\overline{a+b}上水平线：<br>a+b</p>
<h3 id="3-5-上下水平大括号"><a href="#3-5-上下水平大括号" class="headerlink" title="3.5 上下水平大括号"></a>3.5 上下水平大括号</h3><p>我们可以使用\overbrace{} 和 \underbrace{} 在表达式的上、下方给出一水平的大括号</p>
<p>$\overbrace{x_1+x_2+x_3}$<br>$\underbrace{x_1+x_2+x_3}$<br>1<br>2<br>结果为：</p>
<p>x 1 + x 2 + x 3 ⏞ \overbrace{x_1+x_2+x_3}<br>x<br>1</p>
<p> +x<br>2</p>
<p> +x<br>3</p>
<p>x 1 + x 2 + x 3 ⏟ \underbrace{x_1+x_2+x_3}<br>x<br>1</p>
<p> +x<br>2</p>
<p> +x<br>3</p>
<p>当然，我们也可以在括号上添加说明，使用语法为\overbrace{}^{}和\underbrace{}_{}</p>
<p>$\overbrace{x_1+x_2+x_3}^{3个元素}$<br>$\underbrace{x_1+x_2+x_3}_{3个元素}$<br>1<br>2<br>x 1 + x 2 + x 3 ⏞ 3 个 元 素 \overbrace{x_1+x_2+x_3}^{3个元素}<br>x<br>1</p>
<p> +x<br>2</p>
<p> +x<br>3</p>
<p>3个元素</p>
<p>x 1 + x 2 + x 3 ⏟ 3 个 元 素 \underbrace{x_1+x_2+x_3}_{3个元素}<br>3个元素<br>x<br>1</p>
<p> +x<br>2</p>
<p> +x<br>3</p>
<h3 id="3-6-向量符号"><a href="#3-6-向量符号" class="headerlink" title="3.6 向量符号"></a>3.6 向量符号</h3><p>我们可以使用\vec{}来表示单个字母向量，其实也可以表示多个字母，但不美观，另两个命令\overrightarrow{} 和\overleftarrow{}在定义从A 到B 的向量时非常有用。如：</p>
<p>$\vec{a}$<br>$\vec{AB}$<br>$\vec{ABC}$<br>$\overrightarrow{AB}$<br>$\overleftarrow{AB}$<br>1<br>2<br>3<br>4<br>5<br>结果为：</p>
<p>a ⃗ \vec{a}<br>a</p>
<p>A B ⃗ \vec{AB}<br>AB</p>
<p>A B C ⃗ \vec{ABC}<br>ABC</p>
<p>A B → \overrightarrow{AB}<br>AB</p>
<p>A B ← \overleftarrow{AB}<br>AB</p>
<h3 id="3-7-分数"><a href="#3-7-分数" class="headerlink" title="3.7 分数"></a>3.7 分数</h3><p>我们可以使用\frac{}{}来表示分数，如：</p>
<p>$\frac{1}{2}$<br>$\frac{\sqrt{3}}{4}$<br>1<br>2<br>结果为：</p>
<p>1 2 \frac{1}{2}<br>2<br>1</p>
<p>3 4 \frac{\sqrt{3}}{4}<br>4<br>3</p>
<h3 id="3-8-积分运算符"><a href="#3-8-积分运算符" class="headerlink" title="3.8 积分运算符"></a>3.8 积分运算符</h3><p>积分运算符用\int 来生成 ，用\int_{}^{}来表示积分上下界，如：</p>
<p>$\int$<br>$\int_{1}^{2}$<br>1<br>2<br>结果为：</p>
<p>∫ \int∫<br>∫ 1 2 \int_{1}^{2}∫<br>1<br>2</p>
<h3 id="3-9-求和运算符"><a href="#3-9-求和运算符" class="headerlink" title="3.9 求和运算符"></a>3.9 求和运算符</h3><p>求和运算符可以使用\sum来生成，用\sum_{}^{}来表示求和上下界，如：</p>
<p>$\sum$<br>$\sum_{i=1}^{10}x_i$<br>1<br>2<br>结果为：</p>
<p>∑ \sum∑<br>∑ i = 1 10 x i \sum_{i=1}^{10}x_i∑<br>i=1<br>10</p>
<p> x<br>i</p>
<p>求和符号的上下标在内联公式里，表现为上面那样，当在外联公式里时，表现如下：<br>∑ i = 1 10 x i \sum_{i=1}^{10}x_i<br>i=1<br>∑<br>10</p>
<p> x<br>i</p>
<h3 id="3-10-连乘运算符"><a href="#3-10-连乘运算符" class="headerlink" title="3.10 连乘运算符"></a>3.10 连乘运算符</h3><p>连乘运算符用\prod{}表示，同样地，上下标用prod_{}^{}表示，如：</p>
<p>$\prod$<br>$\prod_{i=1}^{10}x_i$<br>$$<br>\prod_{i=1}^{10}x_i<br>$$<br>1<br>2<br>3<br>4<br>5<br>结果为：</p>
<p>∏ \prod∏<br>∏ i = 1 10 x i \prod_{i=1}^{10}x_i∏<br>i=1<br>10</p>
<p> x<br>i</p>
<p>∏ i = 1 10 x i \prod_{i=1}^{10}x_i<br>i=1<br>∏<br>10</p>
<p> x<br>i</p>
<h3 id="3-11-特殊符号"><a href="#3-11-特殊符号" class="headerlink" title="3.11 特殊符号"></a>3.11 特殊符号</h3><p>希腊字母</p>
<p>α \alphaα为\alpha，β \betaβ为\beta，γ \gammaγ为\gamma，θ \thetaθ为\theta，ρ \rhoρ为\rho，λ \lambdaλ为\lambda，μ \muμ为\mu</p>
<p>Δ \DeltaΔ为\Delta，π \piπ为\pi，Ω \OmegaΩ为\Omega</p>
<p>关系运算符</p>
<p>大于&gt;，大于等于≥ \geq≥为\geq或\ge</p>
<p>小于&lt;，小于等于≤ \leq≤为\leq或\le</p>
<p>等于=，不等于≠ \neq<br></p>
<p> =为\neq或\ne</p>
<p>加减乘除</p>
<p>加+ 减-</p>
<p>乘× \times×为\times 除÷ \div÷为\div</p>
<h3 id="3-12-矩阵表示"><a href="#3-12-矩阵表示" class="headerlink" title="3.12 矩阵表示"></a>3.12 矩阵表示</h3><p>我们可以使用以下格式来显示矩阵：<br>$$<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\<br>4 &amp; 5 &amp; 6\<br>\end{matrix}<br>$$<br>1<br>2<br>3<br>4<br>5<br>6<br>结果为：<br>1 2 3 4 5 6<br>142536<br>123456<br>1<br>4</p>
<p>2<br>5</p>
<p>3<br>6</p>
<p>可是这并不是我们常见的矩阵啊，旁边的中括号呢？</p>
<p>别急，我们先把上面的公式说明一下：</p>
<p>\begin{matrix}和\end{matrix}说明在它们之间的是矩阵</p>
<p>1 &amp; 2 &amp; 3\表示第一行的元素，其中用&amp;来分割每一个元素，用\来换行</p>
<p>现在我们来加括号，很简单，语法如下：</p>
<p>$$<br>\left[\begin{matrix}<br>1 &amp; 2 &amp; 3\<br>4 &amp; 5 &amp; 6<br>\end{matrix}\right]<br>$$<br>1<br>2<br>3<br>4<br>5<br>6<br>结果为：<br>[ 1 2 3 4 5 6 ] \left[<br>142536<br>123456<br>\right]<br>[<br>1<br>4</p>
<p>2<br>5</p>
<p>3<br>6</p>
<p> ]</p>
<p>其实我们仅仅在\begin{matrix}前面加了\left[，在\end{matrix}后面加了\right]，这样就能正确显示括号了，那我们可以将[]改为||吗，当然可以，就简单地把\left[，\right]改为\left|和\right|即可。</p>
<p>$$<br>\left|\begin{matrix}<br>1 &amp; 2 &amp; 3\<br>4 &amp; 5 &amp; 6<br>\end{matrix}\right|<br>$$<br>1<br>2<br>3<br>4<br>5<br>6<br>结果就能显示为行列式了。<br>∣ 1 2 3 4 5 6 ∣ \left|<br>142536<br>123456<br>\right|<br>∣<br>∣<br>∣<br>∣</p>
<p>1<br>4</p>
<p>2<br>5</p>
<p>3<br>6</p>
<p>∣<br>∣<br>∣<br>∣</p>
<p>这里仅仅介绍简单的矩阵表示，如果要了解更多矩阵表示法，请自行搜索了解，网上的资料很多。</p>
<h3 id="3-13-方程组"><a href="#3-13-方程组" class="headerlink" title="3.13 方程组"></a>3.13 方程组</h3><p>$$<br>\begin{equation}<br>\left{<br>             \begin{array}{lr}<br>             x=\dfrac{3\pi}{2}(1+2t)\cos(\dfrac{3\pi}{2}(1+2t)), &amp;  \<br>             y=s, &amp; 0\leq s\leq L,|t|\leq1.\<br>             z=\dfrac{3\pi}{2}(1+2t)\sin(\dfrac{3\pi}{2}(1+2t)), &amp;<br>             \end{array}<br>\right.<br>\end{equation}<br>$$</p>
<p>结果如下：<br>KaTeX parse error: No such environment: equation at position 8: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲}̲ \left{ …</p>
<p>现在我们一一来解释：</p>
<p>begin{equation}与\end{euqation}表示它们之间的为方程组。</p>
<p>\left{和\right.表示在方程组的左边加上{，在右边加上.，因为{在外联公式中有特殊的意义，因此需要在其前面加上转义字符\。</p>
<p>\begin{array}和\end{array}表示它们之间的是数组，其实这也可以用来表示矩阵。</p>
<p>{lr}表示有两列，第一列的值靠左排列，用l表示，第二列的值靠右排列，用r表示，如果是中间对齐则为c。</p>
<p>然后下面三行是方程式，用&amp;分割，用\换行。</p>
<h3 id="3-14-分段函数"><a href="#3-14-分段函数" class="headerlink" title="3.14 分段函数"></a>3.14 分段函数</h3><p>其实分段函数与方程组类似，示例如下：<br>$$<br>y=<br>\begin{equation}<br>    \left{<br>        \begin{array}{lr}<br>        x-1 &amp; x \leq 0<br>        x+1 &amp; x&gt;0<br>        \end{array}<br>    \right.<br>\end{equation}<br>$$</p>
<p>结果如下：<br>KaTeX parse error: No such environment: equation at position 11: y= \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲}̲ \left{ \be…<br>就是在\begin{equation}前加y=即可。</p>
<h1 id="四、Typora与HTML"><a href="#四、Typora与HTML" class="headerlink" title="四、Typora与HTML"></a>四、Typora与HTML</h1><h3 id="4-1-改变字体颜色及大小"><a href="#4-1-改变字体颜色及大小" class="headerlink" title="4.1 改变字体颜色及大小"></a>4.1 改变字体颜色及大小</h3><p>我们可以使用<font> </font>标签来改变字体的颜色及大小，如：</p>
<p><font size="3" color="red">字体颜色为红色，大小为3</font></p>
<p><font size="4" color="blue">字体颜色为蓝色，大小为4</font></p>
<p><font size="6" color="violet">字体颜色为紫罗兰，大小为6</font></p>
<p>属性size表示字体大小，color表示颜色。</p>
<h3 id="4-2-改变对齐方式"><a href="#4-2-改变对齐方式" class="headerlink" title="4.2 改变对齐方式"></a>4.2 改变对齐方式</h3><p>我们可以改变字体的对齐方式，用标签</p><p> </p>加上属性align，如：<p></p>
<p>1 </p><p align="left">左对齐</p><br>2 <p align="center">中间对齐</p><br>3 <p align="right">右对齐</p><br>结果为：<p></p>
<p align="left">左对齐</p>
<p align="center">中间对齐</p>
<p align="right">右对齐</p>

<h3 id="4-3-插入图像"><a href="#4-3-插入图像" class="headerlink" title="4.3 插入图像"></a>4.3 插入图像</h3><p>大家可以自己在Typora中测试。<br>我们可以通过标签<img src="url">来插入图片，如：</p>
<img src="img/1.jpg">
结果为：



<p><img src="/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E4%B9%8BTypora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/%E6%9C%89%E5%BF%97%E8%80%85%EF%BC%8C%E4%BA%8B%E7%AB%9F%E6%88%90.png"></p>
<p>我们可以改变<img>标签的属性，来改变图片的大小。</p>
<img src="img/1.jpg" width="100" height="100/">
1
将图片的宽高均设为100



<p>也可以改变图片的位置，如：</p>
<p><img src="img/1.jpg" width="30" height="30" style="float:left">图片在左边<br><img src="img/1.jpg" width="30" height="30" style="float:right">图片在右边</p>
<h1 id="五、扩展用法"><a href="#五、扩展用法" class="headerlink" title="五、扩展用法"></a>五、扩展用法</h1><h3 id="5-1-插入emoji表情"><a href="#5-1-插入emoji表情" class="headerlink" title="5.1 插入emoji表情"></a>5.1 插入emoji表情</h3><p>我们可以使用:emoji:的语法来插入表情，比如：</p>
<p>:happy:的语法为:happy:</p>
<p>🦀的语法为<span class="github-emoji"><span>🦀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f980.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>🐴的语法为<span class="github-emoji"><span>🐴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f434.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<h3 id="5-2-插入目录"><a href="#5-2-插入目录" class="headerlink" title="5.2 插入目录"></a>5.2 插入目录</h3><p>当我们为使用标题将文分章节后，可以在输入[toc]命令的地方自动根据标题生成目录。</p>
<h3 id="5-3-导出"><a href="#5-3-导出" class="headerlink" title="5.3 导出"></a>5.3 导出</h3><p>选择文件 –&gt; 导出，可以选择导出的文件格式，有pdf,html,word等格式。</p>
<h3 id="5-4-文本高亮"><a href="#5-4-文本高亮" class="headerlink" title="5.4 文本高亮"></a>5.4 文本高亮</h3><p>在Typora中，可以用一对==将要高亮的文本括起来，如：</p>
<p>==要高亮的文本==<br>==背景会用黄色填充==<br>1<br>2<br>结果为：</p>
<p>要高亮的文本<br>背景会用黄色填充</p>
<p>这个功能可在偏好设置 –&gt; Markdown扩展语法中设置。</p>
<h3 id="5-5-上下标"><a href="#5-5-上下标" class="headerlink" title="5.5 上下标"></a>5.5 上下标</h3><p>在Typora中，可以用一对<del>将下标括起来，如：H</del>2~O表示H2O</p>
<p>同样，我们也可以用一对^将上标括起来，如：X^2^表示X2</p>
<p>上下标可在偏好设置 –&gt; Markdown扩展语法中设置。</p>
<p><strong>六、参考资料</strong></p>
<p>[1] 菜鸟Markdown教程：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p>
<p>[2] 更多数学符号表达式：<a href="http://mohu.org/info/symbols/symbols.htm">http://mohu.org/info/symbols/symbols.htm</a></p>
<p>[3] Latex 方程组表示： <a href="https://blog.csdn.net/lemolemac/article/details/9057471">https://blog.csdn.net/lemolemac/article/details/9057471</a></p>
<p>[4] 菜鸟HTML教程：<a href="https://www.runoob.com/html/html-tutorial.html">https://www.runoob.com/html/html-tutorial.html</a></p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是Typora的安装和介绍教程了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>工具浅玩类</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发工具之IDEA安装教程</title>
    <url>/2020/09/18/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="IDEA开发工具安装教程"><a href="#IDEA开发工具安装教程" class="headerlink" title="IDEA开发工具安装教程:"></a>IDEA开发工具安装教程:</h1><p>工欲善其事，必先利其器。想要优雅且高效的编写代码，必须熟练使用一款后端开发工具。</p>
<p>但后端开发工具数不胜数，像Eclipse,Notepad++，MobaXterm,Maven,Tomcat…</p>
<p>(厉害的开发者都用记事本，哈哈)</p>
<p>IntelliJ IDEA被认为是当前Java开发效率最快的IDE工具。它整合了开发过程中实用的众多功能，几乎可以不用鼠标可以方便的完成你要做的任何事情，最大程度的加快开发的速度。简单而又功能强大。与其他的一些繁冗而复杂的IDE工具有鲜明的对比。</p>
<p>IDEA以其强大的代码编辑功能，代码补全功能和丰富的插件生态系统，独受后端开发者的青睐。</p>
<p>活不多说，开启教程：</p>
<h1 id="一、下载-IDEA"><a href="#一、下载-IDEA" class="headerlink" title="一、下载 IDEA"></a>一、下载 IDEA</h1><p>官方下载地址:<a href="https://www.jetbrains.com/zh-cn/idea/download/#section=windows">https://www.jetbrains.com/zh-cn/idea/download/#section=windows</a></p>
<p>历史版本下载：<a href="https://www.jetbrains.com/zh-cn/idea/download/other.html">https://www.jetbrains.com/zh-cn/idea/download/other.html</a></p>
<p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/1.jpg"></p>
<p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/2.jpg"></p>
<h1 id="二、安装-IDEA"><a href="#二、安装-IDEA" class="headerlink" title="二、安装 IDEA"></a>二、安装 IDEA</h1><p><strong>注：安装IDEA之前需要我们机器上有JDK环境！！！</strong> </p>
<p><strong>双击下载的安装包打开安装即可：</strong></p>
<p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/3.png"></p>
<h3 id="1、安装IDEA，一路next-即可，遇到安装路径时，记得修改安装路径。"><a href="#1、安装IDEA，一路next-即可，遇到安装路径时，记得修改安装路径。" class="headerlink" title="1、安装IDEA，一路next 即可，遇到安装路径时，记得修改安装路径。"></a>1、安装IDEA，一路<strong>next</strong> 即可，遇到安装路径时，记得修改安装路径。</h3><p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/4.jpg"></p>
<h3 id="2、安装完成，打开IDEA，会先弹出一个注册框，勾选Evaluate-for-free，点击-Evaluate，然后进入主界面"><a href="#2、安装完成，打开IDEA，会先弹出一个注册框，勾选Evaluate-for-free，点击-Evaluate，然后进入主界面" class="headerlink" title="2、安装完成，打开IDEA，会先弹出一个注册框，勾选Evaluate for free，点击 Evaluate，然后进入主界面"></a>2、安装完成，打开IDEA，会先弹出一个注册框，勾选<strong>Evaluate for free</strong>，点击 <strong>Evaluate</strong>，然后进入主界面</h3><h1 id="三、软件收费相关问题解决方案"><a href="#三、软件收费相关问题解决方案" class="headerlink" title="三、软件收费相关问题解决方案"></a>三、软件收费相关问题解决方案</h1><p>建议有条件的购买正版支持，也可以使用破解版，具体的破解流程，百度一下</p>
<h2 id="1、可以对IDEA进行破解，目前有两种方式："><a href="#1、可以对IDEA进行破解，目前有两种方式：" class="headerlink" title="1、可以对IDEA进行破解，目前有两种方式："></a>1、可以对IDEA进行破解，目前有两种方式：</h2><h3 id="1-无限重置30天的插件"><a href="#1-无限重置30天的插件" class="headerlink" title="1.无限重置30天的插件"></a>1.无限重置30天的插件</h3><h3 id="2-激活到2099的文件包，需要保存在计算机中"><a href="#2-激活到2099的文件包，需要保存在计算机中" class="headerlink" title="2.激活到2099的文件包，需要保存在计算机中"></a>2.激活到2099的文件包，需要保存在计算机中</h3><p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/5.png"></p>
<h1 id="四、关于中文汉化问题解决方案"><a href="#四、关于中文汉化问题解决方案" class="headerlink" title="四、关于中文汉化问题解决方案"></a>四、关于中文汉化问题解决方案</h1><p><strong>汉化插件对于英文不是很好的开发者来说，开发项目简直不要太轻松</strong></p>
<p><strong>IDEA可以加载插件，</strong></p>
<p><em><strong>所以汉化只需要下载一个汉化插件就可以实现将英文显示为中文。</strong></em></p>
<h3 id="1-创建项目或打开项目；"><a href="#1-创建项目或打开项目；" class="headerlink" title="1.创建项目或打开项目；"></a>1.创建项目或打开项目；</h3><h3 id="2-单击File-文件-gt-Settings-设置-或者Ctrl-Alt-S"><a href="#2-单击File-文件-gt-Settings-设置-或者Ctrl-Alt-S" class="headerlink" title="2.单击File(文件)->Settings(设置)或者Ctrl+Alt+S;"></a>2.单击File(文件)-&gt;Settings(设置)或者Ctrl+Alt+S;</h3><h3 id="3-选中plugins-插件管理-gt-MarketPlace-插件市场"><a href="#3-选中plugins-插件管理-gt-MarketPlace-插件市场" class="headerlink" title="3.选中plugins(插件管理)->MarketPlace(插件市场);"></a>3.选中plugins(插件管理)-&gt;MarketPlace(插件市场);</h3><h3 id="4-搜索Chinese-gt-选中下载Chinese-Simplified-简体中文语言包；"><a href="#4-搜索Chinese-gt-选中下载Chinese-Simplified-简体中文语言包；" class="headerlink" title="4.搜索Chinese->选中下载Chinese(Simplified)简体中文语言包；"></a>4.搜索Chinese-&gt;选中下载Chinese(Simplified)简体中文语言包；</h3><p><strong>结果如下图:</strong></p>
<p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/6.png"></p>
<h3 id="5-下载完成后，应用，重新启动IDEA；"><a href="#5-下载完成后，应用，重新启动IDEA；" class="headerlink" title="5.下载完成后，应用，重新启动IDEA；"></a>5.下载完成后，应用，重新启动IDEA；</h3><p><strong>不过还是建议使用英文版，最好不要过分依赖中文</strong></p>
<p><strong>毕竟很多项目开发都是英文，需要对英语十分熟悉</strong></p>
<p><strong>英文版不仅可以提高对英语的兴趣，而且有助于熟练英文.</strong></p>
<h1 id="五、接下来就可以愉快地敲写代码了"><a href="#五、接下来就可以愉快地敲写代码了" class="headerlink" title="五、接下来就可以愉快地敲写代码了"></a>五、接下来就可以愉快地敲写代码了</h1><h1 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h1><p><strong>以上就是IDEA的安装和介绍教程了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>工具浅玩类</tag>
      </tags>
  </entry>
  <entry>
    <title>前端网页开发工具之VSCode使用教程</title>
    <url>/2020/10/18/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BVSCode%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="VSCode开发工具安装教程"><a href="#VSCode开发工具安装教程" class="headerlink" title="VSCode开发工具安装教程:"></a>VSCode开发工具安装教程:</h1><p>工欲善其事，必先利其器。想要优雅且高效的编写代码，必须熟练使用一款前端开发工具。</p>
<p>但前端开发工具数不胜数，像HBuilder、Sublime Text、WebStorm、Visual Studio Code……等等,</p>
<p>其中VSCode以其轻量且强大的代码编辑功能和丰富的插件生态系统，独受前端开发者的青睐。</p>
<p>活不多说，开启教程：</p>
<hr>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><h3 id="直接在官网进行下载"><a href="#直接在官网进行下载" class="headerlink" title="直接在官网进行下载"></a>直接在官网进行下载</h3><p>Visual Studio Code - Code Editing. Redefined<br>​code.visualstudio.com/</p>
<h3 id="可以将vscode设置成中文"><a href="#可以将vscode设置成中文" class="headerlink" title="可以将vscode设置成中文"></a>可以将vscode设置成中文</h3><p>vscode默认的语言是英文，对于英文不好的小伙伴可能不太友好。<br>简单几步教大家如何将vscode设置成中文。</p>
<p>按快捷键“Ctrl+Shift+P”。<br>在“vscode”顶部会出现一个搜索框。<br>输入“configure language”，然后回车。<br>“vscode”里面就会打开一个语言配置文件。<br>将“en-us”修改成“zh-cn”。<br>按“Ctrl+S”保存设置。<br>关闭“vscode”，再次打开就可以看到中文界面了。<br>当然如果你不愿意设置，也可以直接安装它的中文插件，还是很人性化的。</p>
<h3 id="VScode用户设置"><a href="#VScode用户设置" class="headerlink" title="VScode用户设置"></a>VScode用户设置</h3><ol>
<li>打开设置</li>
</ol>
<p>文件–首选项–设置，打开用户设置。VScode支持选择配置，也支持编辑setting.json文件修改默认配置。个人更倾向于编写json的方式进行配置，下面会附上我个人的配置代码</p>
<p>这里解析几个常用配置项：</p>
<p>（1）editor.fontsize用来设置字体大小，可以设置editor.fontsize : 14;</p>
<p>（2）files.autoSave这个属性是表示文件是否进行自动保存，推荐设置为onFocusChange——文件焦点变化时自动保存。</p>
<p>（3）editor.tabCompletion用来在出现推荐值时，按下Tab键是否自动填入最佳推荐值，推荐设置为on;</p>
<p>（4）editor.codeActionsOnSave中的source.organizeImports属性，这个属性能够在保存时，自动调整 import 语句相关顺序，能够让你的 import 语句按照字母顺序进行排列，推荐设置为true,即”editor.codeActionsOnSave”: { “source.organizeImports”: true }；</p>
<p>（5）editor.lineNumbers设置代码行号,即editor.lineNumbers ：true；</p>
<p>我的个人配置，供参考：</p>
<p>{<br>  “files.associations”: {<br>  “<em>.vue”: “vue”,<br>  “</em>.wpy”: “vue”,<br>  “<em>.wxml”: “html”,<br>  “</em>.wxss”: “css”<br>  },<br>  “terminal.integrated.shell.windows”: “C:\Windows\System32\cmd.exe”,<br>  “git.enableSmartCommit”: true,<br>  “git.autofetch”: true,<br>  “emmet.triggerExpansionOnTab”: true,<br>  “emmet.showAbbreviationSuggestions”: true,<br>  “emmet.showExpandedAbbreviation”: “always”,<br>  “emmet.includeLanguages”: {<br>  “vue-html”: “html”,<br>  “vue”: “html”,<br>  “wpy”: “html”<br>  },<br>  //主题颜色<br>  //“workbench.colorTheme”: “Monokai”,<br>  “git.confirmSync”: false,<br>  “explorer.confirmDelete”: false,<br>  “editor.fontSize”: 14,<br>  “window.zoomLevel”: 1,<br>  “editor.wordWrap”: “on”,<br>  “editor.detectIndentation”: false,<br>  // 重新设定tabsize<br>  “editor.tabSize”: 2,<br>  //失去焦点后自动保存<br>  “files.autoSave”: “onFocusChange”,<br>  // #值设置为true时，每次保存的时候自动格式化；<br>  “editor.formatOnSave”: false,<br>   //每120行就显示一条线<br>  “editor.rulers”: [<br>  ],<br>  // 在使用搜索功能时，将这些文件夹/文件排除在外<br>  “search.exclude”: {<br>      “<strong>/node_modules”: true,<br>      “</strong>/bower_components”: true,<br>      “<strong>/target”: true,<br>      “</strong>/logs”: true,<br>  },<br>  // 这些文件将不会显示在工作空间中<br>  “files.exclude”: {<br>      “<strong>/.git”: true,<br>      “</strong>/.svn”: true,<br>      “<strong>/.hg”: true,<br>      “</strong>/CVS”: true,<br>      “<strong>/.DS_Store”: true,<br>      “</strong>/*.js”: {<br>          “when”: “$(basename).ts” //ts编译后生成的js文件将不会显示在工作空中<br>      },<br>      “**/node_modules”: true<br>  },<br>  // #让vue中的js按”prettier”格式进行格式化<br>  “vetur.format.defaultFormatter.html”: “js-beautify-html”,<br>  “vetur.format.defaultFormatter.js”: “prettier”,<br>  “vetur.format.defaultFormatterOptions”: {<br>      “js-beautify-html”: {<br>          // #vue组件中html代码格式化样式<br>          “wrap_attributes”: “force-aligned”, //也可以设置为“auto”，效果会不一样<br>          “wrap_line_length”: 200,<br>          “end_with_newline”: false,<br>          “semi”: false,<br>          “singleQuote”: true<br>      },<br>      “prettier”: {<br>          “semi”: false,<br>          “singleQuote”: true<br>      }<br>  }<br>}</p>
<p>新版的vscode设置默认为UI的设置，而非之前的json设置。如果你想复制我上面这段代码进行配置，可以进行下面的修改</p>
<p>文件&gt;首选项&gt;设置 &gt; 搜索workbench.settings.editor，选中json即可改成json设置；</p>
<h3 id="禁用自动更新"><a href="#禁用自动更新" class="headerlink" title="禁用自动更新"></a>禁用自动更新</h3><p>文件 &gt; 首选项 &gt; 设置（macOS：代码 &gt; 首选项 &gt; 设置，搜索update mode并将设置更改为none。</p>
<p>开启代码提示设置</p>
<p>第一步：点击左下角点击设置图标，找到并点击“setting”</p>
<p>第二步：到搜索框里搜索“prevent”—&gt;并取消此项的勾选</p>
<p>常用的快捷键<br>高效的使用vscode,记住一些常用的快捷键是必不可少的，我给大家罗列了一些日常工作过程中用的多的快捷键。</p>
<p>以下以Windows为主，windows的 Ctrl，mac下换成Command就行了</p>
<p>对于 行 的操作：</p>
<p>重开一行：光标在行尾的话，回车即可；不在行尾，ctrl + enter 向下重开一行；ctrl+shift + enter 则是在上一行重开一行<br>删除一行：光标没有选择内容时，ctrl + x 剪切一行；ctrl +shift + k 直接删除一行<br>移动一行：alt + ↑ 向上移动一行；alt + ↓ 向下移动一行<br>复制一行：shift + alt + ↓ 向下复制一行；shift + alt + ↑ 向上复制一行<br>ctrl + z 回退<br>对于 词 的操作：</p>
<p>选中一个词：ctrl + d<br>搜索或者替换：</p>
<p>ctrl + f ：搜索<br>ctrl + alt + f： 替换<br>ctrl + shift + f：在项目内搜索<br>通过Ctrl + ` 可以打开或关闭终端</p>
<p>Ctrl+P 快速打开最近打开的文件</p>
<p>Ctrl+Shift+N 打开新的编辑器窗口</p>
<p>Ctrl+Shift+W 关闭编辑器</p>
<p>Home 光标跳转到行头</p>
<p>End 光标跳转到行尾</p>
<p>Ctrl + Home 跳转到页头</p>
<p>Ctrl + End 跳转到页尾</p>
<p>Ctrl + Shift + [ 折叠区域代码</p>
<p>Ctrl + Shift + ] 展开区域代码</p>
<p>Ctrl + / 添加关闭行注释</p>
<p>Shift + Alt +A 块区域注释</p>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>在输入框中输入想要安装的插件名称，点击安装即可。安装后没有效果，可以重启vscode</p>
<h4 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h4><p>1、View In Browser</p>
<p>在浏览器里预览网页必备。运行html文件</p>
<p>动图封面<br>2、vscode-icons<br>改变编辑器里面的文件图标</p>
<p>3、Bracket Pair Colorizer<br>给嵌套的各种括号加上不同的颜色。</p>
<p>4、Auto Rename Tag<br>自动修改匹配的 HTML 标签。</p>
<p>动图封面<br>5、Path Intellisense<br>智能路径提示，可以在你输入文件路径时智能提示。</p>
<p>动图封面<br>6、Markdown Preview<br>实时预览 markdown。</p>
<p>7、stylelint<br>CSS / SCSS / Less 语法检查</p>
<p>8、Import Cost<br>引入包大小计算,对于项目打包后体积掌握很有帮助</p>
<p>动图封面<br>9、Prettier<br>比Beautify更好用的代码格式化插件<br>Vue插件<br>vetur<br>语法高亮、智能感知、Emmet等</p>
<p>VueHelper<br>snippet代码片段</p>
<p>动图封面</p>
<h4 id="其它插件"><a href="#其它插件" class="headerlink" title="其它插件"></a>其它插件</h4><p>1、CSScomb</p>
<p>CSS 书写顺序规则，这里我推荐腾讯 AollyTeam 团队的规范：</p>
<p><a href="http://alloyteam.github.io/CodeGuide/#css-declaration-order">http://alloyteam.github.io/CodeGuide/#css-declaration-order</a><br>​alloyteam.github.io/CodeGuide/#css-declaration-order<br>简单说下这个插件怎么用：</p>
<p>在项目的根目录下创建一个名为csscomb.json的文件，然后添加一些配置项。也可以将配置项写入项目的 package.json 文件中的 csscombConfig 字段。</p>
<p>至于添加的配置项，CSScomb 提供了示例配置文件：</p>
<p><a href="https://github.com/csscomb/csscomb.js/blob/master/config/csscomb.json">https://github.com/csscomb/csscomb.js/blob/master/config/csscomb.json</a><br>​github.com/csscomb/csscomb.js/blob/master/config/csscomb.json<br>其中的 sort-order 就是 CSS 属性书写顺序，可以按照自己遵循的规范设置，所以我直接替换成了腾讯的。</p>
<p>这个配置文件里面各个字段的作用可以戳这里查看：</p>
<p>csscomb/csscomb.js<br>​github.com/csscomb/csscomb.js/blob/master/doc/options.md<br>2、Turbo Console Log</p>
<p>快捷添加 console.log，一键 注释 / 启用 / 删除 所有 console.log。这也是我最常用的一个插件</p>
<p>动图封面<br>简单说下这个插件要用到的快捷键:</p>
<p>ctrl + alt + l 选中变量之后，使用这个快捷键生成 console.log<br>alt + shift + c 注释所有 console.log<br>alt + shift + u 启用所有 console.log<br>alt + shift + d 删除所有 console.log<br>3、GitLens</p>
<p>详细的 Git 提交日志。</p>
<p>Git 重度使用者必备，尤其是多人协作时：哪一行代码，何时、何人提交都有记录。</p>
<p>妈妈再也不用担心我背锅了！</p>
<p>4、css-auto-prefix<br>自动添加 CSS 私有前缀。</p>
<p>动图封面<br>5、change-case<br>转换命名风格。</p>
<p>动图封面<br>6、CSS Peek</p>
<p>定位 CSS 类名。</p>
<p>动图封面<br>7、vscode-json</p>
<p>处理 JSON 文件，用法看图：</p>
<p>动图封面<br>8、Regex Previewer<br>实时预览正则表达式的效果。</p>
<p>动图封面</p>
<h3 id="设置同步"><a href="#设置同步" class="headerlink" title="设置同步"></a>设置同步</h3><p>花了一天终于把vscode配置成自己满意的样子，如果每换一次电脑就要重新来一次，大家一定会手撕了我。放心，早就帮大家准备好了。Settings Sync，在不同电脑间同步你的插件。</p>
<p>首先要想在不同的设备间同步你的插件, 需要用到 Token 和Gist id</p>
<p>Token 就是你把插件上传到 github 上时, 让你保存的那段字符，Gist id 在你上传插件的那台电脑上保存着。</p>
<p>先给大家来三个快捷键，后面会用到</p>
<p>1、CTRL+SHIFT+P 我也不知道叫什么，暂且就叫它功能搜索功能吧<br>2、ALT+SHIFT+D 下载配置<br>3、ALT+SHIFT+U 上传配置<br>现在手把手教大家配置：</p>
<p>1、安装Settings Sync<br>2、登陆Github&gt;settings&gt;Developer settings&gt;personal access tokens&gt;generate new token，输入名称，勾选Gist，提交</p>
<p>3、保存Github Access Token<br>4、打开vscode，Ctrl+Shift+P打开命令框–&gt;输入sync–&gt;选择高级设置–&gt;编辑本地扩展设置–&gt;编辑token</p>
<p>5、Ctrl+Shift+P打开命令框–&gt;输入sync–&gt;找到update/upload settings，上传成功后会返回Gist ID，保存此Gist ID.</p>
<p>动图封面<br>6、在 VSCode 里，依次打开: 文件 -&gt; 首选项 -&gt; 设置，然后输入 Sync 进行搜索:能找到你gist id</p>
<p>7、若需在其他机器上DownLoad插件的话，同样，Ctrl+Shift+P打开命令框，输入sync，找到Download settings，会跳转到Github的Token编辑界面，点Edit，regenerate token，保存新生成的token，在vscode命令框中输入此Token，回车，再输入之前的Gist ID，即可同步插件和设置</p>
<h3 id="开启本地服务"><a href="#开启本地服务" class="headerlink" title="开启本地服务"></a>开启本地服务</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p>1.安装Debugger for Chrome插件</p>
<p>2.使用ctrl+`快捷键打开终端，然后输入npm install -g live-server</p>
<p>3.在命令行里输入 live-server即可</p>
<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p>在写前端页面中，经常会在浏览器运行HTML页面，从本地文件夹中直接打开的一般都是file协议，当代码中存在http或https的链接时，HTML页面就无法正常打开，为了解决这种情况，需要在在本地开启一个本地的服务器。 本文是利用node.js中的http-server，开启本地服务，步骤如下：</p>
<p>1.安装http-server</p>
<p>在终端输入： $ npm install http-server -g</p>
<p>2.开启 http-server服务</p>
<p>终端进入目标文件夹，然后在终端输入：</p>
<p>$ http-server -c-1   （⚠️只输入http-server的话，更新了代码后，页面不会同步更新）<br>Starting up http-server, serving ./<br>Available on:<br>  <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a><br>  <a href="http://192.168.8.196:8080/">http://192.168.8.196:8080</a><br>Hit CTRL-C to stop the server<br>3.关闭 http-server服务</p>
<p>按快捷键CTRL-C 终端显示^Chttp-server stopped.即关闭服务成功。</p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是VSCode的安装和介绍教程了,</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>工具浅玩类</tag>
      </tags>
  </entry>
</search>
