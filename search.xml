<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GitHub开发者交流平台注册教程</title>
    <url>/2020/09/08/GitHub%E5%BC%80%E5%8F%91%E8%80%85%E4%BA%A4%E6%B5%81%E5%B9%B3%E5%8F%B0%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="GitHub食用教程："><a href="#GitHub食用教程：" class="headerlink" title="GitHub食用教程："></a>GitHub食用教程：</h1><p>GitHub 是一个由美国公司开发的面向开源及私有软件项目的托管平台，<br>因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。<br>GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。</p>
<p>想要成为一个合格的程序员必须要掌握 GitHub 的用法！</p>
<p>由于github是美国公司开发的网站，现在是半墙状态，中国网络限制访问外国网站，有条件的可以开ssh，科学上网<br>优先推荐使用chrome（谷歌浏览器）或者微软edge浏览器</p>
<h3 id="注册github流程"><a href="#注册github流程" class="headerlink" title="注册github流程"></a>注册github流程</h3><p>1.首先进入github官网 <a href="https://github.com/">https://github.com/</a></p>
<p><img src="/github%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B/1.png"></p>
<p>2.点击绿色框Sign up for GitHub进行注册<br>注意：<br>Sign in，登录<br>Sign up，注册</p>
<p><img src="/github%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B/2.png"></p>
<p>3.注册页面第一栏email（邮箱），第二栏password（密码），第三栏username（用户名）</p>
<p>进行验证后即可完成注册</p>
<p>如果看不懂英文可以用网页翻译器，浏览网站内的项目内容</p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是玩转GitHub开发者社区的教程了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>教程类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Hadoop大数据技术</title>
    <url>/2021/12/18/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="关于Hadoop大数据技术"><a href="#关于Hadoop大数据技术" class="headerlink" title="关于Hadoop大数据技术:"></a>关于Hadoop大数据技术:</h1><h1 id="Hadoop-概述"><a href="#Hadoop-概述" class="headerlink" title="Hadoop 概述"></a>Hadoop 概述</h1><h2 id="1-1-Hadoop-是什么"><a href="#1-1-Hadoop-是什么" class="headerlink" title="1.1 Hadoop 是什么"></a>1.1 Hadoop 是什么</h2><p>（1）Hadoop是一个由Apache基金会所开发的分布式系统基础架构<br>（2）主要解决海量数据的存储和海量数据的分析计算问题<br>（3）广义上来说，Hadoop通常是指一个更广泛的概念——Hadoop生态圈</p>
<h2 id="1-2-Hadoop-优势"><a href="#1-2-Hadoop-优势" class="headerlink" title="1.2 Hadoop 优势"></a>1.2 Hadoop 优势</h2><p>（1）高可靠性：Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。<br>（2）高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。<br>（3）高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。<br>（4）高容错性：能够自动将失败的任务重新分配。</p>
<h2 id="1-3-Hadoop-组成★★★★★"><a href="#1-3-Hadoop-组成★★★★★" class="headerlink" title="1.3 Hadoop 组成★★★★★"></a>1.3 Hadoop 组成★★★★★</h2><p><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/1.png"></p>
<p>在Hadoop1.x 时代，Hadoop中的MapReduce同时处理业务逻辑运算和资源的调度，耦合性较大。<br>在Hadoop2.x时代，增加了Yarn。Yarn只负责资源的调度，MapReduce 只负责运算。<br>Hadoop3.x在组成上没有变化。</p>
<h3 id="1-3-1-HDFS-架构概述"><a href="#1-3-1-HDFS-架构概述" class="headerlink" title="1.3.1 HDFS 架构概述"></a>1.3.1 HDFS 架构概述</h3><p>Hadoop Distributed File System，简称HDFS，是一个分布式文件系统。</p>
<p>（1）NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。<br>（2）DataNode(dn)：在本地文件系统存储文件块数据，以及块数据的校验和。<br>（3）Secondary NameNode(2nn)：每隔一段时间对NameNode元数据备份。</p>
<h3 id="1-3-2-YARN-架构概述"><a href="#1-3-2-YARN-架构概述" class="headerlink" title="1.3.2 YARN 架构概述"></a>1.3.2 YARN 架构概述</h3><p>Yet Another Resource Negotiator 简称YARN ，另一种资源协调者，是Hadoop 的资源管理器。</p>
<p><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/2.png"></p>
<p>ResourceManager(RM)：整个集群资源（内存、CPU等）的管理者<br>NodeManager(NM)：单个节点服务器资源的管理者。<br>ApplicationMaster(AM)：单个任务运行的管理者。<br>Container：容器，相当于一台独立的服务器，里面封装了任务运行所需要的资源，如内存、CPU、磁盘、网络等。</p>
<p>说明：<br>（1）客户端可以有多个<br>（2）集群上可以运行多个ApplicationMaster<br>（3）每个NodeManager上可以有多个Container</p>
<h3 id="1-3-3-MapReduce-架构概述"><a href="#1-3-3-MapReduce-架构概述" class="headerlink" title="1.3.3 MapReduce 架构概述"></a>1.3.3 MapReduce 架构概述</h3><p>MapReduce 将计算过程分为两个阶段：Map 和Reduce<br>1）Map 阶段并行处理输入数据<br>2）Reduce 阶段对Map 结果进行汇总</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/3.png"></h3><h3 id="1-3-4-HDFS、YARN、MapReduce-三者关系"><a href="#1-3-4-HDFS、YARN、MapReduce-三者关系" class="headerlink" title="1.3.4 HDFS、YARN、MapReduce 三者关系"></a>1.3.4 HDFS、YARN、MapReduce 三者关系</h3><p>如图所示：</p>
<p><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/4.png"></p>
<h3 id="1-3-5-大数据技术生态体系"><a href="#1-3-5-大数据技术生态体系" class="headerlink" title="1.3.5 大数据技术生态体系"></a>1.3.5 大数据技术生态体系</h3><p>如图所示：</p>
<p><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/5.png"></p>
<p>图中涉及的技术名词解释如下：</p>
<p>（1）Sqoop：Sqoop 是一款开源的工具，主要用于在Hadoop、Hive 与传统的数据库（MySQL）间进行数据的传递，可以将一个关系型数据库（例如 ：MySQL，Oracle 等）中的数据导进到Hadoop 的HDFS 中，也可以将HDFS 的数据导进到关系型数据库中。<br>（2）Flume：Flume 是一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume 支持在日志系统中定制各类数据发送方，用于收集数据。<br>（3）Kafka：Kafka 是一种高吞吐量的分布式发布订阅消息系统。<br>（4）Spark：Spark 是当前最流行的开源大数据内存计算框架。可以基于Hadoop 上存储的大数据进行计算。<br>（5）Flink：Flink 是当前最流行的开源大数据内存计算框架。用于实时计算的场景较多。<br>（6）Oozie：Oozie 是一个管理Hadoop 作业（job）的工作流程调度管理系统。<br>（7）HBase：HBase 是一个分布式的、面向列的开源数据库。HBase 不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。<br>（8）Hive：Hive 是基于Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的SQL 查询功能，可以将SQL 语句转换为MapReduce 任务进行运行。其优点是学习成本低，可以通过类SQL 语句快速实现简单的MapReduce 统计，不必开发专门的MapReduce 应用，十分适合数据仓库的统计分析。<br>（9）ZooKeeper：它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。</p>
<h3 id="1-3-6-推荐系统框架图"><a href="#1-3-6-推荐系统框架图" class="headerlink" title="1.3.6 推荐系统框架图"></a>1.3.6 推荐系统框架图</h3><p>推荐系统项目框架<br><img src="/%E5%85%B3%E4%BA%8EHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/6.png"></p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对Hadoop的详细介绍了，</strong></p>
<p><strong>详细的环境搭建教程，可以上csdn开发者论坛，博客园或者百度进行搜索，这里就不过多演示了.</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JVM</title>
    <url>/2022/07/18/%E5%85%B3%E4%BA%8EJVM/</url>
    <content><![CDATA[<p>JVM总结<br>一、JVM概述<br>定义<br>Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境）</p>
<p>好处<br>一次编写，到处运行（多系统运行）<br>自动内存管理，垃圾回收机制<br>数组下标越界检查<br>比较<br>JVM、JRE、JDK的意义和区别</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/1.png">                                                                                                                   </p>
<p>​                                                               </p>
<p>​                                                                   <strong>JVM、JRE、JDK的意义与区别</strong></p>
<h2 id="二、JVM内存结构"><a href="#二、JVM内存结构" class="headerlink" title="二、JVM内存结构"></a>二、JVM内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><img src="/%E5%85%B3%E4%BA%8EJVM/2.png"></p>
<p>​                                                                                    <strong>JVM结构图</strong></p>
<h3 id="2-1、程序计数器"><a href="#2-1、程序计数器" class="headerlink" title="2.1、程序计数器"></a>2.1、程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h4><p>用于保存JVM中下一条所要执行的指令的地址</p>
<p>JAVA代码执行流程：</p>
<p>JAVA代码 =&gt; 编译后得到二进制字节码（JVM指令）=&gt; 解释器 =&gt; 机器码（0101） =&gt; CPU执行</p>
<p>其中程序计数器保存下一条JVM指令，当上一个指令完成时继续执行代码</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li>线程私有<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程所私有的</strong>，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通 过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li>不会存在内存溢出</li>
</ul>
<h3 id="2-2、虚拟机栈"><a href="#2-2、虚拟机栈" class="headerlink" title="2.2、虚拟机栈"></a>2.2、虚拟机栈</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li>
</ul>
<h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a><strong>问题辨析</strong></h4><ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要。</strong>因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所 以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>如果方法内局部变量<strong>没有逃离方法的作用范围，则是线程安全的</strong></li>
<li>如果如果<strong>局部变量引用了对象，并逃离了方法的作用范围</strong>，则需要考虑线程安全问题（逃逸分析）</li>
</ul>
</li>
<li>内存溢出（Java.lang.stackOverflowError）可能存在的原因？<ul>
<li>虚拟机栈中，栈帧过多（无限递归）</li>
<li>每个栈帧所占用过大</li>
</ul>
</li>
<li>线程运行诊断（CPU占用过高）<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul>
<li>top命令，查看是哪个进程占用CPU过高</li>
<li>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是 哪个线程占用CPU过高</li>
<li>jstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找 出的线程id是16进制的，需要转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3、本地方法栈"><a href="#2-3、本地方法栈" class="headerlink" title="2.3、本地方法栈"></a>2.3、本地方法栈</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h4><p>一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作 系统底层交互，所以需要用到本地方法</p>
<h3 id="2-4、堆"><a href="#2-4、堆" class="headerlink" title="2.4、堆"></a>2.4、堆</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>通过<strong>new关键字创建的对象</strong>都会被放在堆内存</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>存在垃圾回收机制</li>
</ul>
<h4 id="问题辨析-1"><a href="#问题辨析-1" class="headerlink" title="问题辨析"></a><strong>问题辨析</strong></h4><ul>
<li>堆内存溢出（java.lang.OutofMemoryError ：java heap space.）诊断工具<ul>
<li>jps</li>
<li>jmap</li>
<li>jconsole</li>
<li>jvirsalvm</li>
</ul>
</li>
</ul>
<h3 id="2-5、方法区"><a href="#2-5、方法区" class="headerlink" title="2.5、方法区"></a>2.5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/3.png"></p>
<p>​                                                                                       <strong>方法区结构</strong></p>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>1.6以前方法区存在于<strong>堆中</strong>，会导致<strong>永久代内存溢出</strong></li>
<li>1.8以后方法区存在于<strong>元空间中</strong>（元空间位于本地内存中），会导致<strong>元空间内存溢出</strong></li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a><strong>常量池</strong></h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p>
<p><strong>通过反编译来查看类的信息</strong></p>
<ul>
<li>获得对应类的.class文件<ul>
<li>在JDK对应的bin目录下运行cmd，也可以在IDEA控制台输入</li>
<li>输入 javac 对应类的绝对路径</li>
</ul>
</li>
</ul>
<pre class="language-none"><code class="language-none">C:\JAVA\JDK8.0\bin&gt;javac C:\study\src\com\nyima\JVM\day01\Main.java</code></pre>

<ul>
<li><p>输入完成后，对应的目录下就会出现类的.class文件</p>
</li>
<li><p>在控制台输入 javap -v 类的绝对路径</p>
<pre class="language-none"><code class="language-none">javap -v C:\study\src\com\nyima\JVM\day01\Main.class</code></pre>


</li>
<li><p>然后能在控制台看到反编译以后类的信息了</p>
</li>
</ul>
<p>包括类的基本信息、常量池</p>
<p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，#号的内容需要在常量池中查找）</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h4><ul>
<li>常量池<ul>
<li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法 名、参数类型、字面量信息</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>常量池是.class文件中的，当该<em>类被加载以后，<strong>它的常量池信息</strong>就会放入运行时常量池，*<em>并把里面的符号地址变为真实地址</em></em></li>
</ul>
</li>
</ul>
<h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a><strong>常量池与串池的关系</strong></h4><p>stringtable、stringpool、串池、字符串常量池，这四个是一个东西。</p>
<p>但是跟常量池不是一个东西！<strong>串池在堆中</strong></p>
<p>跟常量池是包含关系，跟运行时常量池是互斥关系。</p>
<h4 id="串池（StringTable）"><a href="#串池（StringTable）" class="headerlink" title="串池（StringTable）"></a><strong>串池（StringTable）</strong></h4><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h5><ul>
<li><p>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></p>
</li>
<li><p>利用串池的机制，来避免重复创建字符串对象</p>
</li>
<li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p>
</li>
<li><p>字符串常量拼接的原理是编译器优化</p>
</li>
<li><p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</p>
</li>
<li><p>结构为HashTable (数组 + 链表)</p>
</li>
<li><p><strong>注意：</strong>无论是串池还是堆里面的字符串，都是对象</p>
</li>
<li><p><strong>注意：</strong>字符串对象的创建<strong>都是懒惰的</strong>，只有当运行到那一行字符串<strong>且在串池中不存在的时候</strong>（如 ldc #2） 时，该字符串才会被创建并放入串池中。</p>
</li>
<li><p><strong>注意：</strong>通过<strong>拼接的方式</strong>来创建字符串的过程</p>
<p>只能在运行期确定它的值，所以需要使用StringBuilder来创建</p>
<p>StringBuilder().append(“a”).append(“b”).toString()</p>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的值和拼接的字符串一致，但是是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>
</li>
</ul>
<h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a><strong>intern方法 1.8</strong></h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意：</strong>此时如果调用intern方法<strong>成功</strong>，<strong>堆内存与串池中</strong>的字符串对象是<strong>同一个对象</strong>；</p>
<p> 如果失败，则不是同一个 对象</p>
<h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a><strong>intern方法 1.6</strong></h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p>注意：此时无论调用intern方法<strong>成功与否</strong>，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p>
<h5 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a><strong>StringTable 垃圾回收</strong></h5><p>StringTable在内存紧张时，<strong>会发生垃圾回收</strong></p>
<h5 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a><strong>StringTable调优</strong></h5><ul>
<li>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</li>
</ul>
<pre class="language-none"><code class="language-none">-XX:StringTableSize=xxxx</code></pre>

<ul>
<li><p>考虑是否需要将字符串对象入池</p>
<p>可以<strong>通过intern方法减少重复入池</strong></p>
</li>
</ul>
<h3 id="2-6、直接内存"><a href="#2-6、直接内存" class="headerlink" title="2.6、直接内存"></a>2.6、直接内存</h3><ul>
<li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/4.png"></p>
<p>​                                                                                <strong>文件读写流程</strong></p>
<p><strong>使用了DirectBuffer</strong></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/5.png"></p>
<p>​                                                                              <strong>文件读写流程</strong></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高 了效率</p>
<h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p>
<pre class="language-none"><code class="language-none">//通过ByteBuffer申请1M的直接内存
ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</code></pre>

<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p><strong>allocateDirect的实现</strong></p>
<pre class="language-none"><code class="language-none">public static ByteBuffer allocateDirect(int capacity) {
 return new DirectByteBuffer(capacity);
}</code></pre>

<p><strong>DirectByteBuffer类</strong></p>
<pre class="language-none"><code class="language-none">DirectByteBuffer(int cap) { // package-private

            super(-1, 0, cap, cap);
            boolean pa = VM.isDirectMemoryPageAligned();
            int ps = Bits.pageSize();
            long size = Math.max(1L, (long)cap + (pa ? ps : 0));
            Bits.reserveMemory(size, cap);
            long base = 0;
            try {
                base = unsafe.allocateMemory(size); //申请内存
            } catch (OutOfMemoryError x) {
                Bits.unreserveMemory(size, cap);
                throw x;
            }
            unsafe.setMemory(base, size, (byte) 0);
            if (pa &amp;&amp; (base % ps != 0)) {
                // Round up to page boundary
                address = base + ps - (base &amp; (ps - 1));
            } else {
                address = base;
            }
            //通过虚引用，来实现直接内存的释放，this为虚引
            cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); 
            att = null;
        }</code></pre>

<p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测</p>
<p>如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p>
<pre class="language-none"><code class="language-none">public void clean() {
            if (remove(this)) {
                try {
                    this.thunk.run(); //调用run方法
                } catch (final Throwable var2) {
                    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                        public Void run() {
                            if (System.err != null) {
                                (new Error("Cleaner terminated abnormally", var2)).printStackTrace();
                            }
                            System.exit(1);
                            return null;
                        }
                    });
                }

    }
}</code></pre>

<p>对应对象的run方法</p>
<pre class="language-none"><code class="language-none">public void run() {
           if (address == 0) {
               // Paranoia
               return;
           }
           unsafe.freeMemory(address); //释放直接内存中占用的内存
           address = 0;
           Bits.unreserveMemory(size, capacity);
       }</code></pre>

<h4 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h4><ul>
<li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li>
<li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么 会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li>
</ul>
<h2 id="三、JVM垃圾回收机制"><a href="#三、JVM垃圾回收机制" class="headerlink" title="三、JVM垃圾回收机制"></a>三、JVM垃圾回收机制</h2><h3 id="1、如何判断对象可以被回收？"><a href="#1、如何判断对象可以被回收？" class="headerlink" title="1、如何判断对象可以被回收？"></a>1、如何判断对象可以被回收？</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>若对象被引用则该对象的计数加1</p>
<p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/6.png"></p>
<p>​                                                                      <strong>相互引用导致无法释放</strong></p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul>
<li><p>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象</p>
</li>
<li><p>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p>
</li>
<li><p>可以作为</p>
<p>GC Root的对象</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
</li>
</ul>
<h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/7.png"></p>
<p>​                                                                            <strong>五种引用说明</strong></p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root都不引用该对象时，才会回收强引用对象</p>
<p>如上图B、C对象都不引用A1对象时，A1对象才会被回收</p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象</p>
<p>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</p>
<ul>
<li>软引用的使用</li>
</ul>
<pre class="language-none"><code class="language-none">public class Demo1 {
            public static void main(String[] args) {
                final int _4M = 4*1024*1024;
				//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用
                List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
                SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);
            }
        }</code></pre>

<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>如果想要<strong>清理软引用，需要使用引用队列</strong></p>
<pre class="language-none"><code class="language-none">public class Demo1 {
            public static void main(String[] args) {
                final int _4M = 4*1024*1024;
                //使用引用队列，用于移除引用为空的软引用对象
                ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
                //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用
                List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
                SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);
                //遍历引用队列，如果有元素，则移除
                Reference&lt;? extends byte[]&gt; poll = queue.poll();
                while(poll != null) {
                //引用队列不为空，则从集合中移除该元素
                    list.remove(poll);
                //移动到引用队列中的下一个元素
                    poll = queue.poll();
                }
            }
        }</code></pre>

<ul>
<li><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</li>
</ul>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用所引用的对象</p>
<p>如上图如果B对象不再引用A3对象，则A3对象会被回收</p>
<p><strong>弱引用的使用和软引用类似，只是将 SoftReference 换为了 WeakReference</strong></p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p>
<ul>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象 Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。 这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将 终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize 方法。调用以后，该对象就可以被垃圾回收了</p>
<p>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所 引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul>
<li><p>软引用和弱引用可以配合引用队列</p>
<p>在弱引用和虚引用所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/ 弱引用对象</p>
</li>
<li><p>虚引用和终结器引用必须配合引用队列</p>
</li>
</ul>
<h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/8.png"></p>
<p>​                                                                           <strong>标记清除算法图解</strong></p>
<h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后 垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h5><p><strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm 启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h4 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/9.png"></p>
<p>​                                                                          <strong>标记整理算法图解</strong></p>
<h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>标记-整理会将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/10.png"></p>
<p>​                                     </p>
<p>​                                                                            <strong>复制算法图解</strong></p>
<h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO 中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用 双倍的内存空间。</p>
<h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><img src="/%E5%85%B3%E4%BA%8EJVM/11.png"></p>
<p>​                                                                                 <strong>分代回收图解</strong></p>
<h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>1、新创建的对象都被放在了新生代的伊甸园中</p>
<p>2、当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>
<p><strong>Minor GC</strong> 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先复制到幸存区 TO中</strong>， 并让其寿命加1，再<strong>交换两个幸存区</strong></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/12.png"></p>
<p>​                                                                             <strong>Minor GC 图解</strong></p>
<p>3、再次创建对象，若<strong>新生代的伊甸园又满了</strong>，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用 户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的<strong>对象寿命加1</strong></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/13.png"></p>
<p>4、如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被放入老年代中</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/14.png"></p>
<p>​                                                                              <strong>对象晋升老年代</strong></p>
<p>5、如果新生代老年代中的内存都满了，就会先触发<strong>Minor GC</strong>，再触发<strong>Full GC</strong>，扫描新生代和老年代中所有不再使用的对象并回收</p>
<h4 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/15.png"></p>
<p>​                                                                             <strong>相关JVM参数</strong></p>
<h4 id="GC分析"><a href="#GC分析" class="headerlink" title="GC分析"></a>GC分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a><strong>大对象处理策略</strong></h5><p>当遇到一个<strong>较大的对象时</strong>，就算新生代的伊甸园为空，也无法容纳该对象时，<strong>会将该对象直接晋升为老年代</strong></p>
<h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a><strong>线程内存溢出</strong></h5><p><strong>某个线程的内存溢出了而抛异常</strong>（out of memory），不会让<strong>其他的线程结束运行</strong></p>
<p>这是因为当一个线程抛出OOM异常后，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，进程依然正常</p>
<h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><strong>相关概念</strong></h4><p><strong>并行收集：</strong>指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</p>
<p><strong>并发收集：</strong>指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行， 而垃圾收集程序运行在另一个CPU上</p>
<p><strong>吞吐量：</strong>即CPU用于<strong>运行用户代码的时间</strong>与<strong>CPU总消耗时间</strong>的比值</p>
<p> （吞吐量 = 运行用户代码时间 / ( 运行用户 代码时间 + 垃圾收集时间 )）</p>
<p> 例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量 就是99%</p>
<p><strong>串行：</strong></p>
<ul>
<li>单线程</li>
<li>内存较小，一般用于个人电脑（CPU核数较少）</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/16.png"></p>
<p>​                                                                                 <strong>串行图解</strong></p>
<p><strong>安全点：</strong>让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象 因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞状态</strong></p>
<h4 id="相关收集器"><a href="#相关收集器" class="headerlink" title="相关收集器"></a>相关收集器</h4><p><strong>Serial 收集器</strong></p>
<p>Serial收集器是最基本的、发展历史最悠久的收集器</p>
<ul>
<li><p><strong>特点</strong></p>
<p>单线程、简单高效（与其他收集器的单线程相比），<strong>采用复制算法</strong>。对于限定单个CPU的环境来说， Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃 圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
</li>
</ul>
<p><strong>ParNew 收集器</strong></p>
<p>ParNew收集器其实就是Serial收集器的多线程版本</p>
<ul>
<li><p><strong>特点</strong></p>
<p>多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使 用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
</li>
</ul>
<p><strong>Serial Old 收集器</strong></p>
<p>Serial Old是Serial收集器的老年代版本</p>
<ul>
<li><p><strong>特点</strong></p>
<p>同样是单线程收集器，采用<strong>标记-整理算法</strong></p>
</li>
</ul>
<h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul>
<li>说明<ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li>
<li><strong>JDK1.8默认使用的垃圾回收器</strong></li>
</ul>
</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/17.png"></p>
<p>​                                                                             <strong>运行流程图</strong></p>
<p><strong>Parallel Scavenge 收集器</strong></p>
<p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<ul>
<li><p><strong>特点</strong></p>
<p>属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器 （与ParNew收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收 集器最重要的一个区别）</p>
</li>
</ul>
<p><strong>GC自适应调节策略：</strong>Parallel Scavenge收集器可设置<code>-XX:+UseAdptiveSizePolicy</code>参数。当开关打开时不需 要手动指定新生代的大小（<code>-Xmn</code>）、Eden与Survivor区的比例（<code>-XX:SurvivorRation</code>）、晋升老年代的对象 年龄（<code>-XX:PretenureSizeThreshold</code>）等，虚拟机会根据系统的运行状况收集性能监控信息，<strong>动态设置这些参数以提供最优的停顿时间和最高的吞吐量</strong>，这种调节方式称为GC的自适应调节策略。</p>
<p><strong>Parallel Scavenge收集器使用两个参数控制吞吐量：</strong></p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
<p><strong>Parallel Old 收集器</strong></p>
<p>是Parallel Scavenge收集器的老年代版本</p>
<ul>
<li><p><strong>特点</strong></p>
<p>多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>
</li>
</ul>
<h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul>
<li>说明<ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li>
</ul>
</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/18.png"></p>
<p>​                                                                                <strong>运行流程图</strong></p>
<p><strong>CMS 收集器说明</strong></p>
<p><strong>Concurrent Mark Sweep</strong>，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代收集器</strong></p>
<ul>
<li><p><strong>特点</strong></p>
<p>基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片</p>
</li>
<li><p><strong>应用场景</strong></p>
<p>适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程 序、b/s服务</p>
</li>
</ul>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记：</strong>标记GC Roots能直接到的对象。速度很快但是仍存在<strong>Stop The World</strong>问题</p>
<p><strong>并发标记：</strong>进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
<p><strong>重新标记：</strong>为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在<strong>Stop The World</strong>问题</p>
<p><strong>并发清除：</strong>对标记的对象进行清除回收CMS收集器的内存回收过程是与用户线程一起并发执行的</p>
<p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a><strong>定义</strong></h5><p><strong>Garbage First</strong></p>
<p>JDK 9以后默认使用，而且替代了CMS 收集器</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/19.png"></p>
<h5 id="适用场景和特点"><a href="#适用场景和特点" class="headerlink" title="适用场景和特点"></a><strong>适用场景和特点</strong></h5><ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制算法</strong></li>
</ul>
<h5 id="相关参数-1"><a href="#相关参数-1" class="headerlink" title="相关参数"></a><strong>相关参数</strong></h5><p>JDK8 并不是默认开启的，所需要参数开启</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/21.png"></p>
<p>​                                                                    <strong>G1垃圾回收器相关参数</strong></p>
<h5 id="G1垃圾回收步骤"><a href="#G1垃圾回收步骤" class="headerlink" title="G1垃圾回收步骤"></a><strong>G1垃圾回收步骤</strong></h5><p><img src="/%E5%85%B3%E4%BA%8EJVM/22.png"></p>
<p>​                                                                           <strong>G1垃圾回收步骤</strong></p>
<p><strong>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记</strong></p>
<p><strong>—–&gt;回收新生代伊甸园、幸存区、老年代内存 ——&gt;新生代伊甸园垃圾回收(重新开始)</strong></p>
<h6 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a><strong>Young Collection</strong></h6><p><strong>分区算法region</strong></p>
<p>分代是<strong>按对象的生命周期划分</strong>，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<ul>
<li><strong>会产生STW</strong></li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/23.png"></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/24.png"></p>
<h6 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a><strong>Young Collection + CM</strong></h6><p>CM：并发标记</p>
<ul>
<li>在 Young GC 时会对 <strong>GC Root 进行初始标记</strong></li>
<li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/25.png"></p>
<h6 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a><strong>Mixed Collection</strong></h6><p>会对E S O 进行<strong>全面的回收</strong></p>
<ul>
<li>最终标记</li>
<li>拷贝<strong>存活</strong></li>
</ul>
<p><code>-XX:MaxGCPauseMills:xxx</code> 用于指定最长的停顿时间</p>
<p><strong>问：</strong>为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后能够得到更多内存）</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/26.png"></p>
<h6 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h6><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
<h6 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a><strong>Young Collection 跨代引用</strong></h6><ul>
<li>新生代回收的跨代引用（老年代引用新生代）问题</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/27.png"></p>
<ul>
<li>卡表与Remembered Set<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称 为脏卡</li>
</ul>
</li>
</ul>
</li>
<li>在引用变更时通过post-write barried + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/28.png"></p>
<h6 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a><strong>Remark</strong></h6><p>重新标记阶段</p>
<p>在垃圾回收时，收集器处理对象的过程中 :</p>
<p>黑色：已被处理，需要保留的</p>
<p>灰色：正在处理中的</p>
<p>白色：还未处理的</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/29.png"></p>
<p>但是在<strong>并发标记</strong>过程中，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用 了C，这时就会用到remark</p>
<p><strong>过程如下：</strong></p>
<ul>
<li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当 中，并将C变为 处理中 状态</li>
<li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用 引用它，就会处理它</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/30.png"></p>
<h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p><strong>过程</strong></p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们引用同一个字符串对象</li>
<li>注意，其与String.intern的区别<ul>
<li>intern关注的是字符串对象</li>
<li>字符串去重关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串标</li>
</ul>
</li>
</ul>
<p><strong>优点与缺点</strong></p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收 时处理掉</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/31.png"></p>
<h3 id="5、GC调优"><a href="#5、GC调优" class="headerlink" title="5、GC调优"></a>5、GC调优</h3><h4 id="查看虚拟机参数命令"><a href="#查看虚拟机参数命令" class="headerlink" title="查看虚拟机参数命令"></a><strong>查看虚拟机参数命令</strong></h4><pre class="language-none"><code class="language-none">"F:\JAVA\JDK8.0\bin\java" -XX:+PrintFlagsFinal -version | findstr "GC"</code></pre>

<p>可以根据参数去查询具体的信息</p>
<h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a><strong>调优领域</strong></h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a><strong>确定目标</strong></h4><p>低延迟/高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS G1 ZGC</li>
<li>ParallelGC</li>
<li>Zing</li>
</ul>
<p><strong>最快的GC是不发生GC</strong></p>
<p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<p>查看Full GC前后的内存占用，考虑以下几个问题</p>
<ul>
<li>数据是不是太多？</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a><strong>新生代调优</strong></h4><ul>
<li>新生代的特点<ul>
<li>所有的new操作分配内存都是非常廉价的<ul>
<li>TLAB</li>
</ul>
</li>
<li>死亡对象回收零代价</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于Full GC</li>
</ul>
</li>
<li>新生代内存越大越好么？<ul>
<li>不是<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时， 清理新生代所花费的时间会更长</li>
</ul>
</li>
<li>新生代内存设置为内容纳 [并发量*(请求-响应)] 的数据为宜</li>
</ul>
</li>
</ul>
<h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a><strong>幸存区调优</strong></h4><ul>
<li>幸存区需要能够保存 <strong>当前活跃对象+需要晋升的对象</strong></li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>
</ul>
<h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a><strong>老年代调优</strong></h4><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a><strong>结构图</strong></h3><p><img src="/%E5%85%B3%E4%BA%8EJVM/32.png"></p>
<h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a><strong>1、类文件结构</strong></h3><p>首先获得.class字节码文件</p>
<p>方法：</p>
<ul>
<li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li>
<li>java终端中，执行javac X:…\XXX.java</li>
</ul>
<p>根据 JVM 规范，<strong>类文件结构</strong>如下</p>
<pre class="language-none"><code class="language-none">u4 magic
u2 minor_version; 
u2 major_version; 
u2 constant_pool_count; 
cp_info constant_pool[constant_pool_count-1]; 
u2 access_flags; 
u2 this_class; 
u2 super_class; 
u2 interfaces_count; 
u2 interfaces[interfaces_count]; 
u2 fields_count; 
field_info fields[fields_count]; 
u2 methods_count; 
method_info methods[methods_count]; 
u2 attributes_count; 
attribute_info attributes[attributes_count];</code></pre>

<p><strong>魔数</strong></p>
<p>u4 magic</p>
<p>对应字节码文件的0~3个字节</p>
<p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p><strong>版本</strong></p>
<pre class="language-none"><code class="language-none">u2 minor_version;
u2 major_version;
0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
34H = 52，代表JDK8</code></pre>

<h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><p>可参考</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p>
<p>javap工具</p>
<p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p>
<pre class="language-none"><code class="language-none">javap -v C:\study\src\com\nyima\JVM\day01\Main.class</code></pre>

<h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a><strong>图解方法执行流程</strong></h4><h5 id="一、执行的方法代码"><a href="#一、执行的方法代码" class="headerlink" title="一、执行的方法代码"></a>一、执行的方法代码</h5><pre class="language-none"><code class="language-none">public class Demo3_1 {
            public static void main(String[] args) {
                int a = 10;
                int b = Short.MAX_VALUE + 1;
                int c = a + b;
                System.out.println(c);
            }
        }</code></pre>

<h5 id="二、常量池载入运行时常量池"><a href="#二、常量池载入运行时常量池" class="headerlink" title="二、常量池载入运行时常量池"></a><strong>二、常量池载入运行时常量池</strong></h5><p>常量池也属于方法区，只不过这里单独提出来了</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/33.png"></p>
<h5 id="三、方法字节码载入方法区"><a href="#三、方法字节码载入方法区" class="headerlink" title="三、方法字节码载入方法区"></a>三、方法字节码载入方法区</h5><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/34.png"></p>
<h5 id="四、执行引擎开始执行字节码"><a href="#四、执行引擎开始执行字节码" class="headerlink" title="四、执行引擎开始执行字节码"></a>四、执行引擎开始执行字节码</h5><p><strong>bipush 10</strong></p>
<ul>
<li>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/35.png"></p>
<p><strong>istore 1</strong></p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p>
<p>对应代码中的</p>
<pre class="language-none"><code class="language-none">a = 10</code></pre>

<p><img src="/%E5%85%B3%E4%BA%8EJVM/36.png"></p>
<p><strong>ldc #3</strong></p>
<p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数 栈中</p>
<p><strong>注意：</strong> Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/37.png"></p>
<p><strong>istore 2</strong></p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/38.png"></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/39.png"></p>
<p><strong>iload1 iload2</strong></p>
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p>
<ul>
<li>因为只能在操作数栈中执行运算操作</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/40.png"></p>
<p><strong>iadd</strong></p>
<p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/41.png"></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/42.png"></p>
<p><strong>istore 3</strong></p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/43.png"></p>
<p><strong>getstatic #4</strong></p>
<p>在运行时常量池中找到#4，发现是一个对象 在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/44.png"></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/45.png"></p>
<p><strong>iload 3</strong></p>
<p>将局部变量表中3号位置的元素压入操作数栈中</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/46.png"></p>
<p><strong>invokevirtual 5</strong></p>
<p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p>
<p>生成新的栈帧（分配 locals、stack等）</p>
<p>传递参数，执行新栈帧中的字节码</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/47.png"></p>
<p>执行完毕，弹出栈帧 清除</p>
<p>main 操作数栈内容</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/48.png"></p>
<p><strong>return</strong></p>
<p>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
<h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a><strong>通过字节码指令来分析问题</strong></h4><p>代码</p>
<pre class="language-none"><code class="language-none">public class Demo2 {
            public static void main(String[] args) {
                int i=0;
                int x=0;
                while(i&lt;10) {
                    x = x++;
                    i++;
                }
                System.out.println(x); //接过为0
            }
        }</code></pre>

<p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=3, args_size=1 //操作数栈分配2个空间，局部变量表分配3个空间
 0: iconst_0 //准备一个常数0
 1: istore_1 //将常数0放入局部变量表的1号槽位 i=0
 2: iconst_0 //准备一个常数0
 3: istore_2 //将常数0放入局部变量的2号槽位 x=0 
 4: iload_1 //将局部变量表1号槽位的数放入操作数栈中
 5: bipush 10 //将数字10放入操作数栈中，此时操作数栈中有2个数
 7: if_icmpge 21 //比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。
 10: iload_2 //将局部变量2号槽位的数放入操作数栈中，放入的值是0
 11: iinc 2, 1 //将局部变量2号槽位的数加1，自增后，槽位中的值为1
 14: istore_2 //将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0
 15: iinc 1, 1 //1号槽位的值自增1
 18: goto 4 //跳转到第4条指令
 21: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream;
 24: iload_2
 25: invokevirtual #3 // Method java/io/PrintStream.println:(I)V
 28: return</code></pre>

<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h5><p><strong>cinit()V</strong></p>
<pre class="language-none"><code class="language-none">public class Demo3 {
            static int i = 10;
            static {
                i = 20;
            }
            static {
                i = 30;
            }
            public static void main(String[] args) {
                System.out.println(i); //结果为30
            }
        }</code></pre>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法 cinit()V</p>
<pre class="language-none"><code class="language-none">stack=1, locals=0, args_size=0
 0: bipush 10
 2: putstatic #3 // Field i:I
 5: bipush 20
 7: putstatic #3 // Field i:I
 10: bipush 30
 12: putstatic #3 // Field i:I
 15: return</code></pre>

<h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a><strong>init()V</strong></h5><pre class="language-none"><code class="language-none">public class Demo4 {
            private String a = "s1";
            {
                b = 20;
            }
            private int b = 10;
            {
                a = "s2";
            }
            public Demo4(String a, int b) {
                this.a = a;
                this.b = b;
            }
            public static void main(String[] args) {
                Demo4 d = new Demo4("s3", 30);
                System.out.println(d.a);
                System.out.println(d.b);
            }
        }</code></pre>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但原始构造方法内的代码<strong>总是在后</strong></p>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=3, args_size=3
 0: aload_0
 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V
 4: aload_0
 5: ldc #2 // String s1
 7: putfield #3 // Field a:Ljava/lang/String;
 10: aload_0
 11: bipush 20
 13: putfield #4 // Field b:I
 16: aload_0
 17: bipush 10
 19: putfield #4 // Field b:I
 22: aload_0
 23: ldc #5 // String s2
 25: putfield #3 // Field a:Ljava/lang/String;
 //原始构造方法在最后执行
 28: aload_0
 29: aload_1
 30: putfield #3 // Field a:Ljava/lang/String;
 33: aload_0
 34: iload_2
 35: putfield #4 // Field b:I
 38: return</code></pre>

<h5 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a><strong>方法调用</strong></h5><pre class="language-java" data-language="java"><code class="language-java">public class Demo5 {
            public Demo5() {
            }
            private void test1() {
            }
            private final void test2() {
            }
            public void test3() {
            }
            public static void test4() {
            }
            public static void main(String[] args) {
                Demo5 demo5 = new Demo5();
                demo5.test1();
                demo5.test2();
                demo5.test3();
                Demo5.test4();
            }
        }</code></pre>

<p>不同方法在调用时，对应的虚拟机指令有所区别</p>
<ul>
<li>私有、构造、被final修饰的方法，在调用时都使用invokespecial指令</li>
<li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期 间才能确定</li>
<li>静态方法在调用时使用invokestatic指令</li>
</ul>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=2, args_size=1
 0: new #2 // class com/nyima/JVM/day5/Demo5 
 3: dup
 4: invokespecial #3 // Method "&lt;init&gt;":()V
 7: astore_1
 8: aload_1
 9: invokespecial #4 // Method test1:()V
 12: aload_1
 13: invokespecial #5 // Method test2:()V
 16: aload_1
 17: invokevirtual #6 // Method test3:()V
 20: invokestatic #7 // Method test4:()V
 23: return</code></pre>

<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li>
<li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li>
<li>终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li>
<li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态成员方法与静态方法调用的另一个区 别是，执行方法前是否需要【对象引用】</li>
</ul>
<h5 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h5><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<code>invokevirtual</code>指令</p>
<p>在执行<code>invokevirtual</code>指令时，经历了以下几个步骤</p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong>(虚拟方法表)</li>
<li>查询<code>vtable</code>找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>try-catch</p>
<pre class="language-none"><code class="language-none">public class Demo1 {
            public static void main(String[] args) {
                int i = 0;
                try {
                    i = 10;
                }catch (Exception e) {
                    i = 20;
                }
            }
        }</code></pre>

<p>对应字节码指令</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=3, args_size=1
 0: iconst_0
 1: istore_1
 2: bipush 10
 4: istore_1
 5: goto 12
 8: astore_2
 9: bipush 20
 11: istore_1
 12: return
 //多出来一个异常表
 Exception table:
 from to target type
 2 5 8 Class java/lang/Exception</code></pre>

<ul>
<li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范 围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指 示行号</li>
<li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li>
</ul>
<p><strong>多个single-catch</strong></p>
<pre class="language-none"><code class="language-none">public class Demo1 {
            public static void main(String[] args) {
                int i = 0;
                try {
                    i = 10;
                }catch (ArithmeticException e) {
                    i = 20;
                }catch (Exception e) {
                    i = 30;
                }
            }
        }</code></pre>

<p>对应的字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=3, args_size=1
 0: iconst_0
 1: istore_1
 2: bipush 10
 4: istore_1
 5: goto 19
 8: astore_2
 9: bipush 20
 11: istore_1
 12: goto 19
 15: astore_2
 16: bipush 30
 18: istore_1
 19: return
 Exception table:
 from to target type
 2 5 8 Class java/lang/ArithmeticException
 2 5 15 Class java/lang/Exception</code></pre>

<ul>
<li>因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用</li>
</ul>
<p><strong>finally</strong></p>
<pre class="language-none"><code class="language-none">public class Demo2 {
            public static void main(String[] args) {
                int i = 0;
                try {
                    i = 10;
                } catch (Exception e) {
                    i = 20;
                } finally {
                    i = 30;
                }
            }
        }</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=4, args_size=1
 0: iconst_0
 1: istore_1
 //try块
 2: bipush 10
 4: istore_1
 //try块执行完后，会执行finally 
 5: bipush 30
 7: istore_1
 8: goto 27
 //catch块 
 11: astore_2 //异常信息放入局部变量表的2号槽位
 12: bipush 20
 14: istore_1
 //catch块执行完后，会执行finally 
 15: bipush 30
 17: istore_1
 18: goto 27
 //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码 
 21: astore_3
 22: bipush 30
 24: istore_1
 25: aload_3
 26: athrow //抛出异常
 27: return
 Exception table:
 from to target type
 2 5 11 Class java/lang/Exception
 2 5 21 any
 11 15 21 any</code></pre>

<p>可以看到 finally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p>
<p><strong>注意：</strong>虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码只会被执行一次</p>
<p><strong>finally中的return</strong></p>
<pre class="language-none"><code class="language-none">public class Demo3 {
            public static void main(String[] args) {
                int i = Demo3.test();
                //结果为20
                System.out.println(i);
            }
            public static int test() {
                int i;
                try {
                    i = 10;
                    return i;
                } finally {
                    i = 20;
                    return i;
                }
            }
        }</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=3, args_size=0
 0: bipush 10
 2: istore_0
 3: iload_0
 4: istore_1 //暂存返回值
 5: bipush 20
 7: istore_0
 8: iload_0
 9: ireturn //ireturn会返回操作数栈顶的整型值20
 //如果出现异常，还是会执行finally块中的内容，没有抛出异常
 10: astore_2
 11: bipush 20
 13: istore_0
 14: iload_0
 15: ireturn //这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！
 Exception table:
 from to target type
 0 5 10 any</code></pre>

<ul>
<li><p>由于 finally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以finally的为准</p>
</li>
<li><p>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</p>
</li>
<li><p>跟上例中的 finally 相比，发现<strong>没有 athrow</strong> 了，这告诉我们：<strong>如果在 finally 中出现了 return，会吞掉异常</strong></p>
<p>所以不要在<strong>finally中进行返回操作</strong></p>
</li>
</ul>
<p><strong>被吞掉的异常</strong></p>
<pre class="language-none"><code class="language-none">public class Demo3 {
            public static void main(String[] args) {
                int i = Demo3.test();
                //最终结果为20
                System.out.println(i);
            }
            public static int test() {
                int i;
                try {
                    i = 10;
                    //这里应该会抛出异常
                    i = i/0;
                    return i;
                } finally {
                    i = 20;
                    return i;
                }
            }
        }</code></pre>

<p>会发现打印结果为20，并未抛出异常</p>
<p><strong>finally不带return</strong></p>
<pre class="language-none"><code class="language-none">public class Demo4 {
    public static void main(String[] args) {
        int i = Demo4.test();
        System.out.println(i);
    }
    public static int test() {
        int i = 10;
        try {
            return i;
        } finally {
            i = 20;
        }
    }
}</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=3, args_size=0
 0: bipush 10
 2: istore_0 //赋值给i 10
 3: iload_0 //加载到操作数栈顶
 4: istore_1 //加载到局部变量表的1号位置
 5: bipush 20
 7: istore_0 //赋值给i 20
 8: iload_1 //加载局部变量表1号位置的数10到操作数栈
 9: ireturn //返回操作数栈顶元素 10
 10: astore_2
 11: bipush 20
 13: istore_0
 14: aload_2 //加载异常
 15: athrow //抛出异常
 Exception table:
 from to target type
 3 5 10 any</code></pre>

<h5 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a><strong>Synchronized</strong></h5><pre class="language-none"><code class="language-none">public class Demo5 {
            public static void main(String[] args) {
                int i = 10;
                Lock lock = new Lock();
                synchronized (lock) {
                    System.out.println(i);
                }
            }
        }
class Lock{}</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=5, args_size=1
 0: bipush 10
 2: istore_1
 3: new #2 // class com/nyima/JVM/day06/Lock
 6: dup //复制一份，放到操作数栈顶，用于构造函数消耗
 7: invokespecial #3 // Method com/nyima/JVM/day06/Lock."&lt;init&gt;":()V
 10: astore_2 //剩下的一份放到局部变量表的2号位置
 11: aload_2 //加载到操作数栈
 12: dup //复制一份，放到操作数栈，用于加锁时消耗
 13: astore_3 //将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用
 14: monitorenter //加锁
 //锁住后代码块中的操作 
 15: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream;
 18: iload_1
 19: invokevirtual #5 // Method java/io/PrintStream.println:(I)V
 //加载局部变量表中三号槽位对象的引用，用于解锁 
 22: aload_3 
 23: monitorexit //解锁
 24: goto 34
 //异常操作 
 27: astore 4
 29: aload_3
 30: monitorexit //解锁
 31: aload 4
 33: athrow
 34: return
 //可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。 
 Exception table:
 from to target type
 15 24 27 any
 27 31 27 any</code></pre>

<h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 .java 源码编译为 .class 字节码的过程中，自动生成和转换**的一 些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p>
<p><strong>注意：</strong>以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a><strong>默认构造函数</strong></h4><pre class="language-none"><code class="language-none">public class Candy1 {
        }</code></pre>

<p>经过编译期优化后</p>
<pre class="language-none"><code class="language-none">public class Candy1 {
           //这个无参构造器是java编译器帮我们加上的
           public Candy1() {
               //即调用父类 Object 的无参构造方法，即调用 java/lang/Object." &lt;init&gt;":()V
               super();
           }
       }</code></pre>

<h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p>
<p>在JDK 5以后，它们的转换可以在编译期自动完成</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/49.png"></p>
<h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a><strong>泛型集合取值</strong></h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p>
<pre class="language-none"><code class="language-none">public class Demo3 {
            public static void main(String[] args) {
                List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                list.add(10);
                Integer x = list.get(0);
            }
        }</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=3, args_size=1
 0: new #2 // class java/util/ArrayList
 3: dup
 4: invokespecial #3 // Method java/util/ArrayList."&lt;init&gt;":()V
 7: astore_1
 8: aload_1
 9: bipush 10
 11: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
 //这里进行了泛型擦除，实际调用的是add(Objcet o)
 14: invokeinterface #5, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
 19: pop
 20: aload_1
 21: iconst_0
 //这里也进行了泛型擦除，实际调用的是get(Object o) 
 22: invokeinterface #6, 2 // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
//这里进行了类型转换，将Object转换成了Integer
 27: checkcast #7 // class java/lang/Integer
 30: astore_2
 31: return</code></pre>

<p>所以调用get函数取值时，有一个类型转换的操作</p>
<pre class="language-none"><code class="language-none">Integer x = (Integer) list.get(0);</code></pre>

<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p>
<pre class="language-none"><code class="language-none">int x = (Integer) list.get(0).intValue();</code></pre>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变参数</strong></h4><pre class="language-none"><code class="language-none">public class Demo4 {
            public static void foo(String... args) {
                //将args赋值给arr，可以看出String...实际就是String[] 
                String[] arr = args;
                System.out.println(arr.length);
            }
            public static void main(String[] args) {
                foo("hello", "world");
            }
        }</code></pre>

<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译 器会在编译期间将上述代码变换为：</p>
<pre class="language-none"><code class="language-none">public class Demo4 {
            public Demo4 {}

            public static void foo(String[] args) {
                String[] arr = args;
                System.out.println(arr.length);
            }
            public static void main(String[] args) {
                foo(new String[]{"hello", "world"});
            }
        }</code></pre>

<p>注意，如果调用的是foo()，即未传递参数时，等价代码为<code>foo(new String[]{})</code>，<strong>创建了一个空数组</strong>，而不是直接传递的null</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a><strong>foreach</strong></h4><pre class="language-none"><code class="language-none">public class Demo5 {
            public static void main(String[] args) {
                //数组赋初值的简化写法也是一种语法糖。
                int[] arr = {1, 2, 3, 4, 5};
                for(int x : arr) {
                    System.out.println(x);
                }
            }
        }</code></pre>

<p>编译器会帮我们转换为</p>
<pre class="language-none"><code class="language-none">public class Demo5 {
            public Demo5 {}
            public static void main(String[] args) {
                int[] arr = new int[]{1, 2, 3, 4, 5};
                for(int i=0; i&lt;arr.length; ++i) {
                    int x = arr[i];
                    System.out.println(x);
                }
            }
        }</code></pre>

<p>如果是集合使用foreach</p>
<pre class="language-none"><code class="language-none">public class Demo5 {
 public static void main(String[] args) {
 List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
 for (Integer x : list) {
 System.out.println(x);
 }
 }
}</code></pre>

<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>
<pre class="language-none"><code class="language-none">public class Demo5 {
            public Demo5 {}

            public static void main(String[] args) {
                List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
                //获得该集合的迭代器
                Iterator&lt;Integer&gt; iterator = list.iterator();
                while(iterator.hasNext()) {
                    Integer x = iterator.next();
                    System.out.println(x);
                }
            }
        }</code></pre>

<h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a><strong>switch字符串</strong></h4><pre class="language-none"><code class="language-none">public class Demo6 {
           public static void main(String[] args) {
               String str = "hello";
               switch (str) {
                   case "hello" :
                       System.out.println("h");
                       break;
                   case "world" :
                       System.out.println("w");
                       break;
                   default:
                       break;
               }
           }
       }</code></pre>

<p>在编译器中执行的操作</p>
<pre class="language-none"><code class="language-none">public class Demo6 {
           public Demo6() {

           }
           public static void main(String[] args) {
               String str = "hello";
               int x = -1;
               //通过字符串的hashCode+value来判断是否匹配
               switch (str.hashCode()) {
                   //hello的hashCode
                   case 99162322 :
                       //再次比较，因为字符串的hashCode有可能相等
                       if(str.equals("hello")) {
                           x = 0;
                       }
                       break;
                   //world的hashCode
                   case 11331880 :
                       if(str.equals("world")) {
                           x = 1;
                       }
                       break;
                   default:
                       break;
               }
               //用第二个switch在进行输出判断
               switch (x) {
                   case 0:
                       System.out.println("h");
                       break;
                   case 1:
                       System.out.println("w");
                       break;
                   default:
                       break;
               }
           }
       }</code></pre>

<p>过程说明：</p>
<ul>
<li>在编译期间，单个的switch被分为了两个<ul>
<li>第一个用来匹配字符串，并给x赋值<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>
</ul>
</li>
<li>第二个用来根据x的值来决定输出语句</li>
</ul>
</li>
</ul>
<h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a><strong>switch枚举</strong></h4><pre class="language-none"><code class="language-none">public class Demo7 {
           public static void main(String[] args) {
               SEX sex = SEX.MALE;
               switch (sex) {
                   case MALE:
                       System.out.println("man");
                       break;
                   case FEMALE:
                       System.out.println("woman");
                       break;
                   default:
                       break;
               }
           }
       }
       enum SEX {
           MALE, FEMALE;
       }</code></pre>

<p>编译器中执行的代码如下</p>
<pre class="language-none"><code class="language-none">public class Demo7 {
           /**
            * 定义一个合成类（仅 jvm 使用，对我们不可见） 
            * 用来映射枚举的 ordinal 与数组元素的关系 
            * 枚举的 ordinal 表示枚举对象的序号，从 0 开始 
            * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1 
            */
           static class $MAP {
               //数组大小即为枚举元素个数，里面存放了case用于比较的数字
               static int[] map = new int[2];
               static {
                   //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1
                   map[SEX.MALE.ordinal()] = 1;
                   map[SEX.FEMALE.ordinal()] = 2;
               }
           }
           public static void main(String[] args) {
               SEX sex = SEX.MALE;
               //将对应位置枚举元素的值赋给x，用于case操作
               int x = $MAP.map[sex.ordinal()];
               switch (x) {
                   case 1:
                       System.out.println("man");
                       break;
                   case 2:
                       System.out.println("woman");
                       break;
                   default:
                       break;
               }
           }
       }
       enum SEX {
           MALE, FEMALE;
       }</code></pre>

<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a><strong>枚举类</strong></h4><pre class="language-none"><code class="language-none">enum SEX {
 MALE, FEMALE;
}</code></pre>

<p>转换后的代码</p>
<pre class="language-none"><code class="language-none">public final class Sex extends Enum&lt;Sex&gt; {
           //对应枚举类中的元素
           public static final Sex MALE;
           public static final Sex FEMALE;
           private static final Sex[] $VALUES;

           static {
               //调用构造函数，传入枚举元素的值及ordinal
               MALE = new Sex("MALE", 0);
               FEMALE = new Sex("FEMALE", 1);
               $VALUES = new Sex[]{MALE, FEMALE};
           }

           //调用父类中的方法
           private Sex(String name, int ordinal) {
               super(name, ordinal);
           }

           public static Sex[] values() {
               return $VALUES.clone();
           }
           public static Sex valueOf(String name) {
               return Enum.valueOf(Sex.class, name);
           }

       }</code></pre>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><strong>匿名内部类</strong></h4><pre class="language-none"><code class="language-none">public class Demo8 {
            public static void main(String[] args) {
                Runnable runnable = new Runnable() {
                    @Override
                    public void run() {
                        System.out.println("running...");
                    }
                };
            }
        }</code></pre>

<p>转换后的代码</p>
<pre class="language-none"><code class="language-none">public class Demo8 {
           public static void main(String[] args) {
               //用额外创建的类来创建匿名内部类对象
               Runnable runnable = new Demo8$1();
           }
       }
       //创建了一个额外的类，实现了Runnable接口
       final class Demo8$1 implements Runnable {
           public Demo8$1() {}
           @Override
           public void run() {
               System.out.println("running...");
           }
       }</code></pre>

<p>如果匿名内部类中引用了<strong>局部变量</strong></p>
<pre class="language-none"><code class="language-none">public class Demo8 {
          public static void main(String[] args) {
              int x = 1;
              Runnable runnable = new Runnable() {
                  @Override
                  public void run() {
                      System.out.println(x);
                  }
              };
          }
      }</code></pre>

<p>转化后代码</p>
<pre class="language-none"><code class="language-none">public class Demo8 {
            public static void main(String[] args) {
                int x = 1;
                Runnable runnable = new Runnable() {
                    @Override
                    public void run() {
                        System.out.println(x);
                    }
                };
            }
        }
        final class Demo8$1 implements Runnable {
            //多创建了一个变量
            int val$x;
            //变为了有参构造器
            public Demo8$1(int x) {
                this.val$x = x;
            }
            @Override
            public void run() {
                System.out.println(val$x);
            }
        }</code></pre>

<h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h4><ul>
<li>将类的字节码载入<strong>方法区</strong>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 field 有：<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_fields 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li>如果这个类还有父类没有加载，<strong>先加载父类</strong></li>
<li>加载和链接可能是<strong>交替运行</strong>的</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/50.png"></p>
<ul>
<li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>_java_mirror则是保存在<strong>堆内存</strong>中</li>
<li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>
<li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取 类的各种信息</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h4><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h4><p>验证类是否符合JVM规范，安全性检查</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h4><p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li>
<li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果 static 变量是 final 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>如果 static 变量是 final 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h4><ul>
<li><strong>HSDB的使用</strong></li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p>
<p>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块（static{}块）</strong>中的语句合并产生的</p>
<p>注意：编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的 变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/51.png"></p>
<p><strong>发生时机</strong></p>
<p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p>以下情况不会初始化</p>
<ul>
<li>访问类的 static final 静态常量（基本类型和字符串）</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类对象的数组</li>
<li>类加载器的.loadClass方法</li>
<li>Class.forNamed的参数2为false时</li>
</ul>
<p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p>
<h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的“<strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong>”这个动 作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称 为“<strong>类加载器</strong>”（ClassLoader）</p>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a><strong>类与类加载器</strong></h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p>
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个 类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在 这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一 个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p>
<p>以JDK 8为例</p>
<table>
<thead>
<tr>
<th align="center"><strong>名称</strong></th>
<th align="center"><strong>加载的类</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Bootstrap ClassLoader（启动类加载器）</td>
<td align="center">JAVA_HOME/jre/lib</td>
<td align="center">无法直接访问</td>
</tr>
<tr>
<td align="center">Extension ClassLoader (拓展类加载器)</td>
<td align="center">JAVA_HOME/jre/lib/ext</td>
<td align="center">上级为Bootstrap，显示为 null</td>
</tr>
<tr>
<td align="center">Application ClassLoader (应用程序类加载器)</td>
<td align="center">classpath</td>
<td align="center">上级为Extension</td>
</tr>
<tr>
<td align="center">自定义类加载器</td>
<td align="center">自定义</td>
<td align="center">上级为Application</td>
</tr>
</tbody></table>
<h5 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a><strong>启动类加载器</strong></h5><p>可通过在控制台输入指令，使得类被启动类加器加载</p>
<h5 id="拓展类加载"><a href="#拓展类加载" class="headerlink" title="拓展类加载"></a><strong>拓展类加载</strong></h5><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载 器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
<h5 id="双亲委派模式（经典面试题）"><a href="#双亲委派模式（经典面试题）" class="headerlink" title="双亲委派模式（经典面试题）"></a><strong>双亲委派模式（经典面试题）</strong></h5><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p>
<p>loadClass源码</p>
<pre class="language-none"><code class="language-none">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException
        {
            synchronized (getClassLoadingLock(name)) {
                // 首先查找该类是否已经被该类加载器加载过了
                Class&lt;?&gt; c = findLoadedClass(name);
                //如果没有被加载过
                if (c == null) {
                    long t0 = System.nanoTime();
                    try {
                        //看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null
                        if (parent != null) {
                            c = parent.loadClass(name, false);
                        } else {
                            //看是否被启动类加载器加载过
                            c = findBootstrapClassOrNull(name);
                        }
                    } catch (ClassNotFoundException e) {
                        // ClassNotFoundException thrown if class not found
                        // from the non-null parent class loader
                        //捕获异常，但不做任何处理
                    }
                    if (c == null) {
                        //如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常
                        //然后让应用类加载器去找classpath下找该类
                        long t1 = System.nanoTime();
                        c = findClass(name);
                        // 记录时间
                        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                        sun.misc.PerfCounter.getFindClasses().increment();
                    }
                }
                if (resolve) {
                    resolveClass(c);
                }
                return c;
            }
        }</code></pre>

<p><strong>总结：</strong>先由下到上询问，后由上到下加载</p>
<h5 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h5><p><strong>使用场景</strong></p>
<ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
<li></li>
</ul>
<p><strong>步骤</strong></p>
<ul>
<li><p>继承ClassLoader父类</p>
</li>
<li><p>要遵从双亲委派机制，重写 findClass 方法</p>
<p>不是重写loadClass方法，否则不会走双亲委派机制</p>
</li>
<li><p>读取类文件的字节码</p>
</li>
<li><p>调用父类的 defineClass 方法来加载类</p>
</li>
<li><p>使用者调用该类加载器的 loadClass 方法</p>
</li>
</ul>
<p><strong>破坏双亲委派模式</strong></p>
<ul>
<li><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远 古”时代</p>
<p>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</p>
</li>
<li><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的</p>
<p>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</p>
</li>
<li><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的</p>
<p>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署 （Hot Deployment）等</p>
</li>
</ul>
<h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a><strong>分层编译</strong></h4><p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 profiling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<p>profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】 等</p>
<p><strong>即时编译器（JIT）与解释器的区别</strong></p>
<ul>
<li><strong>解释器</strong><ul>
<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码<strong>编译</strong>为机器码，并<strong>存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方 面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简 单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a><strong>逃逸分析</strong></h4><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定 是否在 Java 堆上分配内存的一项技术</p>
<p>逃逸分析的 JVM 参数如下：</p>
<ul>
<li>开启逃逸分析：<code>-XX:+DoEscapeAnalysis</code></li>
<li>关闭逃逸分析：<code>-XX:-DoEscapeAnalysis</code></li>
<li>显示分析结果：<code>-XX:+PrintEscapeAnalysis</code></li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p>
<p><strong>对象逃逸状态</strong></p>
<ul>
<li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>
<li>对象是一个静态变量</li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
<p><strong>参数逃逸（ArgEscape）</strong></p>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被 调方法的字节码确定的</li>
</ul>
<p><strong>没有逃逸</strong></p>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被 调方法的字节码确定的</li>
</ul>
<p><strong>逃逸分析优化</strong></p>
<p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化：</p>
<p><strong>1、锁消除</strong></p>
<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前 线程中用到，这样编译器就会优化移除掉这些锁操作</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>开启锁消除：<code>-XX:+EliminateLocks</code></li>
<li>关闭锁消除：<code>-XX:-EliminateLocks</code></li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p><strong>2、标量替换</strong></p>
<p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为标量，它们不能被进一步分解。而能被进一步分 解的量就是聚合量，比如：对象</p>
<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节 省了内存空间，也提升了应用程序性能</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>开启标量替换：<code>-XX:+EliminateAllocations</code></li>
<li>关闭标量替换：<code>-XX:-EliminateAllocations</code></li>
<li>显示标量替换详情：<code>-XX:+PrintEliminateAllocations</code></li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p><strong>三、栈上分配</strong></p>
<p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一 致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a><strong>方法内联</strong></h4><h5 id="1、内联函数"><a href="#1、内联函数" class="headerlink" title="1、内联函数"></a><strong>1、内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<h5 id="2、JVM内联函数"><a href="#2、JVM内联函数" class="headerlink" title="2、JVM内联函数"></a><strong>2、JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器</strong>决定。Java不支持直接声明为内联函数的，如果想让他内 联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>
<pre class="language-none"><code class="language-none">public final void doSomething() {
           // to do something 
       }</code></pre>

<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>
<p>第二个原因则更重要：<strong>方法内联</strong></p>
<p>如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身，如：</p>
<pre class="language-none"><code class="language-none">private int add4(int x1, int x2, int x3, int x4) {
       //这里调用了add2方法
           return add2(x1, x2) + add2(x3, x4);
       }
       private int add2(int x1, int x2) {
           return x1 + x2;
       }</code></pre>

<p>方法调用被替换后</p>
<pre class="language-none"><code class="language-none">private int add4(int x1, int x2, int x3, int x4) {
           //被替换为了方法本身
           return x1 + x2 + x3 + x4;
       }</code></pre>

<h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a><strong>反射优化</strong></h4><pre class="language-none"><code class="language-none">public class Reflect1 {
           public static void foo() {
               System.out.println("foo...");
           }
           public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException{
           Method foo = Demo3.class.getMethod("foo");
                for(int i = 0; i&lt;=16; i++) {
                    foo.invoke(null);
                }
           }
       }</code></pre>

<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现， invoke方法源码</p>
<pre class="language-none"><code class="language-none">@CallerSensitive
      public Object invoke(Object obj, Object... args)throws IllegalAccessException, IllegalArgumentException,
              InvocationTargetException
      {
          if (!override) {
              if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                  Class&lt;?&gt; caller = Reflection.getCallerClass();
                  checkAccess(caller, clazz, obj, modifiers);
              }
          }
          //MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类
          MethodAccessor ma = methodAccessor; // read volatile
          if (ma == null) {
              ma = acquireMethodAccessor();
          }
          return ma.invoke(obj, args);
      }</code></pre>

<p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p>
<ul>
<li><p>一开始if条件不满足，就会调用本地方法invoke0</p>
</li>
<li><p>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率</p>
<p>这时会从反射调用变为正常调用，即直接调用 Reflect1.foo()</p>
</li>
</ul>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对JVM的详细介绍了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于二叉树</title>
    <url>/2020/11/18/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="关于二叉树的种类"><a href="#关于二叉树的种类" class="headerlink" title="关于二叉树的种类:"></a>关于二叉树的种类:</h1><hr>
<h3 id="一、满二叉树"><a href="#一、满二叉树" class="headerlink" title="一、满二叉树"></a>一、满二叉树</h3><hr>
<p>满二叉树：<br>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。深度为k，有2^k-1个节点的二叉树。</p>
<h3 id="二、完全二叉树"><a href="#二、完全二叉树" class="headerlink" title="二、完全二叉树"></a>二、完全二叉树</h3><hr>
<p>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1 个节点。</p>
<p>我们可以给完全二叉树编号，这样父子之间就可以通过编号轻松求出。<br>比如我给所有节点从左到右从上到下依次从 1 开始编号。</p>
<p>那么已知一个节点的编号是 i，那么其左子节点就是 2 i，右子节点就是 2 1 + 1，父节点就是 (i + 1) / 2。</p>
<hr>
<h1 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h1><h3 id="一、序列化二叉树"><a href="#一、序列化二叉树" class="headerlink" title="一、序列化二叉树"></a>一、序列化二叉树</h3><h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><p>二叉搜索树是有数值的了，二叉搜索树是一个有序树。</p>
<p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>它的左、右子树也分别为二叉排序树</p>
<h3 id="二、平衡二叉搜索树"><a href="#二、平衡二叉搜索树" class="headerlink" title="二、平衡二叉搜索树"></a>二、平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：</p>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>对于一个二叉查找树，常规操作有插入，查找，删除，找父节点，求最大值，求最小值。</p>
<h5 id="核心：二叉搜索树的中序遍历的结果是一个有序数组"><a href="#核心：二叉搜索树的中序遍历的结果是一个有序数组" class="headerlink" title="核心：二叉搜索树的中序遍历的结果是一个有序数组"></a>核心：二叉搜索树的中序遍历的结果是一个有序数组</h5><h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><h6 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h6><h6 id="二叉搜索树迭代器"><a href="#二叉搜索树迭代器" class="headerlink" title="二叉搜索树迭代器"></a>二叉搜索树迭代器</h6><h6 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h6><h6 id="一个中心"><a href="#一个中心" class="headerlink" title="一个中心"></a>一个中心</h6><h3 id="三、树的遍历："><a href="#三、树的遍历：" class="headerlink" title="三、树的遍历："></a>三、树的遍历：</h3><p>遍历不是目的，遍历是为了更好地做处理，这里的处理包括搜索，修改树等。</p>
<p>树虽然只能从根开始访问，但是可以选择在访问完毕回来的时候做处理，</p>
<p>还是在访问回来之前做处理，这两种不同的方式就是后序遍历和先序遍历。</p>
<h5 id="其中有两个重要知识点："><a href="#其中有两个重要知识点：" class="headerlink" title="其中有两个重要知识点："></a>其中有两个重要知识点：</h5><h6 id="DFS（深度优先遍历）"><a href="#DFS（深度优先遍历）" class="headerlink" title="DFS（深度优先遍历）"></a>DFS（深度优先遍历）</h6><h6 id="BFS（宽度优先遍历）"><a href="#BFS（宽度优先遍历）" class="headerlink" title="BFS（宽度优先遍历）"></a>BFS（宽度优先遍历）</h6><h1 id="二叉树的遍历结构：就是找根节点"><a href="#二叉树的遍历结构：就是找根节点" class="headerlink" title="二叉树的遍历结构：就是找根节点"></a>二叉树的遍历结构：就是找根节点</h1><p>前序：根-左-右<br>中序：左-根-右<br>后序：左-右-根</p>
<p>举个例子：</p>
<p><img src="/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91/1.png"></p>
<p>前序就是根节点在前<br>中序就是根节点在中<br>后序就是根在后</p>
<p><img src="/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91/2.png"></p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对二叉树的详细介绍了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于SQL语言</title>
    <url>/2021/09/18/%E5%85%B3%E4%BA%8ESQL%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="关于SQL语言"><a href="#关于SQL语言" class="headerlink" title="关于SQL语言:"></a>关于SQL语言:</h1><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h3 id="字符集的由来"><a href="#字符集的由来" class="headerlink" title="字符集的由来"></a>字符集的由来</h3><ul>
<li>计算机只能识别二进制代码无论是计算机程序还是数据，最终都会转换成二进制，计算机才能认识。</li>
<li>为了计算机不只能做科学计算，也能处理文字信息。<br>人们想出了给每一个文字符号编码以便于计算识别处理的办法，这就是计算机字符集的由来。</li>
</ul>
<h3 id="ASSCII"><a href="#ASSCII" class="headerlink" title="ASSCII"></a>ASSCII</h3><ul>
<li><p>一套文字符号及其编码,比较规则 的集合。</p>
<ul>
<li>20世纪60年代初。美国标准化组织ANSI发布了第一个字符集。ASCII</li>
<li>后来又进一步变成了国际标准ISO-646</li>
</ul>
</li>
<li><p>各大字符集</p>
<ul>
<li><p>自ASCII后。为了处理不同的文字。各大计算机公司，各国，标准化政府，组织先后发明了几百种字符集。</p>
<ul>
<li>ISO-8859</li>
<li>GB2312-80</li>
<li>GBK</li>
<li>BIG5</li>
</ul>
</li>
<li><p>这些五花八门的字符集从收录的字符集到编码规则各不相同。给计算机软件开发和移值带来了很大的困难。</p>
</li>
</ul>
</li>
</ul>
<p>一个软件要在使用不同文字的国家和地区发布，必须得要做本地化开发。<br>    - 基于这个原因，要统一字符编码。</p>
<h3 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h3><ul>
<li>为了统一字符编码。国际标准化组织ISO的一些成员国于1984年发起制定了新的国际字符集标准。容纳全世界各种语言，文字，和  符号。最后产生了这个标准ISO-10646</li>
<li>ISO-10646发布后，遭到了美国计算机公司的反对。</li>
<li>1988年，Xerox公司提议制定了新的以16位编码人统一字符集。并联合了Apple,IBM,SUN，Microsoft等公司成立了Unicode技术委员会。专门负责收集，整理，和编码。于1991年推出了Unicode1.0</li>
<li>针对字符编码统一问题，ISO和Unicode协会推出了各自不同的标准。这显然是不利的。后来双方开始谈判。1991年10月达成协议。ISO将Unicode收编。起了个名BMP</li>
</ul>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><ul>
<li>ISO-10646编码空间足以容纳从古自今使用过的文字和字符。但很多文字字符已经很少用了。<br>超过99%的在用文字字符都编入了BMP.因此，绝大部分情况下，Unicode双字节方式都能满足需求。<br>而且比双字节编码方式4字节原始编码来说，更节省内存和处理时间 。这也是Unicode流行的原因。</li>
<li>万一使用了BMP以外的文字怎么办？<br>Unicode提出了UTF-16的解决办法。</li>
</ul>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><ul>
<li>虽然UTF-16解决了上面问题。但当时的计算机和网络世界还是ASCII的天下。只能处理单字节数据流。UTF-16离开了Unicode环境后。在传输和处理中，都存在问题。</li>
<li>于是又提出了UTF-8的解决文案，</li>
<li>UTF-8按一定的规则，将一个ISO10646或Unicode转换成1至4个字节的编码</li>
<li>其中ASCII转成单字节编码。也就严格兼容了ASCII字符集。</li>
<li>UTF-8的2，3，4字节用以转换ISO-10646标准的UCS-4原始码。</li>
</ul>
<h3 id="汉字的一些常见字符集"><a href="#汉字的一些常见字符集" class="headerlink" title="汉字的一些常见字符集"></a>汉字的一些常见字符集</h3><ul>
<li>GB2312</li>
<li>GB13000</li>
<li>GBK</li>
<li>GB18030</li>
</ul>
<h2 id="MySql存储引擎"><a href="#MySql存储引擎" class="headerlink" title="MySql存储引擎"></a>MySql存储引擎</h2><h3 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h3><ul>
<li>存储，管理和使用数据的不同结构形式，如：表、视图、存储过程、函数、触发器、事件等。</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>存储数据库对象的容器。</li>
</ul>
<h3 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h3><ul>
<li>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。</li>
<li>每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。</li>
<li>通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</li>
<li>不同的存储引擎性能是不一样的</li>
</ul>
<h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul>
<li>是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</li>
</ul>
<h3 id="存储引擎分类"><a href="#存储引擎分类" class="headerlink" title="存储引擎分类"></a>存储引擎分类</h3><ul>
<li><p>MYISAM</p>
<ul>
<li><p>它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。</p>
</li>
<li><p>每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：</p>
<ul>
<li>.frm(存储表定义)</li>
<li>MYD(MYData，存储数据)</li>
<li>MYI(MYIndex，存储索引)</li>
</ul>
</li>
</ul>
</li>
<li><p>INNODB</p>
<ul>
<li>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</li>
</ul>
</li>
<li><p>MEMORY</p>
<ul>
<li>memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm</li>
<li>MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。</li>
</ul>
</li>
</ul>
<h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><h3 id="SQL是Structured-Quevy-Language-结构化查询语言-的缩写。"><a href="#SQL是Structured-Quevy-Language-结构化查询语言-的缩写。" class="headerlink" title="SQL是Structured Quevy Language(结构化查询语言)的缩写。"></a>SQL是Structured Quevy Language(结构化查询语言)的缩写。</h3><h3 id="SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。"><a href="#SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。" class="headerlink" title="SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。"></a>SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。</h3><h3 id="在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。"><a href="#在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。" class="headerlink" title="在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。"></a>在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。</h3><h3 id="SQL语言功能很强，其核心功能只用了6个命令，分别是SELECT、CREATE、INSERT、DELETE、UPDATE、和GRANT-REVOKE-。"><a href="#SQL语言功能很强，其核心功能只用了6个命令，分别是SELECT、CREATE、INSERT、DELETE、UPDATE、和GRANT-REVOKE-。" class="headerlink" title="SQL语言功能很强，其核心功能只用了6个命令，分别是SELECT、CREATE、INSERT、DELETE、UPDATE、和GRANT(REVOKE)。"></a>SQL语言功能很强，其核心功能只用了6个命令，分别是SELECT、CREATE、INSERT、DELETE、UPDATE、和GRANT(REVOKE)。</h3><h2 id="sql功能分类"><a href="#sql功能分类" class="headerlink" title="sql功能分类"></a>sql功能分类</h2><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL:数据定义语言"></a>DDL:数据定义语言</h3><ul>
<li>用来定义数据库对象：创建库，表，列等。</li>
</ul>
<h3 id="DML：数据操作语言"><a href="#DML：数据操作语言" class="headerlink" title="DML：数据操作语言"></a>DML：数据操作语言</h3><ul>
<li>用来操作数据库表中的记录</li>
</ul>
<h3 id="DQL：数据查询语言"><a href="#DQL：数据查询语言" class="headerlink" title="DQL：数据查询语言"></a>DQL：数据查询语言</h3><ul>
<li>用来查询数据</li>
</ul>
<h3 id="DCL：数据控制语言"><a href="#DCL：数据控制语言" class="headerlink" title="DCL：数据控制语言"></a>DCL：数据控制语言</h3><ul>
<li>用来定义访问权限和安全级别</li>
</ul>
<h2 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h2><h3 id="MySQL中定义数据字段的类型对你数据库的优化是非常重要的。"><a href="#MySQL中定义数据字段的类型对你数据库的优化是非常重要的。" class="headerlink" title="MySQL中定义数据字段的类型对你数据库的优化是非常重要的。"></a>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。</h3><h3 id="MySQL支持所有标准SQL数值数据类型。"><a href="#MySQL支持所有标准SQL数值数据类型。" class="headerlink" title="MySQL支持所有标准SQL数值数据类型。"></a>MySQL支持所有标准SQL数值数据类型。</h3><h3 id="MySQL支持多种类型，大致可以分为三类"><a href="#MySQL支持多种类型，大致可以分为三类" class="headerlink" title="MySQL支持多种类型，大致可以分为三类"></a>MySQL支持多种类型，大致可以分为三类</h3><ul>
<li><p>数值类型</p>
</li>
<li><p>字符串类型</p>
</li>
<li><p>日期和时间类型</p>
</li>
</ul>
<h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><ul>
<li>double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；</li>
<li>char：固定长度字符串类型； char(10)  ‘abc       ‘</li>
<li>varchar：可变长度字符串类型；varchar(10) ‘abc’</li>
<li>text：字符串类型;</li>
<li>blob：二进制类型；</li>
<li>date：日期类型，格式为：yyyy-MM-dd；</li>
<li>time：时间类型，格式为：hh:mm:ss</li>
<li>datetime:日期时间类型 yyyy-MM-dd hh:mm:ss</li>
</ul>
<h3 id="在mysql中，字符串类型和日期类型都要用单引号括起来。"><a href="#在mysql中，字符串类型和日期类型都要用单引号括起来。" class="headerlink" title="在mysql中，字符串类型和日期类型都要用单引号括起来。"></a>在mysql中，字符串类型和日期类型都要用单引号括起来。</h3><p>‘Myxq’  ‘2020-01-01’</p>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul>
<li>create database 数据库名  character set utf8;</li>
</ul>
<h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><ul>
<li>alter database 数据库名 charactor set gbk;</li>
</ul>
<h3 id="显示当前数据库"><a href="#显示当前数据库" class="headerlink" title="显示当前数据库"></a>显示当前数据库</h3><ul>
<li>select  database( );</li>
</ul>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul>
<li>drop  database  数据库名；</li>
</ul>
<h3 id="创建学生表"><a href="#创建学生表" class="headerlink" title="创建学生表"></a>创建学生表</h3><h3 id="添加一列"><a href="#添加一列" class="headerlink" title="添加一列"></a>添加一列</h3><ul>
<li>ALTER TABLE 表名 ADD 列名 数据类型;</li>
</ul>
<h3 id="查看表的字段信息"><a href="#查看表的字段信息" class="headerlink" title="查看表的字段信息"></a>查看表的字段信息</h3><ul>
<li>DESC 表名;</li>
</ul>
<h3 id="修改一个表的字段类型"><a href="#修改一个表的字段类型" class="headerlink" title="修改一个表的字段类型"></a>修改一个表的字段类型</h3><ul>
<li>ALTER TABLE 表名 MODIFY 字段名  数据类型;</li>
</ul>
<h3 id="删除一列"><a href="#删除一列" class="headerlink" title="删除一列"></a>删除一列</h3><ul>
<li>ALTER TABLE 表名 DROP 字段名;</li>
</ul>
<h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><ul>
<li>RENAME TABLE 原始表名 TO  要修改的表名;</li>
</ul>
<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><ul>
<li>create table 新表名 like 参照表名；</li>
</ul>
<h3 id="查看表的创建细节"><a href="#查看表的创建细节" class="headerlink" title="查看表的创建细节"></a>查看表的创建细节</h3><ul>
<li>SHOW CREATE TABLE 表名;</li>
</ul>
<h3 id="修改表的字符集为gbk"><a href="#修改表的字符集为gbk" class="headerlink" title="修改表的字符集为gbk"></a>修改表的字符集为gbk</h3><ul>
<li>ALTER TABLE 表名 CHARACTER SET 字符集名称;</li>
</ul>
<h3 id="修改表的列名"><a href="#修改表的列名" class="headerlink" title="修改表的列名"></a>修改表的列名</h3><ul>
<li>ALTER TABLE 表名 CHANGE 原始列名 新列名 数据类型;</li>
</ul>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ul>
<li>DROP TABLE 表名;</li>
</ul>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="查询表中的所有数据"><a href="#查询表中的所有数据" class="headerlink" title="查询表中的所有数据"></a>查询表中的所有数据</h3><ul>
<li>SELECT * FROM 表名;</li>
</ul>
<h3 id="DML是对表中的数据进行增、删、改的操作"><a href="#DML是对表中的数据进行增、删、改的操作" class="headerlink" title="DML是对表中的数据进行增、删、改的操作"></a>DML是对表中的数据进行增、删、改的操作</h3><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ul>
<li><p>INSERT INTO 表名（列名1，列名2 …）VALUES  (列值1，列值2…);</p>
</li>
<li><p>注意事项</p>
<ul>
<li>列名与列值的类型、个数、顺序要一一对应。</li>
<li>值不要超出列定义的长度。</li>
<li>插入的日期和字符一样，都使用引号括起来。</li>
</ul>
</li>
<li><p>批量插入</p>
<ul>
<li>INSERT INTO 表名（列名1，列名2 …）VALUES (列值1，列值2…)，(列值1，列值2…);</li>
</ul>
</li>
</ul>
<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><ul>
<li><p>UPDATE 表名 SET 列名1=列值1，列名2=列值2 。。。 WHERE 列名=值</p>
</li>
<li><p>把所有学生的分数改为90</p>
<ul>
<li>update students set  score=90</li>
</ul>
</li>
<li><p>把姓名为张三的学生分数改为60</p>
<ul>
<li>update student set score=60 where name=’张三’;</li>
</ul>
</li>
<li><p>把姓名为李四的年龄改为20和分数改为70</p>
<ul>
<li>update student set age=20,score=70 where name=’李四’;</li>
</ul>
</li>
<li><p>把赵六的年龄在原来基础上加1岁</p>
<ul>
<li>update students set age=age+1 where name=’赵六’;</li>
</ul>
</li>
<li><p>修改数据库密码</p>
<ul>
<li>use mysql;</li>
<li>update user set password=password(‘abc’) WHERE User=’root’;</li>
<li>flush privileges;刷新MySQL的系统权限相关表</li>
<li>mysqladmin -u root -p password 12356</li>
</ul>
</li>
</ul>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li><p>DELETE FROM 表名 【WHERE 列名=值】</p>
</li>
<li><p>TRUNCATE TABLE 表名;</p>
</li>
<li><p>DELETED 与TRUNCATE的区别</p>
<ul>
<li>DELETE 删除表中的数据，表结构还在;删除后的数据可以找回</li>
<li>TRUNCATE 删除是把表直接DROP掉，然后再创建一个同样的新表。</li>
</ul>
</li>
</ul>
<p>删除的数据不能找回。执行速度比DELETE快。</p>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="查询所有列"><a href="#查询所有列" class="headerlink" title="查询所有列"></a>查询所有列</h3><ul>
<li>SELECT * FROM 表名;</li>
</ul>
<h3 id="结果集"><a href="#结果集" class="headerlink" title="结果集"></a>结果集</h3><ul>
<li><p>数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。</p>
</li>
<li><p>结果集</p>
<ul>
<li>通过查询语句查询出来的数据以表的形式展示我们称这个表为虚拟结果集。存放在内存中。</li>
<li>查询返回的结果集是一张虚拟表。</li>
</ul>
</li>
</ul>
<h3 id="查询指定列的数据"><a href="#查询指定列的数据" class="headerlink" title="查询指定列的数据"></a>查询指定列的数据</h3><ul>
<li>SELECT 列名1，列表2… FROM 表名;</li>
</ul>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul>
<li><p>条件查询就是在查询时给出WHERE子句，在WHERE子句中可以使用一些运算符及关键字：</p>
</li>
<li><p>条件查询运行符及关键字</p>
<ul>
<li><p>=（等于）、!=（不等于）、&lt;&gt;（不等于）、&lt;（小于）、&lt;=（小于等于）、&gt;（大于）、&gt;=（大于等于）；</p>
</li>
<li><p>BETWEEN…AND；值在什么范围</p>
</li>
<li><p>IN(set)；</p>
<ul>
<li>固定的范围值</li>
</ul>
</li>
<li><p>IS NULL；（为空） IS NOT NULL（不为空）   </p>
</li>
<li><p>AND；与</p>
</li>
<li><p>OR；或</p>
</li>
<li><p>NOT； 非</p>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>查询性别为男，并且年龄为20的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE gender=’男’ AND age=20;</li>
</ul>
</li>
<li><p>查询学号为1 或者 名为zs的记录</p>
<ul>
<li>SELECT * FROM students WHERE id =1 OR name=’zs’;</li>
</ul>
</li>
<li><p>查询学号为1，2，3的记录</p>
<ul>
<li>SELECT * FROM students WHERE id=’1001’ OR id=’1002’ OR 1001=’1003’;</li>
<li>SELECT * FROM students WHERE id  IN(‘1001’,’1002’,’1003’);</li>
<li>SELECT * FROM students WHERE id NOT IN (‘1001’,’1002’,’1003’);</li>
</ul>
</li>
<li><p>查询年龄为null的记录</p>
<ul>
<li>SELECT * FROM students WHERE age IS NULL;</li>
</ul>
</li>
<li><p>查询年龄在18到20之间的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE age&gt;=18 AND age&lt;=20;</li>
<li>SELECT * FROM students WHERE age BETWEEN 18 AND 20;</li>
</ul>
</li>
<li><p>查询性别非男的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE gender !=’男’;</li>
</ul>
</li>
<li><p>查询姓名不为null的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE  name IS NOT  NULL;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><ul>
<li><p>根据指定的关键进行查询</p>
</li>
<li><p>使用LIKE关键字后跟通配符</p>
</li>
<li><p>通配符</p>
<ul>
<li>_  ：任意一个字符</li>
<li>%：任意0~n个字符</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>查询姓名由5个字母构成的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE name LIKE ‘_____’;</li>
<li>模糊查询必须使用LIKE关键字。其中 “_”匹配任意一个字母，5个“_”表示5个任意字母。</li>
</ul>
</li>
<li><p>查询姓名由5个字母构成，并且第5个字母为“s”的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE name LIKE ‘____s’;</li>
</ul>
</li>
<li><p>查询姓名以“m”开头的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE name LIKE ‘m%’;</li>
<li>其中“%”匹配0~n个任何字母。</li>
</ul>
</li>
<li><p>查询姓名中第2个字母为“u”的学生记录</p>
<ul>
<li>SELECT * FROM students WHERE name LIKE ‘_u%’;</li>
</ul>
</li>
<li><p>查询姓名中包含“s”字母的学生记录</p>
<ul>
<li>SELECT * FROM stu WHERE name LIKE ‘%s%’;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字段控制查询"><a href="#字段控制查询" class="headerlink" title="字段控制查询"></a>字段控制查询</h3><ul>
<li><p>去除重复字段</p>
<ul>
<li>SELECT DISTINCT name FROM students;</li>
</ul>
</li>
<li><p>把查询字段的结果进行运算，必须都要是数据型</p>
<ul>
<li>SELECT *,字段1+字段2 FROM 表名;</li>
<li>列有很多记录的值为NULL，</li>
</ul>
</li>
</ul>
<p>因为任何东西与NULL相加结果还是NULL，所以结算结果可能会出现NULL。<br>下面使用了把NULL转换成数值0的函数IFNULL：<br>    - SELECT *,age+IFNULL(score,0) FROM students;</p>
<ul>
<li><p>对查询结果起别名</p>
<ul>
<li>在上面查询中出现列名为sx+IFNULL(yw,0)，这很不美观，现在我们给这一列给出一个别名，为total：</li>
<li>SELECT *, yw+IFNULL(sx,0) AS total FROM score;</li>
<li>省略 AS SELECT *, yw+IFNULL(sx,0)  total FROM score;</li>
</ul>
</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li><p>创建表</p>
<ul>
<li><p>CREATE TABLE <code>employee</code> (<br><code>id</code> int(11) NOT NULL,<br><code>name</code> varchar(50) DEFAULT NULL,<br><code>gender</code> varchar(1) DEFAULT NULL,<br><code>hire_date</code> date DEFAULT NULL,<br><code>salary</code> decimal(10,0) DEFAULT NULL,<br><code>performance</code> double(255,0) DEFAULT NULL,<br><code>manage</code> double(255,0) DEFAULT NULL,<br><code>department</code> varchar(255) DEFAULT NULL<br>  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1001, ‘张三’, ‘男’, ‘1991-7-25’, 2000, 200, 500, ‘营销部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1002, ‘李四’, ‘男’, ‘2017-7-5’, 4000, 500, NULL, ‘营销部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1003, ‘王五’, ‘女’, ‘2018-5-1’, 6000, 100, 5000, ‘研发部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1004, ‘赵六’, ‘男’, ‘1991-6-1’, 1000, 3000, 4000, ‘财务部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1005, ‘孙七’, ‘女’, ‘2018-3-23’, 8000, 1000, NULL, ‘研发部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1006, ‘周八’, ‘男’, ‘2010-9-8’, 5000, 500, 1000, ‘人事部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1007, ‘吴九’, ‘女’, ‘2017-7-5’, 8000, 601, NULL, ‘研发部’);</p>
</li>
<li><p>INSERT INTO <code>employee</code> VALUES (1008, ‘郑十’, ‘女’, ‘2014-4-6’, 4000, 1801, NULL, ‘人事部’);</p>
</li>
</ul>
</li>
<li><p>对查询的结果进行排序</p>
</li>
<li><p>使用关键字ORDER BY</p>
</li>
<li><p>排序类型</p>
<ul>
<li><p>升序ASC</p>
<ul>
<li>从小到大  默认</li>
</ul>
</li>
<li><p>降序DESC</p>
<ul>
<li>从大到小</li>
</ul>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>对所有员工的薪水进行排序</p>
<ul>
<li>SELECT *FROM employee ORDER BY salary ASC;</li>
</ul>
</li>
<li><p>查询所有员工记录，按年龄降序排序</p>
<ul>
<li>SELECT * FROM employee ORDER BY salary DESC;</li>
</ul>
</li>
<li><p>查询所有雇员，按月薪降序排序，如果月薪相同时，按编号升序排序</p>
<ul>
<li>SELECT * FROM employee ORDER BY salary DESC, id ASC;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul>
<li><p>对查询的结果进行统计计算</p>
</li>
<li><p>常用聚合函数</p>
<ul>
<li>COUNT()：统计指定列不为NULL的记录行数；</li>
<li>MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</li>
<li>MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</li>
<li>SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</li>
<li>AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>COUNT</p>
<ul>
<li><p>查询employee表中记录数：</p>
<ul>
<li>SELECT COUNT(*) AS total_record FROM employee;</li>
</ul>
</li>
<li><p>查询员工表中有绩效的人数</p>
<ul>
<li>SELECT COUNT(performance)  FROM employee;</li>
</ul>
</li>
<li><p>查询员工表中月薪大于2500的人数：</p>
<ul>
<li>SELECT COUNT(*) FROM employee WHERE salary &gt; 2500;</li>
</ul>
</li>
<li><p>统计月薪与管理费之和大于5000元的人数：</p>
<ul>
<li>SELECT COUNT(*)  FROM employee WHERE salary+IFNULL(manage,0) &gt; 5000;</li>
</ul>
</li>
<li><p>查询有绩效的人数，和有管理费的人数：</p>
<ul>
<li>SELECT COUNT(performance), COUNT(manage) FROM employee;</li>
</ul>
</li>
</ul>
</li>
<li><p>SUM和AVG</p>
<ul>
<li><p>查询所有雇员月薪和：</p>
<ul>
<li>SELECT SUM(salary) FROM employee;</li>
</ul>
</li>
<li><p>查询所有雇员月薪和，以及所有雇员绩效和</p>
<ul>
<li>SELECT SUM(salary), SUM(performance) FROM employee;</li>
</ul>
</li>
<li><p>查询所有雇员月薪+绩效和：</p>
<ul>
<li>SELECT SUM(salary+IFNULL(performance,0)) FROM employee;</li>
</ul>
</li>
<li><p>统计所有员工平均工资：</p>
<ul>
<li>SELECT AVG(salary) FROM employee;</li>
</ul>
</li>
</ul>
</li>
<li><p>MAX和MIN</p>
<ul>
<li><p>查询最高工资和最低工资：</p>
<ul>
<li>SELECT MAX(salary), MIN(salary) FROM employee;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对sql语句使用的详细操作说明了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数据库</title>
    <url>/2021/03/18/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="关于数据库"><a href="#关于数据库" class="headerlink" title="关于数据库:"></a>关于数据库:</h1><h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><h3 id="数据库管理系统DBMS"><a href="#数据库管理系统DBMS" class="headerlink" title="数据库管理系统DBMS"></a>数据库管理系统DBMS</h3><ul>
<li>是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。<br>它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。<br>用户通过DBMS访问数据库中的数据，数据库管理员也通过dbms进行数据库的维护工作。<br>数据库管理系统是数据库系统的核心，是管理数据库的软件。<br>我们一般说的数据库,就是指的DBMS: 数据库管理系统</li>
</ul>
<h3 id="常见的数据库"><a href="#常见的数据库" class="headerlink" title="常见的数据库"></a>常见的数据库</h3><ul>
<li><p>Oracle</p>
<ul>
<li>运行稳定，可移植性高，功能齐全，性能超群！适用于大型企业领域。</li>
</ul>
</li>
<li><p>DB2</p>
<ul>
<li>速度快、可靠性好，适于海量数据，恢复性极强。适用于大中型企业领域。</li>
</ul>
</li>
<li><p>MySQL</p>
<ul>
<li>开源，跨平台、体积小，速度快。适用于于中小型企业领域。</li>
</ul>
</li>
<li><p>SQL Server</p>
<ul>
<li>全面，效率高，界面友好，操作容易，但是不跨平台。适用于于中小型企业领域。</li>
</ul>
</li>
</ul>
<h3 id="结构化查询语言SQL"><a href="#结构化查询语言SQL" class="headerlink" title="结构化查询语言SQL"></a>结构化查询语言SQL</h3><ul>
<li>SQL语言的功能包括查询、操纵、定义和控制，是一个综合的、通用的关系数据库语言，同时又是一种高度非过程化的语言，只要求用户指出做什么而不需要指出怎么做。</li>
</ul>
<h3 id="非关系型数据库NoSql"><a href="#非关系型数据库NoSql" class="headerlink" title="非关系型数据库NoSql"></a>非关系型数据库NoSql</h3><ul>
<li>MongoDB,Redis,HBase…</li>
</ul>
<h2 id="RDBMS专业术语"><a href="#RDBMS专业术语" class="headerlink" title="RDBMS专业术语"></a>RDBMS专业术语</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul>
<li>具有固定的列数,和任意的行数</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>数据库是一些关联表的集合</li>
</ul>
<h3 id="列"><a href="#列" class="headerlink" title="列"></a>列</h3><ul>
<li>一个数据项 Field   字段</li>
</ul>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><ul>
<li>一条记录  row</li>
</ul>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><ul>
<li>主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
</ul>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><ul>
<li>外键用于关联两个表</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
</ul>
<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><h3 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h3><ul>
<li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</li>
<li>MySQL是开源的，所以你不需要支付额外的费用。</li>
<li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>MySQL使用标准的SQL数据语言形式。</li>
<li>MySQL可以安装在多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。</li>
</ul>
<h3 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h3><ul>
<li>windows安装</li>
<li>Mac安装</li>
</ul>
<h3 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h3><ul>
<li><p>什么是存储引擎</p>
<ul>
<li>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</li>
<li>不同的存储引擎性能是不一样的</li>
</ul>
</li>
<li><p>什么是事务</p>
<ul>
<li>是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</li>
</ul>
</li>
<li><p>存储引擎分类</p>
<ul>
<li><p>MYISAM</p>
<ul>
<li><p>它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。</p>
</li>
<li><p>每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：</p>
<ul>
<li>.frm(存储表定义)</li>
<li>MYD(MYData，存储数据)</li>
<li>MYI(MYIndex，存储索引)</li>
</ul>
</li>
</ul>
</li>
<li><p>INNODB</p>
<ul>
<li>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</li>
</ul>
</li>
<li><p>MEMORY</p>
<ul>
<li>memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm</li>
<li>MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用数据库命令"><a href="#常用数据库命令" class="headerlink" title="常用数据库命令"></a>常用数据库命令</h2><h3 id="MySQL数据库分为两种"><a href="#MySQL数据库分为两种" class="headerlink" title="MySQL数据库分为两种"></a>MySQL数据库分为两种</h3><h4 id="一、系统数据库-数据库服务器自带的-自带的4个"><a href="#一、系统数据库-数据库服务器自带的-自带的4个" class="headerlink" title="一、系统数据库(数据库服务器自带的,自带的4个)"></a>一、系统数据库(数据库服务器自带的,自带的4个)</h4><ul>
<li><p>information_schema</p>
<ul>
<li>存储数据库对象信息</li>
</ul>
</li>
</ul>
<p>如用户表信息,列信息,根除,字符,分区<br>里面的内容我们不能动.</p>
<ul>
<li><p>performance_schema</p>
<ul>
<li>存储数据库服务器性能参数信息</li>
</ul>
</li>
<li><p>MySQL</p>
<ul>
<li>存储数据库用户权限信息</li>
</ul>
</li>
<li><p>test</p>
<ul>
<li>一个空的数据库，用户可以使用它也可以不使用它</li>
</ul>
</li>
</ul>
<h4 id="二、用户数据库"><a href="#二、用户数据库" class="headerlink" title="二、用户数据库"></a>二、用户数据库</h4><ul>
<li>用户自己创建的数据库,一个项目用一个数据库</li>
</ul>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul>
<li>create database 数据库名称;</li>
</ul>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul>
<li>drop database 数据库名称;</li>
</ul>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><ul>
<li>show databases;</li>
</ul>
<h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><ul>
<li>use 数据库名;</li>
</ul>
<h3 id="查看数据库当中有多少张表"><a href="#查看数据库当中有多少张表" class="headerlink" title="查看数据库当中有多少张表"></a>查看数据库当中有多少张表</h3><ul>
<li>show  tables;</li>
</ul>
<p><strong>请注意”写的顺序,先使用数据库,再去查有多少张表”</strong></p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对MySQL数据库的详细介绍了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>前端网页开发工具之Typora使用教程</title>
    <url>/2020/12/18/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BTypora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Typora开发工具安装教程"><a href="#Typora开发工具安装教程" class="headerlink" title="Typora开发工具安装教程:"></a>Typora开发工具安装教程:</h1><h1 id="一、Markdown与Typora介绍"><a href="#一、Markdown与Typora介绍" class="headerlink" title="一、Markdown与Typora介绍"></a>一、Markdown与Typora介绍</h1><h2 id="1-1-Markdown介绍"><a href="#1-1-Markdown介绍" class="headerlink" title="1.1 Markdown介绍"></a>1.1 Markdown介绍</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 .md, .markdown。</p>
<h2 id="1-2-Typora介绍与下载"><a href="#1-2-Typora介绍与下载" class="headerlink" title="1.2 Typora介绍与下载"></a>1.2 Typora介绍与下载</h2><p>Typora编辑器让人们能更简单地用Markdown语言书写文字，解决了使用传统的Markdown编辑器写文的痛点，并且界面简洁优美，实现了实时预览等功能。</p>
<p>Typora官网： <a href="https://typora.io/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8E%BB%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E4%B8%8B%E8%BD%BD%E4%B8%AD%E6%96%87%E7%A0%B4%E8%A7%A3%E7%89%88%EF%BC%8C%E5%96%84%E7%94%A8%E6%90%9C%E7%B4%A2">https://typora.io/，可以去吾爱破解下载中文破解版，善用搜索</a></p>
<p>windos版本下载地址：<a href="https://typora.io/#windows">https://typora.io/#windows</a></p>
<p>请根据自己的电脑配置自行下载安装，过程简单，在此不多做介绍。</p>
<h1 id="二、Markdown语法"><a href="#二、Markdown语法" class="headerlink" title="二、Markdown语法"></a>二、Markdown语法</h1><h2 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h2><p>使用 # 可以表示标题，一级标题对应一个 # ，二级标题对应两个 # 号，最多至六级标题。在Typora中，# 后要紧接着一个空格才能表示标题，否则就是普通字符。</p>
<p>在Typora中，也可以使用快捷键Ctrl+1（2，3，4，5，6）表示相对应的标题。Ctrl+0表示段落。标题快捷键信息可在菜单栏中的段落选项下查看。</p>
<h2 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h2><p>用一对星号<em>括住的文本表示斜体文本，如：</em>要变斜体的文本*，斜体文本 ；<br>也可以用一对下划线_括住文本来表示斜体文本，如：_要变斜体的文本_，斜体文本 ；<br>也可以使用Typora的快捷键Ctrl+I来表示斜体文本。</p>
<p>用一对<strong>括住的文本表示粗体文本，如：</strong>要变粗体的文本**，粗体文本；<br>也可以用一对__括住的文本来表示粗体文本，如：__要变粗体的文本__，粗体文本；<br>也可以使用Typora的快捷键Ctrl+B来表示粗体文本。</p>
<p>用一对<em><strong>括住的文本表示粗斜体文本，如：</strong></em>要变粗斜体的文本***，粗斜体文本；<br>也可以用一对___括住的文本来表示粗斜体文本，如：___要变粗斜体的文本___，粗斜体文本；</p>
<h2 id="2-3-各种线"><a href="#2-3-各种线" class="headerlink" title="2.3 各种线"></a>2.3 各种线</h2><p>分割线，可以使用三个及以上的 + 号或 * 号或 - 来表示一条分割线；<br>由三个*号表示的分割线：</p>
<p>由三个+号表示的分割线：</p>
<p>+++(可能不代表分割线）</p>
<p>由三个-号表示的分割线：</p>
<p>删除线，可以使用一对<del>括住的文本来表示删除文本，如：</del>要加删除线的文本~~，删除文本；在Typora中，也可以使用快捷键Alt+Shift+5来加删除线，语法相同，删除线。<br>下划线，可以使用HTML的标签<u>和</u>表示增加下划线的文本，如：<u>要增加下划线的文本</u>，下划线；在Typora中，也可以使用快捷键Ctrl+U来增加下划线，语法也是相同的，下划线。</p>
<h2 id="2-4-列表"><a href="#2-4-列表" class="headerlink" title="2.4 列表"></a>2.4 列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>可以使用*，+或-标记符号来表示无序列表项，记住要在标记符号后添加一个空格，显示如下：</p>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>可以使用数字加上.再加上空格来表示有序列表</p>
<p>结果如下：</p>
<p>第一项<br>第二项<br>第三项<br>从结果可以看出，数字并不重要。</p>
<h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>一<br>1.1<br>1.1.1<br>1.1.1.2<br>1.1.1.3<br>二<br>2.1<br>2.1.1<br>有序列表第一项<br>有序列表第二项<br>首先使用*、+或-进入列表，然后回车换行，会发现系统自动生成列表第二项，此时按下Tab键，列表第二项变为第一项的子列表。按回车退出当前列表。可以在无序列表中嵌套有序列表。</p>
<p>一<br>一、一<br>一、一、一<br>一、一、一、一<br>一、一、一、二<br>二<br>二、一<br>无序列表第一项<br>无序列表第二项<br>也可以在有序列表中嵌套无序列表。</p>
<h2 id="2-5-区块"><a href="#2-5-区块" class="headerlink" title="2.5 区块"></a>2.5 区块</h2><p>当我们想要引用别人的文章内容时，可以将其放在区块内。</p>
<p>可以使用&gt;加空格来表示区块。</p>
<p>这是区块</p>
<p>区块也可以嵌套</p>
<p>二级区块</p>
<p>三级区块</p>
<p>要退出区块，同样使用Enter键即可。</p>
<h2 id="2-6-代码"><a href="#2-6-代码" class="headerlink" title="2.6 代码"></a>2.6 代码</h2><p>如果是一行代码，可以使用段内代码块来表示，用一对 `（数字1旁边的符号）括住代码。</p>
<p>比如printf(“Hello World!”)</p>
<p>如果是代码段，那么可以使用三个 ` 加Enter/空格+编程语言来表示。如：</p>
<p>include &lt;stdio.h&gt;</p>
<p>void main(){<br>    printf(“Hello world!\n”);<br>}</p>
<p>可以在代码块的右下角选择编程语言。</p>
<h2 id="2-7-链接"><a href="#2-7-链接" class="headerlink" title="2.7 链接"></a>2.7 链接</h2><p>链接的使用方式有两种语法，如下：</p>
<p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接文字</a><br>或<br>&lt;链接地址&gt;</p>
<p>我们可以使用链接打开网页，示例如下：</p>
<p><a href="https://www.baidu.com/">百度</a><br><a href="https://www.baidu.com/">https://www.baidu.com/</a><br>显示效果如下：</p>
<p>百度<br><a href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<p>当鼠标移到相应的链接文字时，按住Ctrl+鼠标左键点击访问。</p>
<p>链接除了可以打开相应的网页外，还可以打开本地文件，使用方式类似，不过链接地址需要使用本地文件的地址，相对地址、绝对地址均可：</p>
<p>示例：</p>
<p><a href="./LinkTest.md">打开LinkTest.md文档</a><br><a href="./img/LinkTest.png">打开LinkTest.png照片</a><br>1<br>2<br>结果如下：</p>
<p>打开LinkTest.md文档</p>
<p>打开LinkTest.png照片</p>
<p>经测试可以打开相应的文件。但是不能使用&lt;要打开的文件地址&gt;来打开相应的文件，比如&lt;./LinkTest.md&gt;并没有表现为可链接状态。</p>
<p>补充知识：</p>
<p>一个小圆点.表示当前目录，故./LinkTest.md表示当前目录下的LinkTest.md文件，./img/LinkTest.png表示当前目录下的img文件下的LinkTest.png文件。</p>
<p>两个小圆点..表示上一级目录。</p>
<p>我们也可以使用链接来实现页内跳转，语法为：</p>
<p><a href="#%E6%A0%87%E9%A2%98%E6%96%87%E5%AD%97">链接文字</a><br>1<br>示例：</p>
<p>[跳转到第一章第一节](#1.1 Markdown介绍)<br>1<br>结果如下：<br>[跳转到第一章第一节](#1.1 Markdown介绍)</p>
<p>经测试，可以成功跳转。</p>
<h2 id="2-8-图片"><a href="#2-8-图片" class="headerlink" title="2.8 图片"></a>2.8 图片</h2><p>我们也可以在Markdown文档中插入图片，语法如下：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"></p>
<p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"></p>
<p>首先一个感叹号<br>然后中括号里面写属性文本<br>小括号里面写图片地址，后可接标题</p>
<p>示例语法：</p>
<p><img src="/./img/PictureTest.png" alt="本地png图片PictureTest.png"></p>
<p><img src="/./img/PictureTest.jpg" alt="本地jpg图片"></p>
<p>结果如下：</p>
<p><img src="http://static.runoob.com/images/runoob-logo.png" alt="网络图片" title="菜鸟教程"></p>
<p>在Typora中，也可以直接使用Ctrl+C，Ctrl+V来直接进行复制粘贴图片，但是，由于Markdown是需要图片的地址的，所以需要简单设置一下Typora。</p>
<p>点击文件 –&gt; 偏好设置 –&gt; 图像，如下：</p>
<p>可以自行设置选择将图片复制到哪个文件夹。</p>
<p>这里选择复制到指定路径，然后在下面一栏中填写./img，表示将图片复制到你正在编辑的文档同一级的img文件夹下。在下面的选项中，勾选第一、二、三项。正因为勾选了第二项，所以当我们在插入网络图片时，Typora会自动帮我们将网络图片下载到指定的路径下，前面的”菜鸟教程”图片便是如此。</p>
<p>由于Markdown的特殊语法，故经常会出现图片加载失败的情况，很大的可能就是因为在指定的路径上找不到相应的图片，当然，有时候也是由于Typora的原因，重启Typora即可。</p>
<h2 id="2-9-表格"><a href="#2-9-表格" class="headerlink" title="2.9 表格"></a>2.9 表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p>
<p>结果如下：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<p>我们可以设置对齐方式：</p>
<p>:-表示左对齐<br>-:表示右对齐<br>:-:表示中间对齐<br>示例如下：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">中间对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<p>在Typora中，我们可以使用快捷键Ctrl+T来插入表格，并选择行列，当选中表格某一单元格时，可以在表格左上角手动设置对齐方式，右上角选择更多操作。</p>
<h1 id="三、Typora与数学公式"><a href="#三、Typora与数学公式" class="headerlink" title="三、Typora与数学公式"></a>三、Typora与数学公式</h1><p>在本章中，重点不在于介绍如何插入数学公式，而在于如何表示数学符号。</p>
<h3 id="3-1-如何插入数学公式"><a href="#3-1-如何插入数学公式" class="headerlink" title="3.1 如何插入数学公式"></a>3.1 如何插入数学公式</h3><p>在Typora中，有两种方法插入数学公式，语法为：</p>
<p>第一种方法：$数学公式$<br>第二种方法：<br>$$<br>数学公式<br>$$<br>1<br>2<br>3<br>4<br>5<br>第一种方法表示插入行内公式（内联公式），即可以将公式插入到一行中，比如1 + 2 = 3 1+2=31+2=3这样的公式。</p>
<p>第二种方法表示插入行间公式（外联公式），即可以将公式插入到行与行之间，单独占据一行或者数行的空间，并且居中放置。<br>1 + 2 = 3 1+2=3<br>1+2=3</p>
<p>如果要在行间公式内换行，在换行的位置使用\。</p>
<p>接下来重点介绍如何表示数学符号。</p>
<h3 id="3-2-上标下标"><a href="#3-2-上标下标" class="headerlink" title="3.2 上标下标"></a>3.2 上标下标</h3><p>上下标可以使用^，_后跟相应的符号来实现。如：</p>
<p>上 标 ： a 1 ， 下 标 ： a 1 上标：a^1，下标：a_1上标：a<br>1<br> ，下标：a<br>1</p>
<p>如果作为上标、下标的符号不止一个，则需要用花括号{}将其括起来。如：</p>
<p>上 标 为 12 ： a 12 , 下 标 为 34 ： a 34 上标为12：a^{12},下标为34：a_{34}上标为12：a<br>12<br> ,下标为34：a<br>34</p>
<p>更多例子：<br>f ( x ) = x x x e x 2 e x 2 f(x)=x^{x^x}\ e^{x2}\ e^{x^2}\<br>f(x)=x<br>x<br>x</p>
<p>e<br>x2</p>
<p>e<br>x<br>2</p>
<h3 id="3-3-根号"><a href="#3-3-根号" class="headerlink" title="3.3 根号"></a>3.3 根号</h3><p>我们可以使用\sqrt{}来表示根号。如：</p>
<p>\sqrt{2},\sqrt{5}<br>1<br>结果为：</p>
<p>2 , 5 \sqrt{2},\sqrt{5}<br>2</p>
<p> ,<br>5</p>
<p>我们也可以使用\sqrt[]{}来表示更具体的根号信息：</p>
<p>\sqrt[3]{4}，\sqrt[4]{10}<br>1<br>4 3 ， 10 4 \sqrt[3]{4}，\sqrt[4]{10}<br>3</p>
<p>4</p>
<p> ，<br>4</p>
<p>10</p>
<h3 id="3-4-上下水平线"><a href="#3-4-上下水平线" class="headerlink" title="3.4 上下水平线"></a>3.4 上下水平线</h3><p>我们可以使用\underline{},\overline{}来表示上下水平线，如：</p>
<p>$下水平线：\underline{a+b}$<br>$上水平线：\overline{a+b}$<br>1<br>2<br>结果为：</p>
<p>下 水 平 线 ： a + b ‾ 下水平线：\underline{a+b}下水平线：<br>a+b</p>
<p>上 水 平 线 ： a + b ‾ 上水平线：\overline{a+b}上水平线：<br>a+b</p>
<h3 id="3-5-上下水平大括号"><a href="#3-5-上下水平大括号" class="headerlink" title="3.5 上下水平大括号"></a>3.5 上下水平大括号</h3><p>我们可以使用\overbrace{} 和 \underbrace{} 在表达式的上、下方给出一水平的大括号</p>
<p>$\overbrace{x_1+x_2+x_3}$<br>$\underbrace{x_1+x_2+x_3}$<br>1<br>2<br>结果为：</p>
<p>x 1 + x 2 + x 3 ⏞ \overbrace{x_1+x_2+x_3}<br>x<br>1</p>
<p> +x<br>2</p>
<p> +x<br>3</p>
<p>x 1 + x 2 + x 3 ⏟ \underbrace{x_1+x_2+x_3}<br>x<br>1</p>
<p> +x<br>2</p>
<p> +x<br>3</p>
<p>当然，我们也可以在括号上添加说明，使用语法为\overbrace{}^{}和\underbrace{}_{}</p>
<p>$\overbrace{x_1+x_2+x_3}^{3个元素}$<br>$\underbrace{x_1+x_2+x_3}_{3个元素}$<br>1<br>2<br>x 1 + x 2 + x 3 ⏞ 3 个 元 素 \overbrace{x_1+x_2+x_3}^{3个元素}<br>x<br>1</p>
<p> +x<br>2</p>
<p> +x<br>3</p>
<p>3个元素</p>
<p>x 1 + x 2 + x 3 ⏟ 3 个 元 素 \underbrace{x_1+x_2+x_3}_{3个元素}<br>3个元素<br>x<br>1</p>
<p> +x<br>2</p>
<p> +x<br>3</p>
<h3 id="3-6-向量符号"><a href="#3-6-向量符号" class="headerlink" title="3.6 向量符号"></a>3.6 向量符号</h3><p>我们可以使用\vec{}来表示单个字母向量，其实也可以表示多个字母，但不美观，另两个命令\overrightarrow{} 和\overleftarrow{}在定义从A 到B 的向量时非常有用。如：</p>
<p>$\vec{a}$<br>$\vec{AB}$<br>$\vec{ABC}$<br>$\overrightarrow{AB}$<br>$\overleftarrow{AB}$<br>1<br>2<br>3<br>4<br>5<br>结果为：</p>
<p>a ⃗ \vec{a}<br>a</p>
<p>A B ⃗ \vec{AB}<br>AB</p>
<p>A B C ⃗ \vec{ABC}<br>ABC</p>
<p>A B → \overrightarrow{AB}<br>AB</p>
<p>A B ← \overleftarrow{AB}<br>AB</p>
<h3 id="3-7-分数"><a href="#3-7-分数" class="headerlink" title="3.7 分数"></a>3.7 分数</h3><p>我们可以使用\frac{}{}来表示分数，如：</p>
<p>$\frac{1}{2}$<br>$\frac{\sqrt{3}}{4}$<br>1<br>2<br>结果为：</p>
<p>1 2 \frac{1}{2}<br>2<br>1</p>
<p>3 4 \frac{\sqrt{3}}{4}<br>4<br>3</p>
<h3 id="3-8-积分运算符"><a href="#3-8-积分运算符" class="headerlink" title="3.8 积分运算符"></a>3.8 积分运算符</h3><p>积分运算符用\int 来生成 ，用\int_{}^{}来表示积分上下界，如：</p>
<p>$\int$<br>$\int_{1}^{2}$<br>1<br>2<br>结果为：</p>
<p>∫ \int∫<br>∫ 1 2 \int_{1}^{2}∫<br>1<br>2</p>
<h3 id="3-9-求和运算符"><a href="#3-9-求和运算符" class="headerlink" title="3.9 求和运算符"></a>3.9 求和运算符</h3><p>求和运算符可以使用\sum来生成，用\sum_{}^{}来表示求和上下界，如：</p>
<p>$\sum$<br>$\sum_{i=1}^{10}x_i$<br>1<br>2<br>结果为：</p>
<p>∑ \sum∑<br>∑ i = 1 10 x i \sum_{i=1}^{10}x_i∑<br>i=1<br>10</p>
<p> x<br>i</p>
<p>求和符号的上下标在内联公式里，表现为上面那样，当在外联公式里时，表现如下：<br>∑ i = 1 10 x i \sum_{i=1}^{10}x_i<br>i=1<br>∑<br>10</p>
<p> x<br>i</p>
<h3 id="3-10-连乘运算符"><a href="#3-10-连乘运算符" class="headerlink" title="3.10 连乘运算符"></a>3.10 连乘运算符</h3><p>连乘运算符用\prod{}表示，同样地，上下标用prod_{}^{}表示，如：</p>
<p>$\prod$<br>$\prod_{i=1}^{10}x_i$<br>$$<br>\prod_{i=1}^{10}x_i<br>$$<br>1<br>2<br>3<br>4<br>5<br>结果为：</p>
<p>∏ \prod∏<br>∏ i = 1 10 x i \prod_{i=1}^{10}x_i∏<br>i=1<br>10</p>
<p> x<br>i</p>
<p>∏ i = 1 10 x i \prod_{i=1}^{10}x_i<br>i=1<br>∏<br>10</p>
<p> x<br>i</p>
<h3 id="3-11-特殊符号"><a href="#3-11-特殊符号" class="headerlink" title="3.11 特殊符号"></a>3.11 特殊符号</h3><p>希腊字母</p>
<p>α \alphaα为\alpha，β \betaβ为\beta，γ \gammaγ为\gamma，θ \thetaθ为\theta，ρ \rhoρ为\rho，λ \lambdaλ为\lambda，μ \muμ为\mu</p>
<p>Δ \DeltaΔ为\Delta，π \piπ为\pi，Ω \OmegaΩ为\Omega</p>
<p>关系运算符</p>
<p>大于&gt;，大于等于≥ \geq≥为\geq或\ge</p>
<p>小于&lt;，小于等于≤ \leq≤为\leq或\le</p>
<p>等于=，不等于≠ \neq<br></p>
<p> =为\neq或\ne</p>
<p>加减乘除</p>
<p>加+ 减-</p>
<p>乘× \times×为\times 除÷ \div÷为\div</p>
<h3 id="3-12-矩阵表示"><a href="#3-12-矩阵表示" class="headerlink" title="3.12 矩阵表示"></a>3.12 矩阵表示</h3><p>我们可以使用以下格式来显示矩阵：<br>$$<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\<br>4 &amp; 5 &amp; 6\<br>\end{matrix}<br>$$<br>1<br>2<br>3<br>4<br>5<br>6<br>结果为：<br>1 2 3 4 5 6<br>142536<br>123456<br>1<br>4</p>
<p>2<br>5</p>
<p>3<br>6</p>
<p>可是这并不是我们常见的矩阵啊，旁边的中括号呢？</p>
<p>别急，我们先把上面的公式说明一下：</p>
<p>\begin{matrix}和\end{matrix}说明在它们之间的是矩阵</p>
<p>1 &amp; 2 &amp; 3\表示第一行的元素，其中用&amp;来分割每一个元素，用\来换行</p>
<p>现在我们来加括号，很简单，语法如下：</p>
<p>$$<br>\left[\begin{matrix}<br>1 &amp; 2 &amp; 3\<br>4 &amp; 5 &amp; 6<br>\end{matrix}\right]<br>$$<br>1<br>2<br>3<br>4<br>5<br>6<br>结果为：<br>[ 1 2 3 4 5 6 ] \left[<br>142536<br>123456<br>\right]<br>[<br>1<br>4</p>
<p>2<br>5</p>
<p>3<br>6</p>
<p> ]</p>
<p>其实我们仅仅在\begin{matrix}前面加了\left[，在\end{matrix}后面加了\right]，这样就能正确显示括号了，那我们可以将[]改为||吗，当然可以，就简单地把\left[，\right]改为\left|和\right|即可。</p>
<p>$$<br>\left|\begin{matrix}<br>1 &amp; 2 &amp; 3\<br>4 &amp; 5 &amp; 6<br>\end{matrix}\right|<br>$$<br>1<br>2<br>3<br>4<br>5<br>6<br>结果就能显示为行列式了。<br>∣ 1 2 3 4 5 6 ∣ \left|<br>142536<br>123456<br>\right|<br>∣<br>∣<br>∣<br>∣</p>
<p>1<br>4</p>
<p>2<br>5</p>
<p>3<br>6</p>
<p>∣<br>∣<br>∣<br>∣</p>
<p>这里仅仅介绍简单的矩阵表示，如果要了解更多矩阵表示法，请自行搜索了解，网上的资料很多。</p>
<h3 id="3-13-方程组"><a href="#3-13-方程组" class="headerlink" title="3.13 方程组"></a>3.13 方程组</h3><p>$$<br>\begin{equation}<br>\left{<br>             \begin{array}{lr}<br>             x=\dfrac{3\pi}{2}(1+2t)\cos(\dfrac{3\pi}{2}(1+2t)), &amp;  \<br>             y=s, &amp; 0\leq s\leq L,|t|\leq1.\<br>             z=\dfrac{3\pi}{2}(1+2t)\sin(\dfrac{3\pi}{2}(1+2t)), &amp;<br>             \end{array}<br>\right.<br>\end{equation}<br>$$</p>
<p>结果如下：<br>KaTeX parse error: No such environment: equation at position 8: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲}̲ \left{ …</p>
<p>现在我们一一来解释：</p>
<p>begin{equation}与\end{euqation}表示它们之间的为方程组。</p>
<p>\left{和\right.表示在方程组的左边加上{，在右边加上.，因为{在外联公式中有特殊的意义，因此需要在其前面加上转义字符\。</p>
<p>\begin{array}和\end{array}表示它们之间的是数组，其实这也可以用来表示矩阵。</p>
<p>{lr}表示有两列，第一列的值靠左排列，用l表示，第二列的值靠右排列，用r表示，如果是中间对齐则为c。</p>
<p>然后下面三行是方程式，用&amp;分割，用\换行。</p>
<h3 id="3-14-分段函数"><a href="#3-14-分段函数" class="headerlink" title="3.14 分段函数"></a>3.14 分段函数</h3><p>其实分段函数与方程组类似，示例如下：<br>$$<br>y=<br>\begin{equation}<br>    \left{<br>        \begin{array}{lr}<br>        x-1 &amp; x \leq 0<br>        x+1 &amp; x&gt;0<br>        \end{array}<br>    \right.<br>\end{equation}<br>$$</p>
<p>结果如下：<br>KaTeX parse error: No such environment: equation at position 11: y= \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲}̲ \left{ \be…<br>就是在\begin{equation}前加y=即可。</p>
<h1 id="四、Typora与HTML"><a href="#四、Typora与HTML" class="headerlink" title="四、Typora与HTML"></a>四、Typora与HTML</h1><h3 id="4-1-改变字体颜色及大小"><a href="#4-1-改变字体颜色及大小" class="headerlink" title="4.1 改变字体颜色及大小"></a>4.1 改变字体颜色及大小</h3><p>我们可以使用<font> </font>标签来改变字体的颜色及大小，如：</p>
<p><font size="3" color="red">字体颜色为红色，大小为3</font></p>
<p><font size="4" color="blue">字体颜色为蓝色，大小为4</font></p>
<p><font size="6" color="violet">字体颜色为紫罗兰，大小为6</font></p>
<p>属性size表示字体大小，color表示颜色。</p>
<h3 id="4-2-改变对齐方式"><a href="#4-2-改变对齐方式" class="headerlink" title="4.2 改变对齐方式"></a>4.2 改变对齐方式</h3><p>我们可以改变字体的对齐方式，用标签</p><p> </p>加上属性align，如：<p></p>
<p>1 </p><p align="left">左对齐</p><br>2 <p align="center">中间对齐</p><br>3 <p align="right">右对齐</p><br>结果为：<p></p>
<p align="left">左对齐</p>
<p align="center">中间对齐</p>
<p align="right">右对齐</p>

<h3 id="4-3-插入图像"><a href="#4-3-插入图像" class="headerlink" title="4.3 插入图像"></a>4.3 插入图像</h3><p>大家可以自己在Typora中测试。<br>我们可以通过标签<img src="url">来插入图片，如：</p>
<img src="img/1.jpg">
结果为：



<p><img src="/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E4%B9%8BTypora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/%E6%9C%89%E5%BF%97%E8%80%85%EF%BC%8C%E4%BA%8B%E7%AB%9F%E6%88%90.png"></p>
<p>我们可以改变<img>标签的属性，来改变图片的大小。</p>
<img src="img/1.jpg" width="100" height="100/">
1
将图片的宽高均设为100



<p>也可以改变图片的位置，如：</p>
<p><img src="img/1.jpg" width="30" height="30" style="float:left">图片在左边<br><img src="img/1.jpg" width="30" height="30" style="float:right">图片在右边</p>
<h1 id="五、扩展用法"><a href="#五、扩展用法" class="headerlink" title="五、扩展用法"></a>五、扩展用法</h1><h3 id="5-1-插入emoji表情"><a href="#5-1-插入emoji表情" class="headerlink" title="5.1 插入emoji表情"></a>5.1 插入emoji表情</h3><p>我们可以使用:emoji:的语法来插入表情，比如：</p>
<p>:happy:的语法为:happy:</p>
<p>🦀的语法为<span class="github-emoji"><span>🦀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f980.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>🐴的语法为<span class="github-emoji"><span>🐴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f434.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<h3 id="5-2-插入目录"><a href="#5-2-插入目录" class="headerlink" title="5.2 插入目录"></a>5.2 插入目录</h3><p>当我们为使用标题将文分章节后，可以在输入[toc]命令的地方自动根据标题生成目录。</p>
<h3 id="5-3-导出"><a href="#5-3-导出" class="headerlink" title="5.3 导出"></a>5.3 导出</h3><p>选择文件 –&gt; 导出，可以选择导出的文件格式，有pdf,html,word等格式。</p>
<h3 id="5-4-文本高亮"><a href="#5-4-文本高亮" class="headerlink" title="5.4 文本高亮"></a>5.4 文本高亮</h3><p>在Typora中，可以用一对==将要高亮的文本括起来，如：</p>
<p>==要高亮的文本==<br>==背景会用黄色填充==<br>1<br>2<br>结果为：</p>
<p>要高亮的文本<br>背景会用黄色填充</p>
<p>这个功能可在偏好设置 –&gt; Markdown扩展语法中设置。</p>
<h3 id="5-5-上下标"><a href="#5-5-上下标" class="headerlink" title="5.5 上下标"></a>5.5 上下标</h3><p>在Typora中，可以用一对<del>将下标括起来，如：H</del>2~O表示H2O</p>
<p>同样，我们也可以用一对^将上标括起来，如：X^2^表示X2</p>
<p>上下标可在偏好设置 –&gt; Markdown扩展语法中设置。</p>
<p><strong>六、参考资料</strong></p>
<p>[1] 菜鸟Markdown教程：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p>
<p>[2] 更多数学符号表达式：<a href="http://mohu.org/info/symbols/symbols.htm">http://mohu.org/info/symbols/symbols.htm</a></p>
<p>[3] Latex 方程组表示： <a href="https://blog.csdn.net/lemolemac/article/details/9057471">https://blog.csdn.net/lemolemac/article/details/9057471</a></p>
<p>[4] 菜鸟HTML教程：<a href="https://www.runoob.com/html/html-tutorial.html">https://www.runoob.com/html/html-tutorial.html</a></p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是Typora的安装和介绍教程了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>工具浅玩类</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Spark大数据开发</title>
    <url>/2022/03/18/%E5%85%B3%E4%BA%8ESpark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="关于Spark大数据开发"><a href="#关于Spark大数据开发" class="headerlink" title="关于Spark大数据开发:"></a>关于Spark大数据开发:</h1><h1 id="一、Spark概述"><a href="#一、Spark概述" class="headerlink" title="一、Spark概述"></a>一、Spark概述</h1><h2 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h2><p>Spark，是一种”One Stack to rule them all”的大数据计算框架，期望使用一个技术堆栈就完美地解决大数据领域的各种计算任务。Apache官方，对Spark的定义就是：通用的大数据快速处理引擎。<br>Spark使用Spark RDD、Spark SQL、 Spark Streaming，MLlib，GraphX成功解决了大数据领城中，离线批处理、交互式查询、实时流计算、机器学习与图计算等最重要的任务和问题。<br>Spark除了一站式的特点之外，另外一个最重要的特点，就是基于内存进行计算，从而让它的速度可以达到MapReduce、Hive的数倍甚至数十倍！<br>现在已经有很多大公司正在生产环境下深度地使用Spark作为大数据的计算框架，包括eBay.Yahool、 BAT、网易、京东、华为、大众点评、优酷土豆、搜狗等等。<br>Spark同时也获得了多个世界顶级IT厂商的支持，包括IBM、 Intel等。</p>
<p>Spark，是一种通用的大数据计算框架，I正如传统大数据技术Hadoop的MapReduce、Hive引擎，以及Storm流式实时计算引擎等，<br>Spark包含了大数据领城常见的各种计算框架：比如Spark Core用于离线计算，Spark SQL用于交互式查询，Spark Streaming用于实时流式计算，Spark MILlib用于机器学习，Spark GraphX用于图计算。<br>Spark主要用于大数据的计算，而Hadoop以后主要用于大数据的存储（比如HDFS、Hive，HBase等），以及资源调度（Yarn）。</p>
<p>Spark+Hadoop的组合，是未来大数据领域最热门的组合，也是最有前景的组合！</p>
<h2 id="（2）Spark整体架构"><a href="#（2）Spark整体架构" class="headerlink" title="（2）Spark整体架构"></a>（2）Spark整体架构</h2><p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/1.png"></p>
<h2 id="（3）Spark特性："><a href="#（3）Spark特性：" class="headerlink" title="（3）Spark特性："></a>（3）Spark特性：</h2><p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/2.png"></p>
<h4 id="（1）spark-计算速度快"><a href="#（1）spark-计算速度快" class="headerlink" title="（1）spark 计算速度快"></a>（1）spark 计算速度快</h4><p>spark将每个任务构建成DAG进行计算，内部的计算过程通过弹性式分布式数据集RDD在内存在进行计算，相比于hadoop的mapreduce效率提升了100倍。</p>
<h4 id="（2）易于使用"><a href="#（2）易于使用" class="headerlink" title="（2）易于使用"></a>（2）易于使用</h4><p>spark 提供了大量的算子，开发只需调用相关api进行实现无法关注底层的实现原理。</p>
<p>通用的大数据解决方案</p>
<p>相较于以前离线任务采用mapreduce实现，实时任务采用storm实现，目前这些都可以通过spark来实现，降低来开发的成本。同时spark 通过spark SQL降低了用户的学习使用门槛，还提供了机器学习，图计算引擎等。</p>
<h4 id="（3）支持多种的资源管理模式"><a href="#（3）支持多种的资源管理模式" class="headerlink" title="（3）支持多种的资源管理模式"></a>（3）支持多种的资源管理模式</h4><p>学习使用中可以采用local 模型进行任务的调试，在正式环境中又提供了standalone，yarn等模式，方便用户选择合适的资源管理模式进行适配。</p>
<h4 id="（4）社区支持"><a href="#（4）社区支持" class="headerlink" title="（4）社区支持"></a>（4）社区支持</h4><p>spark 生态圈丰富，迭代更新快，成为大数据领域必备的计算引擎。</p>
<h2 id="（4）Spark与MR"><a href="#（4）Spark与MR" class="headerlink" title="（4）Spark与MR"></a>（4）Spark与MR</h2><p>MapReduce能够完成的各种离线批处理功能，以及常见算法（比如二次排序、topn等），基于Spark RDD的核心编程，都可以实现，并且可以更好地、更容易地实现。而且基于Spark RDD编写的离线批处理程序，运行速度是MapReduce的数倍，速度上有非常明显的优势。</p>
<p>Spark相较于MapReduce速度快的最主要原因就在于，MapReduce的计算模型太死板，必须是map-reduce模式，有时候即使完成一些诸如过滤之类的操作，也必须经过map-reduce过程，这样就必须经过shuffle过程。而<br>MapReduce的shuffle过程是最消耗性能的，因为shuffle中间的过程必须基于磁盘来读写。而Spark的shuffle虽然也要基于磁盘，但是其大量transformation操作，比如单纯的map或者filter等操作，可以直接基于内存进行pipeline操作，速度性能自然大大提升。</p>
<p>但是Spark也有其劣势。由于Spark基于内存进行计算，虽然开发容易，但是真正面对大数据的时候（比如一次操作针对10亿以上级别），在没有进行调优的情况下，可能会出现各种各样的问题，比如OOM内存溢出等等。导致Spark程序可能都无法完全运行起来，就报错挂掉了，而MapReduce即使是运行缓慢，但是至少可以慢慢运行完。</p>
<p>此外，Spark由于是新崛起的技术新秀，因此在大数据领域的完善程度，肯定不如MapReduce，比如基于HBase、Hive作为离线批处理程序的输入输出，Spark就远没有MapReduce来的完善。实现起来非常麻烦。</p>
<h2 id="（5）Spark-Streaming与Storm"><a href="#（5）Spark-Streaming与Storm" class="headerlink" title="（5）Spark Streaming与Storm"></a>（5）Spark Streaming与Storm</h2><p>Spark Streaming 与Storm都可以用于进行实时流计算。但是他们两者的区别是非常大的。其中区别之一，就是，Spark<br>Streaming 和Storm的计算模型完全不一样，Spark Streaming是基于RDD的，因此需要将一小段时间内的，比如1秒内的数据，收集起来，作为一个RDD，然后再针对这个batch的数据进行处理。而Storm却可以做到每来一条数据，都可以立即进行处理和计算。因此，Spark Streaming实际上严格意义上来说，只能称作准实时的流计算框架；西Storm是真正意义上的实时计算框架<br>此外，Storm支持的一项高级特性，是Spark Streaming暂时不具备的，即Storm支持在分布式流式计算程序（Topolopy）在运行过程中，可以动态地调整并行度，从而动态提高并发处理能力。而Spark Streaming是无法动态调整并行度的。<br>但是Spark Streaming也有其优点，首先Spark Streaming由于是基于batch进行处理的，因此相较于Storm基于单条数据进行处理，具有数倍甚至数十倍的吞吐量。<br>此外，Spark Streaming由于也身处于Spark生态圈内，因此Spark Streaming可以与Spark Core、 Spark SQL，甚至是Spark Mllib.Spark GraphX进行无缝整合。流式处理完的数据，可以立即进行各种map、reduce转换操作，可以立即使用sql进行查询，甚至可以立即使用machine learning或者图计算算法进行处理。这种一站式的大数据处理功能和优势，是Storm无法匹敌的。<br>因此，综合上述来看，通常在对实时性要求特别高，而且实时数据量不稳定，比如在白天有高峰期的情况下，可以选择使用Storm。但是如果是对实时性要求一般，允许1秒的准实时处理，而且不要求动态调整并行度的话，选择Spark Streaming是更好的选择。</p>
<h2 id="（6）Spark-SQL与Hive"><a href="#（6）Spark-SQL与Hive" class="headerlink" title="（6）Spark SQL与Hive"></a>（6）Spark SQL与Hive</h2><p>Spark SQL实际上并不能完全替代Hive,因为Hive是一种基于HDFS的数据仓库,并且提供了基于SQL模型的,针对存储了大数据的数据仓库,进行分布式交互查询的查询引擎。<br>严格的来说, Spark SQL能够替代的,是ive的查询引擎,而不是Hive本身,实际上即使在生产环境下, SparkSQL也是针对Hive数据仓库中的数据进行查询, Spark本身自己是不提供存储的,自然也不可能替代Hive作为数据仓库的这个功能。<br>Spark SQL的一个优点,相较于Hive查询引擎来说,就是速度快,同样的SQL语句,可能使用Hive的查询引擎,由于其底层基于 MapReduce,必须经过 shuffle过程走磁盘,因此速度是非常缓慢的。很多复杂的SQL语句,在hive中执行都需要一个小时以上的时间。而 Spark SQLSpark由于其底层基于自身的基于内存的特点,因此速度达到了Hive查询引擎的数倍以上。<br>而 Spark SQL相较于Hive的另外一个优点,就是支持大量不同的数据源,包括ive、json、 parquet、jdbc等等此外, Spark SQLSpark由于身处技术堆栈内,也是基于RDD来工作,因此可以与 Spark的其他组件无缝整合使用,配合起来实现许多复杂的功能。比如 Spark SQL支持可以直接针对hdfs文件执行sq语句!</p>
<h1 id="二、Spark基本原理"><a href="#二、Spark基本原理" class="headerlink" title="二、Spark基本原理"></a>二、Spark基本原理</h1><h2 id="（1）Spark-Core"><a href="#（1）Spark-Core" class="headerlink" title="（1）Spark Core"></a>（1）Spark Core</h2><p>Spark Core是Spark的核心，其包含如下几个部分：</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/3.png"></p>
<h3 id="（1）spark-基础配置"><a href="#（1）spark-基础配置" class="headerlink" title="（1）spark 基础配置"></a>（1）spark 基础配置</h3><p>sparkContext是spark应用程序的入口，spark应用程序的提交和执行离不开sparkContext，它隐藏了网络通信，分布式部署，消息通信，存储体系，计算存储等，开发人员只需要通过sparkContext等api进行开发即可。</p>
<p>sparkRpc 基于netty实现，分为异步和同步两种方式。事件总线主要用于sparkContext组件间的交换，它属于监听者模式，采用异步调用。度量系统主要用于系统的运行监控。</p>
<p>（2）spark 存储系统</p>
<p>它用于管理spark运行中依赖的数据存储方式和存储位置，spark的存储系统优先考虑在各节点以内存的方式存储数据，内存不足时将数据写入磁盘中，这也是spark计算性能高的重要原因。</p>
<p>我们可以灵活的控制数据存储在内存还是磁盘中，同时可以通过远程网络调用将结果输出到远程存储中，比如hdfs，hbase等。</p>
<p>（3）spark 调度系统</p>
<p>spark 调度系统主要由DAGScheduler和TaskScheduler组成。</p>
<p>DAGScheduler 主要是把一个Job根据RDD间的依赖关系，划分为多个Stage，对于划分后的每个Stage都抽象为一个或多个Task组成的任务集，并交给TaskScheduler来进行进一步的任务调度。而TaskScheduler 负责对每个具体的Task进行调度。</p>
<p>具体调度算法有FIFO，FAIR：</p>
<p>FIFO调度：先进先出，这是Spark默认的调度模式。<br>FAIR调度：支持将作业分组到池中，并为每个池设置不同的调度权重，任务可以按照权重来决定执行顺序。</p>
<h2 id="（2）Spark-SQL"><a href="#（2）Spark-SQL" class="headerlink" title="（2）Spark SQL"></a>（2）Spark SQL</h2><p>spark sql提供了基于sql的数据处理方法，使得分布式的数据集处理变的更加简单，这也是spark 广泛使用的重要原因。</p>
<p>目前大数据相关计算引擎一个重要的评价指标就是：是否支持sql，这样才会降低使用者的门槛。spark sql提供了两种抽象的数据集合DataFrame和DataSet。</p>
<p>DataFrame 是spark Sql 对结构化数据的抽象，可以简单的理解为spark中的表，相比较于RDD多了数据的表结构信息(schema).DataFrame = Data + schema</p>
<p>RDD是分布式对象集合，DataFrame是分布式Row的集合，提供了比RDD更丰富的算子，同时提升了数据的执行效率。</p>
<p>DataSet 是数据的分布式集合 ，它具有RDD强类型的优点 和Spark SQL优化后执行的优点。DataSet可以由jvm对象构建，然后使用map，filter，flatmap等操作函数操作。</p>
<h2 id="（3）Spark-Streaming"><a href="#（3）Spark-Streaming" class="headerlink" title="（3）Spark Streaming"></a>（3）Spark Streaming</h2><p>这个模块主要是对流数据的处理，支持流数据的可伸缩和容错处理，可以与Flume和Kafka等已建立的数据源集成。Spark Streaming的实现，也使用RDD抽象的概念，使得在为流数据编写应用程序时更为方便。</p>
<h2 id="（4）Spark基本工作原理"><a href="#（4）Spark基本工作原理" class="headerlink" title="（4）Spark基本工作原理"></a>（4）Spark基本工作原理</h2><p>Spark基本工作原理的理解，其最主要的是要搞清楚什么是RDD以及RDD的特性。深刻理解了RDD的特性，也就理解了数据在spark中是如何被处理的（spark的基本工作原理）</p>
<p>那么RDD是什么，官方说法：<br>RDD是Spark提供的核心抽象，全称为Resillient Distributed Dataset，即弹性分布式数据集。</p>
<p>最简单的理解：<br>RDD就是源数据的抽象，或者叫映射，或者就代表。也就是说，数据要被spark进行处理，在处理之前的首要任务就是要将数据映射成RDD，对于spark来说，RDD才是我们处理数据的规则，我只认RDD，只有RDD，通过我spark的计算引擎，才能发挥巨大的威力！</p>
<h3 id="（1）分布式数据集"><a href="#（1）分布式数据集" class="headerlink" title="（1）分布式数据集"></a>（1）分布式数据集</h3><p>RDD是Spark提供的核心抽象，全称为Resillient Distributed Dataset，即弹性分布式数据集。</p>
<p>RDD在抽象上来说是一种元素集合，包含了数据。它是被分区的，分为多个分区，每个分区分布在集群中的不同节点上，从而让RDD中的数据可以被并行操作。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/4.png"></p>
<h3 id="（2）弹性"><a href="#（2）弹性" class="headerlink" title="（2）弹性"></a>（2）弹性</h3><p>RDD的数据默认情况下存放在内存中的，但是在内存资源不足时，Spark会自动将RDD数据写入磁盘。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/5.png"></p>
<h3 id="（3）迭代式处理"><a href="#（3）迭代式处理" class="headerlink" title="（3）迭代式处理"></a>（3）迭代式处理</h3><p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/6.png"></p>
<p>对节点1、2、3、4上的数据进行处理完成之后，可能会移动到其他的节点内存中继续处理！Spark 与Mr最大的不同在与迭代式计算模型：Mr分为两个阶段，map和reduce，两个阶段处理完了就结束了，所以我们在一个job中能做的处理很有限，只能在map和reduce中处理；而spark计算过程可以分为n个阶段，因为他是内存迭代式的，我们在处理完一个阶段之后，可以继续往下处理很多阶段，而不是两个阶段。所以Spark相较于MR，计算模型可以提供更强大的功能。</p>
<h3 id="（4）容错性"><a href="#（4）容错性" class="headerlink" title="（4）容错性"></a>（4）容错性</h3><p>RDD最重要的特性就是，提供了容错性，可以自动从节点失败中恢复过来。即如果某个节点上的RDD partition，因为节点故障，导致数据丢了，那么RDD会自动通过自己的数据来源重新计算该partition。这一切对使用者是透明的。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/7.png"></p>
<h1 id="三、Spark-运行模式及集群角色"><a href="#三、Spark-运行模式及集群角色" class="headerlink" title="三、Spark 运行模式及集群角色"></a>三、Spark 运行模式及集群角色</h1><h2 id="（1）Spark运行模式"><a href="#（1）Spark运行模式" class="headerlink" title="（1）Spark运行模式"></a>（1）Spark运行模式</h2><table>
<thead>
<tr>
<th align="center"><strong>运行模式</strong></th>
<th align="center"><strong>运行类型</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">local</td>
<td align="center">本地模式</td>
<td align="center">常用于本地开发测试，分为local单线程和local-cluster多线程模式</td>
</tr>
<tr>
<td align="center">standalone</td>
<td align="center">集群模式</td>
<td align="center">独立模式，在spark自己的资源调度管理框架上运行，该框架采用master/salve结构</td>
</tr>
<tr>
<td align="center">yarn</td>
<td align="center">集群模式</td>
<td align="center">在yarn资源管理器框架上运行，由yarn负责资源管理，spark负责任务调度和计算</td>
</tr>
<tr>
<td align="center">mesos</td>
<td align="center">集群模式</td>
<td align="center">在mesos资源管理器框架上运行，由mesos负责资源管理，spark负责任务调度和计算</td>
</tr>
<tr>
<td align="center">k8s</td>
<td align="center">集群模式</td>
<td align="center">在k8s上运行</td>
</tr>
</tbody></table>
<h2 id="（2）Spark集群角色"><a href="#（2）Spark集群角色" class="headerlink" title="（2）Spark集群角色"></a>（2）Spark集群角色</h2><p>下图是spark的集群角色图，主要有集群管理节点cluster manager，工作节点worker，执行器executor，驱动器driver和应用程序application 五部分组成，下面详细说明每部分的特点。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/8.png"></p>
<h3 id="（1）Cluster-Manager"><a href="#（1）Cluster-Manager" class="headerlink" title="（1）Cluster Manager"></a>（1）Cluster Manager</h3><p>集群管理器，它存在于Master进程中，主要用来对应用程序申请的资源进行管理，根据其部署模式的不同，可以分为local，standalone，yarn，mesos等模式。</p>
<h3 id="（2）worker"><a href="#（2）worker" class="headerlink" title="（2）worker"></a>（2）worker</h3><p>worker是spark的工作节点，用于执行任务的提交，主要工作职责有下面四点：</p>
<p>worker节点通过注册机向cluster manager汇报自身的cpu，内存等信息。<br>worker 节点在spark master作用下创建并启用executor，executor是真正的计算单元。<br>spark master将任务Task分配给worker节点上的executor并执行运用。<br>worker节点同步资源信息和executor状态信息给cluster manager。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/9.png"></p>
<p>在yarn 模式下运行worker节点一般指的是NodeManager节点，standalone模式下运行一般指的是slave节点。</p>
<h3 id="（3）executor"><a href="#（3）executor" class="headerlink" title="（3）executor"></a>（3）executor</h3><p>executor 是真正执行计算任务的组件，它是application运行在worker上的一个进程。这个进程负责Task的运行，它能够将数据保存在内存或磁盘存储中，也能够将结果数据返回给Driver。</p>
<h3 id="（4）Application"><a href="#（4）Application" class="headerlink" title="（4）Application"></a>（4）Application</h3><p>application是Spark API 编程的应用程序，它包括实现Driver功能的代码和在程序中各个executor上要执行的代码，一个application由多个job组成。其中应用程序的入口为用户所定义的main方法。</p>
<h3 id="（5）Driver"><a href="#（5）Driver" class="headerlink" title="（5）Driver"></a>（5）Driver</h3><p>驱动器节点，它是一个运行Application中main函数并创建SparkContext的进程。application通过Driver 和Cluster Manager及executor进行通讯。它可以运行在application节点上，也可以由application提交给Cluster Manager，再由Cluster Manager安排worker进行运行。</p>
<p>Driver节点也负责提交Job，并将Job转化为Task，在各个Executor进程间协调Task的调度。</p>
<h3 id="（6）sparkContext"><a href="#（6）sparkContext" class="headerlink" title="（6）sparkContext"></a>（6）sparkContext</h3><p>sparkContext是整个spark应用程序最关键的一个对象，是Spark所有功能的主要入口点。核心作用是初始化spark应用程序所需要的组件，同时还负责向master程序进行注册等。</p>
<h2 id="（3）Spark其他核心概念"><a href="#（3）Spark其他核心概念" class="headerlink" title="（3）Spark其他核心概念"></a>（3）Spark其他核心概念</h2><h3 id="（1）RDD"><a href="#（1）RDD" class="headerlink" title="（1）RDD"></a>（1）RDD</h3><p>它是Spark中最重要的一个概念，是弹性分布式数据集，是一种容错的、可以被并行操作的元素集合，是Spark对所有数据处理的一种基本抽象。可以通过一系列的算子对rdd进行操作，主要分为Transformation和Action两种操作。</p>
<p>‍‍‍‍‍Transformation(转换)：是对已有的RDD进行换行生成新的RDD，对于转换过程采用惰性计算机制，不会立即计算出结果。常用的方法有map，filter，flatmap等。<br>Action(执行)：对已有对RDD对数据执行计算产生结果，并将结果返回Driver或者写入到外部存储中。常用到方法有reduce，collect，saveAsTextFile等。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/10.png"></p>
<h3 id="（2）DAG"><a href="#（2）DAG" class="headerlink" title="（2）DAG"></a>（2）DAG</h3><p>DAG是一个有向无环图，在Spark中， 使用 DAG 来描述我们的计算逻辑。主要分为DAG Scheduler 和Task Scheduler。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/11.png"></p>
<h3 id="（3）DAG-Scheduler"><a href="#（3）DAG-Scheduler" class="headerlink" title="（3）DAG Scheduler"></a>（3）DAG Scheduler</h3><p>DAG Scheduler 是面向stage的高层级的调度器，DAG Scheduler把DAG拆分为多个Task，每组Task都是一个stage，解析时是以shuffle为边界进行反向构建的，每当遇见一个shuffle，spark就会产生一个新的stage，接着以TaskSet的形式提交给底层的调度器（task scheduler），每个stage封装成一个TaskSet。DAG Scheduler需要记录RDD被存入磁盘物化等动作，同时会需要Task寻找最优等调度逻辑，以及监控因shuffle跨节点输出导致的失败。<br><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/12.png"></p>
<h3 id="（4）Task-Scheduler"><a href="#（4）Task-Scheduler" class="headerlink" title="（4）Task Scheduler"></a>（4）Task Scheduler</h3><p>Task Scheduler 负责每一个具体任务的执行。它的主要职责包括</p>
<p>任务集的调度管理<br>状态结果跟踪<br>物理资源调度管理<br>任务执行<br>获取结果</p>
<h3 id="（5）Job"><a href="#（5）Job" class="headerlink" title="（5）Job"></a>（5）Job</h3><p>job是有多个stage构建的并行的计算任务，job是由spark的action操作来触发的，在spark中一个job包含多个RDD以及作用在RDD的各种操作算子。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/13.png"></p>
<h3 id="（6）stage"><a href="#（6）stage" class="headerlink" title="（6）stage"></a>（6）stage</h3><p>DAG Scheduler会把DAG切割成多个相互依赖的Stage，划分Stage的一个依据是RDD间的宽窄依赖。</p>
<p>在对Job中的所有操作划分Stage时，一般会按照倒序进行，即从Action开始，遇到窄依赖操作，则划分到同一个执行阶段，遇到宽依赖操作，则划分一个新的执行阶段，且新的阶段为之前阶段的parent，然后依次类推递归执行。</p>
<p>child Stage需要等待所有的parent Stage执行完之后才可以执行，这时Stage之间根据依赖关系构成了一个大粒度的DAG。在一个Stage内，所有的操作以串行的Pipeline的方式，由一组Task完成计算。</p>
<h3 id="（7）TaskSet-Task"><a href="#（7）TaskSet-Task" class="headerlink" title="（7）TaskSet Task"></a>（7）TaskSet Task</h3><p>TaskSet 可以理解为一种任务，对应一个stage，是Task组成的任务集。一个TaskSet中的所有Task没有shuffle依赖可以并行计算。</p>
<p>Task是spark中最独立的计算单元，由Driver Manager发送到executer执行，通常情况一个task处理spark RDD一个partition。Task分为ShuffleMapTask和ResultTask两种，位于最后一个Stage的Task为ResultTask，其他阶段的属于ShuffleMapTask。</p>
<h1 id="四、Spark作业运行流程"><a href="#四、Spark作业运行流程" class="headerlink" title="四、Spark作业运行流程"></a>四、Spark作业运行流程</h1><h2 id="1-Spark作业运行流程"><a href="#1-Spark作业运行流程" class="headerlink" title="(1)Spark作业运行流程"></a>(1)Spark作业运行流程</h2><p>spark应用程序以进程集合为单位在分布式集群上运行，通过driver程序的main方法创建sparkContext的对象与集群进行交互。具体运行流程如下：</p>
<p>sparkContext向cluster Manager申请CPU，内存等计算资源。<br>cluster Manager分配应用程序执行所需要的资源，在worker节点创建executor。<br>sparkContext将程序代码和task任务发送到executor上进行执行，代码可以是编译成的jar包或者python文件等。接着sparkContext会收集结果到Driver端。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/14.png"></p>
<h2 id="（2）-Spark-RDD迭代过程"><a href="#（2）-Spark-RDD迭代过程" class="headerlink" title="（2） Spark RDD迭代过程"></a>（2） Spark RDD迭代过程</h2><p>sparkContext创建RDD对象，计算RDD间的依赖关系，并组成一个DAG有向无环图。<br>DAGScheduler将DAG划分为多个stage，并将stage对应的TaskSet提交到集群的管理中心，stage的划分依据是RDD中的宽窄依赖，spark遇见宽依赖就会划分为一个stage，每个stage中包含来一个或多个task任务，避免多个stage之间消息传递产生的系统开销。<br>taskScheduler 通过集群管理中心为每一个task申请资源并将task提交到worker的节点上进行执行。<br>worker上的executor执行具体的任务。<br><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/15.png"></p>
<h2 id="（3）Yarn资源管理器介绍"><a href="#（3）Yarn资源管理器介绍" class="headerlink" title="（3）Yarn资源管理器介绍"></a>（3）Yarn资源管理器介绍</h2><p>spark 程序一般是运行在集群上的，spark on yarn是工作或生产上用的非常多的一种运行模式。</p>
<p>没有yarn模式前，每个分布式框架都要跑在一个集群上面，比如说Hadoop要跑在一个集群上，Spark用集群的时候跑在standalone上。这样的话整个集群的资源的利用率低，且管理起来比较麻烦。</p>
<p>yarn是分布式资源管理和任务管理管理，主要由ResourceManager，NodeManager和ApplicationMaster三个模块组成。</p>
<p><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/16.png"></p>
<p>ResourceManager 主要负责集群的资源管理，监控和分配。对于所有的应用它有绝对的控制权和资源管理权限。</p>
<p>NodeManager 负责节点的维护，执行和监控task运行状况。会通过心跳的方式向ResourceManager汇报自己的资源使用情况。</p>
<p>yarn资源管理器的每个节点都运行着一个NodeManager，是ResourceManager的代理。如果主节点的ResourceManager宕机后，会连接ResourceManager的备用节点。</p>
<p>ApplicationMaster 负责具体应用程序的调度和资源的协调，它会与ResourceManager协商进行资源申请。ResourceManager以container容器的形式将资源分配给application进行运行。同时负责任务的启停。</p>
<p>container 是资源的抽象，它封装着每个节点上的资源信息(cpu,内存，磁盘，网络等)，yarn将任务分配到container上运行，同时该任务只能使用container描述的资源，达到各个任务间资源的隔离。</p>
<h2 id="（4）Spark程序在Yarn上执行流程"><a href="#（4）Spark程序在Yarn上执行流程" class="headerlink" title="（4）Spark程序在Yarn上执行流程"></a>（4）Spark程序在Yarn上执行流程</h2><p>spark on yarn分为两种模式yarn-client模式，和yarn—cluster模式，一般线上采用的是yarn-cluster模式。</p>
<h3 id="（1）yarn-client模式"><a href="#（1）yarn-client模式" class="headerlink" title="（1）yarn-client模式"></a>（1）yarn-client模式</h3><p>driver在客户端本地执行，这种模式可以使得spark application和客户端进行交互，因为driver在客户端可以通过webUI访问driver的状态。同时Driver会与yarn集群中的Executor进行大量的通信，会造成客户机网卡流量的大量增加。</p>
<h3 id="（2）yarn-cluster模式"><a href="#（2）yarn-cluster模式" class="headerlink" title="（2）yarn-cluster模式"></a>（2）yarn-cluster模式</h3><p>Yarn-Cluster主要用于生产环境中，因为Driver运行在Yarn集群中某一台NodeManager中，每次提交任务的Driver所在的机器都是随机的，不会产生某一台机器网卡流量激增的现象，缺点是任务提交后不能看到日志。只能通过yarn查看日志。</p>
<p>下图是yarn-cluster运行模式：<br><img src="/%E5%85%B3%E4%BA%8Espark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/17.png"></p>
<p>client 向yarn提交应用程序，包含ApplicationMaster程序、启动ApplicationMaster的命令、需要在Executor中运行的程序等。<br>ApplicationMaster程序启动ApplicationMaster的命令、需要在Executor中运行的程序等。<br>ApplicationMaster向ResourceManager注册，这样用户可以直接通过ResourceManage查看应用程序的运行状态。<br>ApplicationMaster申请到资源（也就是Container）后，便与对应的NodeManager通信，启动Task。<br>Task向ApplicationMaster汇报运行的状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。<br>应用程序运行完成后，ApplicationMaster向ResourceManager申请注销并关闭自己。</p>
<h1 id="五、基于WordCount程序开发"><a href="#五、基于WordCount程序开发" class="headerlink" title="五、基于WordCount程序开发"></a>五、基于WordCount程序开发</h1><p>下面使用Java和Scala语言编写WordCount程序</p>
<h2 id="（1）Java开发WordCount程序"><a href="#（1）Java开发WordCount程序" class="headerlink" title="（1）Java开发WordCount程序"></a>（1）Java开发WordCount程序</h2><pre class="language-none"><code class="language-none">package com.kfk.spark;

import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.function.FlatMapFunction;
import org.apache.spark.api.java.function.Function2;
import org.apache.spark.api.java.function.PairFunction;
import org.apache.spark.api.java.function.VoidFunction;
import scala.Tuple2;

import java.util.Arrays;
import java.util.Iterator;

/**
 * @author : 
 * @email :
 * @date : 
 * @time : 
 */
public class WordCountJava {
    public static void main(String[] args) {

        SparkConf sparkConf = new SparkConf().setAppName("wordCountApp").setMaster("local");

        JavaSparkContext sc = new JavaSparkContext(sparkConf);

        JavaRDD lines = sc.textFile("hdfs://bigdata-pro-m04:9000/user/caizhengjie/datas/wordcount.txt");

        JavaRDD words = lines.flatMap(new FlatMapFunction&lt;String,String&gt;() {
            public Iterator call(String line) throws Exception {
                return Arrays.asList(line.split(" ")).iterator();
            }
        });

        JavaPairRDD word = words.mapToPair(new PairFunction&lt;String,String,Integer&gt;() {
            public Tuple2 call(String word) throws Exception {
                return new Tuple2(word,1);
            }
        });

        JavaPairRDD wordcount = word.reduceByKey(new Function2&lt;Integer,Integer,Integer&gt;() {
            public Integer call(Integer v1, Integer v2) throws Exception {
                return v1+ v2;
            }
        });

        wordcount.foreach(new VoidFunction&lt;Tuple2&lt;String,Integer&gt;&gt;() {
            public void call(Tuple2&lt;String,Integer&gt; o) throws Exception {
                System.out.println(o._1 + " : " + o._2);
            }
        });

    }
}
</code></pre>

<p>运行结果：</p>
<pre class="language-none"><code class="language-none">spark : 1
hive : 3
hadoop : 3
python : 1
flink : 2
java : 5
storm : 1
hbase : 1
</code></pre>

<h2 id="（2）Scala开发WordCount程序"><a href="#（2）Scala开发WordCount程序" class="headerlink" title="（2）Scala开发WordCount程序"></a>（2）Scala开发WordCount程序</h2><pre class="language-none"><code class="language-none">package com.kfk.spark

import org.apache.spark.{SparkConf, SparkContext}

/**
 * @author : 
 * @email :
 * @date : 
 * @time : 
 */
object WordCountScala {
    def main(args: Array[String]): Unit = {
        val sparkConf = new SparkConf().setAppName("wordCountApp").setMaster("local")
        val sc = new SparkContext(sparkConf)
        val lines = sc.textFile("hdfs://bigdata-pro-m04:9000/user/caizhengjie/datas/wordcount.txt")

        // val wordcount = lines.flatMap(line =&gt; line.split(" ")).map(word =&gt; (word,1)).reduceByKey((x,y) =&gt; (x+y)).foreach((_wordcount =&gt; println(_wordcount._1 + " : " + _wordcount._2))

        val words = lines.flatMap(line =&gt; line.split(" "))
        val word = words.map(word =&gt; (word,1))
        val wordcount = word.reduceByKey((x,y) =&gt; (x+y))

        // println(wordcount.collect().toList)

        wordcount.foreach(_wordcount =&gt; println(_wordcount._1 + " : " + _wordcount._2))
    }
}
</code></pre>

<p>运行结果：</p>
<pre class="language-none"><code class="language-none">spark : 1
hive : 3
hadoop : 3
python : 1
flink : 2
java : 5
storm : 1
hbase : 1
</code></pre>

<h2 id="（3）程序打包提交Spark集群测试"><a href="#（3）程序打包提交Spark集群测试" class="headerlink" title="（3）程序打包提交Spark集群测试"></a>（3）程序打包提交Spark集群测试</h2><pre class="language-none"><code class="language-none">bin/spark-submit --class com.kfk.spark.WordCountJava --master local[2] /opt/jars/wordcountjava.jar 
</code></pre>

<p>运行结果：</p>
<pre class="language-none"><code class="language-none">spark : 1
hive : 3
hadoop : 3
python : 1
flink : 2
java : 5
storm : 1
hbase : 1
</code></pre>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对Spark大数据技术的详细介绍了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>术语定义类</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发工具之IDEA安装教程</title>
    <url>/2020/09/18/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="IDEA开发工具安装教程"><a href="#IDEA开发工具安装教程" class="headerlink" title="IDEA开发工具安装教程:"></a>IDEA开发工具安装教程:</h1><p>工欲善其事，必先利其器。想要优雅且高效的编写代码，必须熟练使用一款后端开发工具。</p>
<p>但后端开发工具数不胜数，像Eclipse,Notepad++，MobaXterm,Maven,Tomcat…</p>
<p>(厉害的开发者都用记事本，哈哈)</p>
<p>IntelliJ IDEA被认为是当前Java开发效率最快的IDE工具。它整合了开发过程中实用的众多功能，几乎可以不用鼠标可以方便的完成你要做的任何事情，最大程度的加快开发的速度。简单而又功能强大。与其他的一些繁冗而复杂的IDE工具有鲜明的对比。</p>
<p>IDEA以其强大的代码编辑功能，代码补全功能和丰富的插件生态系统，独受后端开发者的青睐。</p>
<p>活不多说，开启教程：</p>
<h1 id="一、下载-IDEA"><a href="#一、下载-IDEA" class="headerlink" title="一、下载 IDEA"></a>一、下载 IDEA</h1><p>官方下载地址:<a href="https://www.jetbrains.com/zh-cn/idea/download/#section=windows">https://www.jetbrains.com/zh-cn/idea/download/#section=windows</a></p>
<p>历史版本下载：<a href="https://www.jetbrains.com/zh-cn/idea/download/other.html">https://www.jetbrains.com/zh-cn/idea/download/other.html</a></p>
<p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/1.jpg"></p>
<p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/2.jpg"></p>
<h1 id="二、安装-IDEA"><a href="#二、安装-IDEA" class="headerlink" title="二、安装 IDEA"></a>二、安装 IDEA</h1><p><strong>注：安装IDEA之前需要我们机器上有JDK环境！！！</strong> </p>
<p><strong>双击下载的安装包打开安装即可：</strong></p>
<p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/3.png"></p>
<h3 id="1、安装IDEA，一路next-即可，遇到安装路径时，记得修改安装路径。"><a href="#1、安装IDEA，一路next-即可，遇到安装路径时，记得修改安装路径。" class="headerlink" title="1、安装IDEA，一路next 即可，遇到安装路径时，记得修改安装路径。"></a>1、安装IDEA，一路<strong>next</strong> 即可，遇到安装路径时，记得修改安装路径。</h3><p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/4.jpg"></p>
<h3 id="2、安装完成，打开IDEA，会先弹出一个注册框，勾选Evaluate-for-free，点击-Evaluate，然后进入主界面"><a href="#2、安装完成，打开IDEA，会先弹出一个注册框，勾选Evaluate-for-free，点击-Evaluate，然后进入主界面" class="headerlink" title="2、安装完成，打开IDEA，会先弹出一个注册框，勾选Evaluate for free，点击 Evaluate，然后进入主界面"></a>2、安装完成，打开IDEA，会先弹出一个注册框，勾选<strong>Evaluate for free</strong>，点击 <strong>Evaluate</strong>，然后进入主界面</h3><h1 id="三、软件收费相关问题解决方案"><a href="#三、软件收费相关问题解决方案" class="headerlink" title="三、软件收费相关问题解决方案"></a>三、软件收费相关问题解决方案</h1><p>建议有条件的购买正版支持，也可以使用破解版，具体的破解流程，百度一下</p>
<h2 id="1、可以对IDEA进行破解，目前有两种方式："><a href="#1、可以对IDEA进行破解，目前有两种方式：" class="headerlink" title="1、可以对IDEA进行破解，目前有两种方式："></a>1、可以对IDEA进行破解，目前有两种方式：</h2><h3 id="1-无限重置30天的插件"><a href="#1-无限重置30天的插件" class="headerlink" title="1.无限重置30天的插件"></a>1.无限重置30天的插件</h3><h3 id="2-激活到2099的文件包，需要保存在计算机中"><a href="#2-激活到2099的文件包，需要保存在计算机中" class="headerlink" title="2.激活到2099的文件包，需要保存在计算机中"></a>2.激活到2099的文件包，需要保存在计算机中</h3><p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/5.png"></p>
<h1 id="四、关于中文汉化问题解决方案"><a href="#四、关于中文汉化问题解决方案" class="headerlink" title="四、关于中文汉化问题解决方案"></a>四、关于中文汉化问题解决方案</h1><p><strong>汉化插件对于英文不是很好的开发者来说，开发项目简直不要太轻松</strong></p>
<p><strong>IDEA可以加载插件，</strong></p>
<p><em><strong>所以汉化只需要下载一个汉化插件就可以实现将英文显示为中文。</strong></em></p>
<h3 id="1-创建项目或打开项目；"><a href="#1-创建项目或打开项目；" class="headerlink" title="1.创建项目或打开项目；"></a>1.创建项目或打开项目；</h3><h3 id="2-单击File-文件-gt-Settings-设置-或者Ctrl-Alt-S"><a href="#2-单击File-文件-gt-Settings-设置-或者Ctrl-Alt-S" class="headerlink" title="2.单击File(文件)->Settings(设置)或者Ctrl+Alt+S;"></a>2.单击File(文件)-&gt;Settings(设置)或者Ctrl+Alt+S;</h3><h3 id="3-选中plugins-插件管理-gt-MarketPlace-插件市场"><a href="#3-选中plugins-插件管理-gt-MarketPlace-插件市场" class="headerlink" title="3.选中plugins(插件管理)->MarketPlace(插件市场);"></a>3.选中plugins(插件管理)-&gt;MarketPlace(插件市场);</h3><h3 id="4-搜索Chinese-gt-选中下载Chinese-Simplified-简体中文语言包；"><a href="#4-搜索Chinese-gt-选中下载Chinese-Simplified-简体中文语言包；" class="headerlink" title="4.搜索Chinese->选中下载Chinese(Simplified)简体中文语言包；"></a>4.搜索Chinese-&gt;选中下载Chinese(Simplified)简体中文语言包；</h3><p><strong>结果如下图:</strong></p>
<p><img src="/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/6.png"></p>
<h3 id="5-下载完成后，应用，重新启动IDEA；"><a href="#5-下载完成后，应用，重新启动IDEA；" class="headerlink" title="5.下载完成后，应用，重新启动IDEA；"></a>5.下载完成后，应用，重新启动IDEA；</h3><p><strong>不过还是建议使用英文版，最好不要过分依赖中文</strong></p>
<p><strong>毕竟很多项目开发都是英文，需要对英语十分熟悉</strong></p>
<p><strong>英文版不仅可以提高对英语的兴趣，而且有助于熟练英文.</strong></p>
<h1 id="五、接下来就可以愉快地敲写代码了"><a href="#五、接下来就可以愉快地敲写代码了" class="headerlink" title="五、接下来就可以愉快地敲写代码了"></a>五、接下来就可以愉快地敲写代码了</h1><h1 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h1><p><strong>以上就是IDEA的安装和介绍教程了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>工具浅玩类</tag>
      </tags>
  </entry>
  <entry>
    <title>前端网页开发工具之VSCode使用教程</title>
    <url>/2020/10/18/%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BVSCode%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="VSCode开发工具安装教程"><a href="#VSCode开发工具安装教程" class="headerlink" title="VSCode开发工具安装教程:"></a>VSCode开发工具安装教程:</h1><p>工欲善其事，必先利其器。想要优雅且高效的编写代码，必须熟练使用一款前端开发工具。</p>
<p>但前端开发工具数不胜数，像HBuilder、Sublime Text、WebStorm、Visual Studio Code……等等,</p>
<p>其中VSCode以其轻量且强大的代码编辑功能和丰富的插件生态系统，独受前端开发者的青睐。</p>
<p>活不多说，开启教程：</p>
<hr>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><h3 id="直接在官网进行下载"><a href="#直接在官网进行下载" class="headerlink" title="直接在官网进行下载"></a>直接在官网进行下载</h3><p>Visual Studio Code - Code Editing. Redefined<br>​code.visualstudio.com/</p>
<h3 id="可以将vscode设置成中文"><a href="#可以将vscode设置成中文" class="headerlink" title="可以将vscode设置成中文"></a>可以将vscode设置成中文</h3><p>vscode默认的语言是英文，对于英文不好的小伙伴可能不太友好。<br>简单几步教大家如何将vscode设置成中文。</p>
<p>按快捷键“Ctrl+Shift+P”。<br>在“vscode”顶部会出现一个搜索框。<br>输入“configure language”，然后回车。<br>“vscode”里面就会打开一个语言配置文件。<br>将“en-us”修改成“zh-cn”。<br>按“Ctrl+S”保存设置。<br>关闭“vscode”，再次打开就可以看到中文界面了。<br>当然如果你不愿意设置，也可以直接安装它的中文插件，还是很人性化的。</p>
<h3 id="VScode用户设置"><a href="#VScode用户设置" class="headerlink" title="VScode用户设置"></a>VScode用户设置</h3><ol>
<li>打开设置</li>
</ol>
<p>文件–首选项–设置，打开用户设置。VScode支持选择配置，也支持编辑setting.json文件修改默认配置。个人更倾向于编写json的方式进行配置，下面会附上我个人的配置代码</p>
<p>这里解析几个常用配置项：</p>
<p>（1）editor.fontsize用来设置字体大小，可以设置editor.fontsize : 14;</p>
<p>（2）files.autoSave这个属性是表示文件是否进行自动保存，推荐设置为onFocusChange——文件焦点变化时自动保存。</p>
<p>（3）editor.tabCompletion用来在出现推荐值时，按下Tab键是否自动填入最佳推荐值，推荐设置为on;</p>
<p>（4）editor.codeActionsOnSave中的source.organizeImports属性，这个属性能够在保存时，自动调整 import 语句相关顺序，能够让你的 import 语句按照字母顺序进行排列，推荐设置为true,即”editor.codeActionsOnSave”: { “source.organizeImports”: true }；</p>
<p>（5）editor.lineNumbers设置代码行号,即editor.lineNumbers ：true；</p>
<p>我的个人配置，供参考：</p>
<p>{<br>  “files.associations”: {<br>  “<em>.vue”: “vue”,<br>  “</em>.wpy”: “vue”,<br>  “<em>.wxml”: “html”,<br>  “</em>.wxss”: “css”<br>  },<br>  “terminal.integrated.shell.windows”: “C:\Windows\System32\cmd.exe”,<br>  “git.enableSmartCommit”: true,<br>  “git.autofetch”: true,<br>  “emmet.triggerExpansionOnTab”: true,<br>  “emmet.showAbbreviationSuggestions”: true,<br>  “emmet.showExpandedAbbreviation”: “always”,<br>  “emmet.includeLanguages”: {<br>  “vue-html”: “html”,<br>  “vue”: “html”,<br>  “wpy”: “html”<br>  },<br>  //主题颜色<br>  //“workbench.colorTheme”: “Monokai”,<br>  “git.confirmSync”: false,<br>  “explorer.confirmDelete”: false,<br>  “editor.fontSize”: 14,<br>  “window.zoomLevel”: 1,<br>  “editor.wordWrap”: “on”,<br>  “editor.detectIndentation”: false,<br>  // 重新设定tabsize<br>  “editor.tabSize”: 2,<br>  //失去焦点后自动保存<br>  “files.autoSave”: “onFocusChange”,<br>  // #值设置为true时，每次保存的时候自动格式化；<br>  “editor.formatOnSave”: false,<br>   //每120行就显示一条线<br>  “editor.rulers”: [<br>  ],<br>  // 在使用搜索功能时，将这些文件夹/文件排除在外<br>  “search.exclude”: {<br>      “<strong>/node_modules”: true,<br>      “</strong>/bower_components”: true,<br>      “<strong>/target”: true,<br>      “</strong>/logs”: true,<br>  },<br>  // 这些文件将不会显示在工作空间中<br>  “files.exclude”: {<br>      “<strong>/.git”: true,<br>      “</strong>/.svn”: true,<br>      “<strong>/.hg”: true,<br>      “</strong>/CVS”: true,<br>      “<strong>/.DS_Store”: true,<br>      “</strong>/*.js”: {<br>          “when”: “$(basename).ts” //ts编译后生成的js文件将不会显示在工作空中<br>      },<br>      “**/node_modules”: true<br>  },<br>  // #让vue中的js按”prettier”格式进行格式化<br>  “vetur.format.defaultFormatter.html”: “js-beautify-html”,<br>  “vetur.format.defaultFormatter.js”: “prettier”,<br>  “vetur.format.defaultFormatterOptions”: {<br>      “js-beautify-html”: {<br>          // #vue组件中html代码格式化样式<br>          “wrap_attributes”: “force-aligned”, //也可以设置为“auto”，效果会不一样<br>          “wrap_line_length”: 200,<br>          “end_with_newline”: false,<br>          “semi”: false,<br>          “singleQuote”: true<br>      },<br>      “prettier”: {<br>          “semi”: false,<br>          “singleQuote”: true<br>      }<br>  }<br>}</p>
<p>新版的vscode设置默认为UI的设置，而非之前的json设置。如果你想复制我上面这段代码进行配置，可以进行下面的修改</p>
<p>文件&gt;首选项&gt;设置 &gt; 搜索workbench.settings.editor，选中json即可改成json设置；</p>
<h3 id="禁用自动更新"><a href="#禁用自动更新" class="headerlink" title="禁用自动更新"></a>禁用自动更新</h3><p>文件 &gt; 首选项 &gt; 设置（macOS：代码 &gt; 首选项 &gt; 设置，搜索update mode并将设置更改为none。</p>
<p>开启代码提示设置</p>
<p>第一步：点击左下角点击设置图标，找到并点击“setting”</p>
<p>第二步：到搜索框里搜索“prevent”—&gt;并取消此项的勾选</p>
<p>常用的快捷键<br>高效的使用vscode,记住一些常用的快捷键是必不可少的，我给大家罗列了一些日常工作过程中用的多的快捷键。</p>
<p>以下以Windows为主，windows的 Ctrl，mac下换成Command就行了</p>
<p>对于 行 的操作：</p>
<p>重开一行：光标在行尾的话，回车即可；不在行尾，ctrl + enter 向下重开一行；ctrl+shift + enter 则是在上一行重开一行<br>删除一行：光标没有选择内容时，ctrl + x 剪切一行；ctrl +shift + k 直接删除一行<br>移动一行：alt + ↑ 向上移动一行；alt + ↓ 向下移动一行<br>复制一行：shift + alt + ↓ 向下复制一行；shift + alt + ↑ 向上复制一行<br>ctrl + z 回退<br>对于 词 的操作：</p>
<p>选中一个词：ctrl + d<br>搜索或者替换：</p>
<p>ctrl + f ：搜索<br>ctrl + alt + f： 替换<br>ctrl + shift + f：在项目内搜索<br>通过Ctrl + ` 可以打开或关闭终端</p>
<p>Ctrl+P 快速打开最近打开的文件</p>
<p>Ctrl+Shift+N 打开新的编辑器窗口</p>
<p>Ctrl+Shift+W 关闭编辑器</p>
<p>Home 光标跳转到行头</p>
<p>End 光标跳转到行尾</p>
<p>Ctrl + Home 跳转到页头</p>
<p>Ctrl + End 跳转到页尾</p>
<p>Ctrl + Shift + [ 折叠区域代码</p>
<p>Ctrl + Shift + ] 展开区域代码</p>
<p>Ctrl + / 添加关闭行注释</p>
<p>Shift + Alt +A 块区域注释</p>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>在输入框中输入想要安装的插件名称，点击安装即可。安装后没有效果，可以重启vscode</p>
<h4 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h4><p>1、View In Browser</p>
<p>在浏览器里预览网页必备。运行html文件</p>
<p>动图封面<br>2、vscode-icons<br>改变编辑器里面的文件图标</p>
<p>3、Bracket Pair Colorizer<br>给嵌套的各种括号加上不同的颜色。</p>
<p>4、Auto Rename Tag<br>自动修改匹配的 HTML 标签。</p>
<p>动图封面<br>5、Path Intellisense<br>智能路径提示，可以在你输入文件路径时智能提示。</p>
<p>动图封面<br>6、Markdown Preview<br>实时预览 markdown。</p>
<p>7、stylelint<br>CSS / SCSS / Less 语法检查</p>
<p>8、Import Cost<br>引入包大小计算,对于项目打包后体积掌握很有帮助</p>
<p>动图封面<br>9、Prettier<br>比Beautify更好用的代码格式化插件<br>Vue插件<br>vetur<br>语法高亮、智能感知、Emmet等</p>
<p>VueHelper<br>snippet代码片段</p>
<p>动图封面</p>
<h4 id="其它插件"><a href="#其它插件" class="headerlink" title="其它插件"></a>其它插件</h4><p>1、CSScomb</p>
<p>CSS 书写顺序规则，这里我推荐腾讯 AollyTeam 团队的规范：</p>
<p><a href="http://alloyteam.github.io/CodeGuide/#css-declaration-order">http://alloyteam.github.io/CodeGuide/#css-declaration-order</a><br>​alloyteam.github.io/CodeGuide/#css-declaration-order<br>简单说下这个插件怎么用：</p>
<p>在项目的根目录下创建一个名为csscomb.json的文件，然后添加一些配置项。也可以将配置项写入项目的 package.json 文件中的 csscombConfig 字段。</p>
<p>至于添加的配置项，CSScomb 提供了示例配置文件：</p>
<p><a href="https://github.com/csscomb/csscomb.js/blob/master/config/csscomb.json">https://github.com/csscomb/csscomb.js/blob/master/config/csscomb.json</a><br>​github.com/csscomb/csscomb.js/blob/master/config/csscomb.json<br>其中的 sort-order 就是 CSS 属性书写顺序，可以按照自己遵循的规范设置，所以我直接替换成了腾讯的。</p>
<p>这个配置文件里面各个字段的作用可以戳这里查看：</p>
<p>csscomb/csscomb.js<br>​github.com/csscomb/csscomb.js/blob/master/doc/options.md<br>2、Turbo Console Log</p>
<p>快捷添加 console.log，一键 注释 / 启用 / 删除 所有 console.log。这也是我最常用的一个插件</p>
<p>动图封面<br>简单说下这个插件要用到的快捷键:</p>
<p>ctrl + alt + l 选中变量之后，使用这个快捷键生成 console.log<br>alt + shift + c 注释所有 console.log<br>alt + shift + u 启用所有 console.log<br>alt + shift + d 删除所有 console.log<br>3、GitLens</p>
<p>详细的 Git 提交日志。</p>
<p>Git 重度使用者必备，尤其是多人协作时：哪一行代码，何时、何人提交都有记录。</p>
<p>妈妈再也不用担心我背锅了！</p>
<p>4、css-auto-prefix<br>自动添加 CSS 私有前缀。</p>
<p>动图封面<br>5、change-case<br>转换命名风格。</p>
<p>动图封面<br>6、CSS Peek</p>
<p>定位 CSS 类名。</p>
<p>动图封面<br>7、vscode-json</p>
<p>处理 JSON 文件，用法看图：</p>
<p>动图封面<br>8、Regex Previewer<br>实时预览正则表达式的效果。</p>
<p>动图封面</p>
<h3 id="设置同步"><a href="#设置同步" class="headerlink" title="设置同步"></a>设置同步</h3><p>花了一天终于把vscode配置成自己满意的样子，如果每换一次电脑就要重新来一次，大家一定会手撕了我。放心，早就帮大家准备好了。Settings Sync，在不同电脑间同步你的插件。</p>
<p>首先要想在不同的设备间同步你的插件, 需要用到 Token 和Gist id</p>
<p>Token 就是你把插件上传到 github 上时, 让你保存的那段字符，Gist id 在你上传插件的那台电脑上保存着。</p>
<p>先给大家来三个快捷键，后面会用到</p>
<p>1、CTRL+SHIFT+P 我也不知道叫什么，暂且就叫它功能搜索功能吧<br>2、ALT+SHIFT+D 下载配置<br>3、ALT+SHIFT+U 上传配置<br>现在手把手教大家配置：</p>
<p>1、安装Settings Sync<br>2、登陆Github&gt;settings&gt;Developer settings&gt;personal access tokens&gt;generate new token，输入名称，勾选Gist，提交</p>
<p>3、保存Github Access Token<br>4、打开vscode，Ctrl+Shift+P打开命令框–&gt;输入sync–&gt;选择高级设置–&gt;编辑本地扩展设置–&gt;编辑token</p>
<p>5、Ctrl+Shift+P打开命令框–&gt;输入sync–&gt;找到update/upload settings，上传成功后会返回Gist ID，保存此Gist ID.</p>
<p>动图封面<br>6、在 VSCode 里，依次打开: 文件 -&gt; 首选项 -&gt; 设置，然后输入 Sync 进行搜索:能找到你gist id</p>
<p>7、若需在其他机器上DownLoad插件的话，同样，Ctrl+Shift+P打开命令框，输入sync，找到Download settings，会跳转到Github的Token编辑界面，点Edit，regenerate token，保存新生成的token，在vscode命令框中输入此Token，回车，再输入之前的Gist ID，即可同步插件和设置</p>
<h3 id="开启本地服务"><a href="#开启本地服务" class="headerlink" title="开启本地服务"></a>开启本地服务</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p>1.安装Debugger for Chrome插件</p>
<p>2.使用ctrl+`快捷键打开终端，然后输入npm install -g live-server</p>
<p>3.在命令行里输入 live-server即可</p>
<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p>在写前端页面中，经常会在浏览器运行HTML页面，从本地文件夹中直接打开的一般都是file协议，当代码中存在http或https的链接时，HTML页面就无法正常打开，为了解决这种情况，需要在在本地开启一个本地的服务器。 本文是利用node.js中的http-server，开启本地服务，步骤如下：</p>
<p>1.安装http-server</p>
<p>在终端输入： $ npm install http-server -g</p>
<p>2.开启 http-server服务</p>
<p>终端进入目标文件夹，然后在终端输入：</p>
<p>$ http-server -c-1   （⚠️只输入http-server的话，更新了代码后，页面不会同步更新）<br>Starting up http-server, serving ./<br>Available on:<br>  <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a><br>  <a href="http://192.168.8.196:8080/">http://192.168.8.196:8080</a><br>Hit CTRL-C to stop the server<br>3.关闭 http-server服务</p>
<p>按快捷键CTRL-C 终端显示^Chttp-server stopped.即关闭服务成功。</p>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是VSCode的安装和介绍教程了,</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>
]]></content>
      <tags>
        <tag>工具浅玩类</tag>
      </tags>
  </entry>
</search>
