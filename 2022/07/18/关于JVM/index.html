<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="关于JVM, HTML, Python,CSS, JavaScript, JQuery, React, Vue.js，Java,java,mysql,MySQL,Tomcat,navicat">
    <meta name="description" content="JVM总结一、JVM概述定义Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境）
好处一次编写，到处运行（多系统运行）自动内存管理，垃圾回收机制数组下标越界检查比较JVM、JRE、JDK的意义和">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>关于JVM | Welcome*＾-＾*</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Welcome*＾-＾*" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/favicon.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Welcome*＾-＾*</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/favicon.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Welcome*＾-＾*</div>
        <div class="logo-desc">
            
            个人技术Blog记录网站
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://Lil-sum.github.io/SZsum-Profile/" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://Lil-sum.github.io/SZsum-Profile/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">关于JVM</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        
<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFunction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>



<!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9C%AF%E8%AF%AD%E5%AE%9A%E4%B9%89%E7%B1%BB/">
                                <span class="chip bg-color">术语定义类</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-07-18
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16.3k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>JVM总结<br>一、JVM概述<br>定义<br>Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境）</p>
<p>好处<br>一次编写，到处运行（多系统运行）<br>自动内存管理，垃圾回收机制<br>数组下标越界检查<br>比较<br>JVM、JRE、JDK的意义和区别</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/1.png">                                                                                                                   </p>
<p>​                                                               </p>
<p>​                                                                   <strong>JVM、JRE、JDK的意义与区别</strong></p>
<h2 id="二、JVM内存结构"><a href="#二、JVM内存结构" class="headerlink" title="二、JVM内存结构"></a>二、JVM内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><img src="/%E5%85%B3%E4%BA%8EJVM/2.png"></p>
<p>​                                                                                    <strong>JVM结构图</strong></p>
<h3 id="2-1、程序计数器"><a href="#2-1、程序计数器" class="headerlink" title="2.1、程序计数器"></a>2.1、程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h4><p>用于保存JVM中下一条所要执行的指令的地址</p>
<p>JAVA代码执行流程：</p>
<p>JAVA代码 =&gt; 编译后得到二进制字节码（JVM指令）=&gt; 解释器 =&gt; 机器码（0101） =&gt; CPU执行</p>
<p>其中程序计数器保存下一条JVM指令，当上一个指令完成时继续执行代码</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li>线程私有<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程所私有的</strong>，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通 过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li>不会存在内存溢出</li>
</ul>
<h3 id="2-2、虚拟机栈"><a href="#2-2、虚拟机栈" class="headerlink" title="2.2、虚拟机栈"></a>2.2、虚拟机栈</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li>
</ul>
<h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a><strong>问题辨析</strong></h4><ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要。</strong>因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所 以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>如果方法内局部变量<strong>没有逃离方法的作用范围，则是线程安全的</strong></li>
<li>如果如果<strong>局部变量引用了对象，并逃离了方法的作用范围</strong>，则需要考虑线程安全问题（逃逸分析）</li>
</ul>
</li>
<li>内存溢出（Java.lang.stackOverflowError）可能存在的原因？<ul>
<li>虚拟机栈中，栈帧过多（无限递归）</li>
<li>每个栈帧所占用过大</li>
</ul>
</li>
<li>线程运行诊断（CPU占用过高）<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul>
<li>top命令，查看是哪个进程占用CPU过高</li>
<li>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是 哪个线程占用CPU过高</li>
<li>jstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找 出的线程id是16进制的，需要转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3、本地方法栈"><a href="#2-3、本地方法栈" class="headerlink" title="2.3、本地方法栈"></a>2.3、本地方法栈</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h4><p>一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作 系统底层交互，所以需要用到本地方法</p>
<h3 id="2-4、堆"><a href="#2-4、堆" class="headerlink" title="2.4、堆"></a>2.4、堆</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>通过<strong>new关键字创建的对象</strong>都会被放在堆内存</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>存在垃圾回收机制</li>
</ul>
<h4 id="问题辨析-1"><a href="#问题辨析-1" class="headerlink" title="问题辨析"></a><strong>问题辨析</strong></h4><ul>
<li>堆内存溢出（java.lang.OutofMemoryError ：java heap space.）诊断工具<ul>
<li>jps</li>
<li>jmap</li>
<li>jconsole</li>
<li>jvirsalvm</li>
</ul>
</li>
</ul>
<h3 id="2-5、方法区"><a href="#2-5、方法区" class="headerlink" title="2.5、方法区"></a>2.5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/3.png"></p>
<p>​                                                                                       <strong>方法区结构</strong></p>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>1.6以前方法区存在于<strong>堆中</strong>，会导致<strong>永久代内存溢出</strong></li>
<li>1.8以后方法区存在于<strong>元空间中</strong>（元空间位于本地内存中），会导致<strong>元空间内存溢出</strong></li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a><strong>常量池</strong></h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p>
<p><strong>通过反编译来查看类的信息</strong></p>
<ul>
<li>获得对应类的.class文件<ul>
<li>在JDK对应的bin目录下运行cmd，也可以在IDEA控制台输入</li>
<li>输入 javac 对应类的绝对路径</li>
</ul>
</li>
</ul>
<pre class="language-none"><code class="language-none">C:\JAVA\JDK8.0\bin&gt;javac C:\study\src\com\nyima\JVM\day01\Main.java</code></pre>

<ul>
<li><p>输入完成后，对应的目录下就会出现类的.class文件</p>
</li>
<li><p>在控制台输入 javap -v 类的绝对路径</p>
<pre class="language-none"><code class="language-none">javap -v C:\study\src\com\nyima\JVM\day01\Main.class</code></pre>


</li>
<li><p>然后能在控制台看到反编译以后类的信息了</p>
</li>
</ul>
<p>包括类的基本信息、常量池</p>
<p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，#号的内容需要在常量池中查找）</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h4><ul>
<li>常量池<ul>
<li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法 名、参数类型、字面量信息</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>常量池是.class文件中的，当该<em>类被加载以后，<strong>它的常量池信息</strong>就会放入运行时常量池，*<em>并把里面的符号地址变为真实地址</em></em></li>
</ul>
</li>
</ul>
<h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a><strong>常量池与串池的关系</strong></h4><p>stringtable、stringpool、串池、字符串常量池，这四个是一个东西。</p>
<p>但是跟常量池不是一个东西！<strong>串池在堆中</strong></p>
<p>跟常量池是包含关系，跟运行时常量池是互斥关系。</p>
<h4 id="串池（StringTable）"><a href="#串池（StringTable）" class="headerlink" title="串池（StringTable）"></a><strong>串池（StringTable）</strong></h4><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h5><ul>
<li><p>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></p>
</li>
<li><p>利用串池的机制，来避免重复创建字符串对象</p>
</li>
<li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p>
</li>
<li><p>字符串常量拼接的原理是编译器优化</p>
</li>
<li><p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</p>
</li>
<li><p>结构为HashTable (数组 + 链表)</p>
</li>
<li><p><strong>注意：</strong>无论是串池还是堆里面的字符串，都是对象</p>
</li>
<li><p><strong>注意：</strong>字符串对象的创建<strong>都是懒惰的</strong>，只有当运行到那一行字符串<strong>且在串池中不存在的时候</strong>（如 ldc #2） 时，该字符串才会被创建并放入串池中。</p>
</li>
<li><p><strong>注意：</strong>通过<strong>拼接的方式</strong>来创建字符串的过程</p>
<p>只能在运行期确定它的值，所以需要使用StringBuilder来创建</p>
<p>StringBuilder().append(“a”).append(“b”).toString()</p>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的值和拼接的字符串一致，但是是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>
</li>
</ul>
<h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a><strong>intern方法 1.8</strong></h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意：</strong>此时如果调用intern方法<strong>成功</strong>，<strong>堆内存与串池中</strong>的字符串对象是<strong>同一个对象</strong>；</p>
<p> 如果失败，则不是同一个 对象</p>
<h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a><strong>intern方法 1.6</strong></h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p>注意：此时无论调用intern方法<strong>成功与否</strong>，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p>
<h5 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a><strong>StringTable 垃圾回收</strong></h5><p>StringTable在内存紧张时，<strong>会发生垃圾回收</strong></p>
<h5 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a><strong>StringTable调优</strong></h5><ul>
<li>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</li>
</ul>
<pre class="language-none"><code class="language-none">-XX:StringTableSize=xxxx</code></pre>

<ul>
<li><p>考虑是否需要将字符串对象入池</p>
<p>可以<strong>通过intern方法减少重复入池</strong></p>
</li>
</ul>
<h3 id="2-6、直接内存"><a href="#2-6、直接内存" class="headerlink" title="2.6、直接内存"></a>2.6、直接内存</h3><ul>
<li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/4.png"></p>
<p>​                                                                                <strong>文件读写流程</strong></p>
<p><strong>使用了DirectBuffer</strong></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/5.png"></p>
<p>​                                                                              <strong>文件读写流程</strong></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高 了效率</p>
<h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p>
<pre class="language-none"><code class="language-none">//通过ByteBuffer申请1M的直接内存
ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</code></pre>

<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p><strong>allocateDirect的实现</strong></p>
<pre class="language-none"><code class="language-none">public static ByteBuffer allocateDirect(int capacity) {
 return new DirectByteBuffer(capacity);
}</code></pre>

<p><strong>DirectByteBuffer类</strong></p>
<pre class="language-none"><code class="language-none">DirectByteBuffer(int cap) { // package-private

            super(-1, 0, cap, cap);
            boolean pa = VM.isDirectMemoryPageAligned();
            int ps = Bits.pageSize();
            long size = Math.max(1L, (long)cap + (pa ? ps : 0));
            Bits.reserveMemory(size, cap);
            long base = 0;
            try {
                base = unsafe.allocateMemory(size); //申请内存
            } catch (OutOfMemoryError x) {
                Bits.unreserveMemory(size, cap);
                throw x;
            }
            unsafe.setMemory(base, size, (byte) 0);
            if (pa &amp;&amp; (base % ps != 0)) {
                // Round up to page boundary
                address = base + ps - (base &amp; (ps - 1));
            } else {
                address = base;
            }
            //通过虚引用，来实现直接内存的释放，this为虚引
            cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); 
            att = null;
        }</code></pre>

<p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测</p>
<p>如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p>
<pre class="language-none"><code class="language-none">public void clean() {
            if (remove(this)) {
                try {
                    this.thunk.run(); //调用run方法
                } catch (final Throwable var2) {
                    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                        public Void run() {
                            if (System.err != null) {
                                (new Error("Cleaner terminated abnormally", var2)).printStackTrace();
                            }
                            System.exit(1);
                            return null;
                        }
                    });
                }

    }
}</code></pre>

<p>对应对象的run方法</p>
<pre class="language-none"><code class="language-none">public void run() {
           if (address == 0) {
               // Paranoia
               return;
           }
           unsafe.freeMemory(address); //释放直接内存中占用的内存
           address = 0;
           Bits.unreserveMemory(size, capacity);
       }</code></pre>

<h4 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h4><ul>
<li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li>
<li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么 会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li>
</ul>
<h2 id="三、JVM垃圾回收机制"><a href="#三、JVM垃圾回收机制" class="headerlink" title="三、JVM垃圾回收机制"></a>三、JVM垃圾回收机制</h2><h3 id="1、如何判断对象可以被回收？"><a href="#1、如何判断对象可以被回收？" class="headerlink" title="1、如何判断对象可以被回收？"></a>1、如何判断对象可以被回收？</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>若对象被引用则该对象的计数加1</p>
<p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/6.png"></p>
<p>​                                                                      <strong>相互引用导致无法释放</strong></p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul>
<li><p>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象</p>
</li>
<li><p>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p>
</li>
<li><p>可以作为</p>
<p>GC Root的对象</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
</li>
</ul>
<h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/7.png"></p>
<p>​                                                                            <strong>五种引用说明</strong></p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root都不引用该对象时，才会回收强引用对象</p>
<p>如上图B、C对象都不引用A1对象时，A1对象才会被回收</p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象</p>
<p>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</p>
<ul>
<li>软引用的使用</li>
</ul>
<pre class="language-none"><code class="language-none">public class Demo1 {
            public static void main(String[] args) {
                final int _4M = 4*1024*1024;
				//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用
                List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
                SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);
            }
        }</code></pre>

<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>如果想要<strong>清理软引用，需要使用引用队列</strong></p>
<pre class="language-none"><code class="language-none">public class Demo1 {
            public static void main(String[] args) {
                final int _4M = 4*1024*1024;
                //使用引用队列，用于移除引用为空的软引用对象
                ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
                //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用
                List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
                SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);
                //遍历引用队列，如果有元素，则移除
                Reference&lt;? extends byte[]&gt; poll = queue.poll();
                while(poll != null) {
                //引用队列不为空，则从集合中移除该元素
                    list.remove(poll);
                //移动到引用队列中的下一个元素
                    poll = queue.poll();
                }
            }
        }</code></pre>

<ul>
<li><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</li>
</ul>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用所引用的对象</p>
<p>如上图如果B对象不再引用A3对象，则A3对象会被回收</p>
<p><strong>弱引用的使用和软引用类似，只是将 SoftReference 换为了 WeakReference</strong></p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p>
<ul>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象 Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。 这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将 终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize 方法。调用以后，该对象就可以被垃圾回收了</p>
<p>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所 引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul>
<li><p>软引用和弱引用可以配合引用队列</p>
<p>在弱引用和虚引用所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/ 弱引用对象</p>
</li>
<li><p>虚引用和终结器引用必须配合引用队列</p>
</li>
</ul>
<h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/8.png"></p>
<p>​                                                                           <strong>标记清除算法图解</strong></p>
<h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后 垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h5><p><strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm 启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h4 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/9.png"></p>
<p>​                                                                          <strong>标记整理算法图解</strong></p>
<h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>标记-整理会将不被GC Root引用的对象回收，清除其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/10.png"></p>
<p>​                                     </p>
<p>​                                                                            <strong>复制算法图解</strong></p>
<h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO 中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用 双倍的内存空间。</p>
<h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><img src="/%E5%85%B3%E4%BA%8EJVM/11.png"></p>
<p>​                                                                                 <strong>分代回收图解</strong></p>
<h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>1、新创建的对象都被放在了新生代的伊甸园中</p>
<p>2、当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>
<p><strong>Minor GC</strong> 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先复制到幸存区 TO中</strong>， 并让其寿命加1，再<strong>交换两个幸存区</strong></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/12.png"></p>
<p>​                                                                             <strong>Minor GC 图解</strong></p>
<p>3、再次创建对象，若<strong>新生代的伊甸园又满了</strong>，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用 户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的<strong>对象寿命加1</strong></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/13.png"></p>
<p>4、如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被放入老年代中</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/14.png"></p>
<p>​                                                                              <strong>对象晋升老年代</strong></p>
<p>5、如果新生代老年代中的内存都满了，就会先触发<strong>Minor GC</strong>，再触发<strong>Full GC</strong>，扫描新生代和老年代中所有不再使用的对象并回收</p>
<h4 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h4><p><img src="/%E5%85%B3%E4%BA%8EJVM/15.png"></p>
<p>​                                                                             <strong>相关JVM参数</strong></p>
<h4 id="GC分析"><a href="#GC分析" class="headerlink" title="GC分析"></a>GC分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a><strong>大对象处理策略</strong></h5><p>当遇到一个<strong>较大的对象时</strong>，就算新生代的伊甸园为空，也无法容纳该对象时，<strong>会将该对象直接晋升为老年代</strong></p>
<h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a><strong>线程内存溢出</strong></h5><p><strong>某个线程的内存溢出了而抛异常</strong>（out of memory），不会让<strong>其他的线程结束运行</strong></p>
<p>这是因为当一个线程抛出OOM异常后，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，进程依然正常</p>
<h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><strong>相关概念</strong></h4><p><strong>并行收集：</strong>指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</p>
<p><strong>并发收集：</strong>指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行， 而垃圾收集程序运行在另一个CPU上</p>
<p><strong>吞吐量：</strong>即CPU用于<strong>运行用户代码的时间</strong>与<strong>CPU总消耗时间</strong>的比值</p>
<p> （吞吐量 = 运行用户代码时间 / ( 运行用户 代码时间 + 垃圾收集时间 )）</p>
<p> 例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量 就是99%</p>
<p><strong>串行：</strong></p>
<ul>
<li>单线程</li>
<li>内存较小，一般用于个人电脑（CPU核数较少）</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/16.png"></p>
<p>​                                                                                 <strong>串行图解</strong></p>
<p><strong>安全点：</strong>让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象 因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞状态</strong></p>
<h4 id="相关收集器"><a href="#相关收集器" class="headerlink" title="相关收集器"></a>相关收集器</h4><p><strong>Serial 收集器</strong></p>
<p>Serial收集器是最基本的、发展历史最悠久的收集器</p>
<ul>
<li><p><strong>特点</strong></p>
<p>单线程、简单高效（与其他收集器的单线程相比），<strong>采用复制算法</strong>。对于限定单个CPU的环境来说， Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃 圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
</li>
</ul>
<p><strong>ParNew 收集器</strong></p>
<p>ParNew收集器其实就是Serial收集器的多线程版本</p>
<ul>
<li><p><strong>特点</strong></p>
<p>多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使 用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
</li>
</ul>
<p><strong>Serial Old 收集器</strong></p>
<p>Serial Old是Serial收集器的老年代版本</p>
<ul>
<li><p><strong>特点</strong></p>
<p>同样是单线程收集器，采用<strong>标记-整理算法</strong></p>
</li>
</ul>
<h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul>
<li>说明<ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li>
<li><strong>JDK1.8默认使用的垃圾回收器</strong></li>
</ul>
</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/17.png"></p>
<p>​                                                                             <strong>运行流程图</strong></p>
<p><strong>Parallel Scavenge 收集器</strong></p>
<p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<ul>
<li><p><strong>特点</strong></p>
<p>属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器 （与ParNew收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收 集器最重要的一个区别）</p>
</li>
</ul>
<p><strong>GC自适应调节策略：</strong>Parallel Scavenge收集器可设置<code>-XX:+UseAdptiveSizePolicy</code>参数。当开关打开时不需 要手动指定新生代的大小（<code>-Xmn</code>）、Eden与Survivor区的比例（<code>-XX:SurvivorRation</code>）、晋升老年代的对象 年龄（<code>-XX:PretenureSizeThreshold</code>）等，虚拟机会根据系统的运行状况收集性能监控信息，<strong>动态设置这些参数以提供最优的停顿时间和最高的吞吐量</strong>，这种调节方式称为GC的自适应调节策略。</p>
<p><strong>Parallel Scavenge收集器使用两个参数控制吞吐量：</strong></p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
<p><strong>Parallel Old 收集器</strong></p>
<p>是Parallel Scavenge收集器的老年代版本</p>
<ul>
<li><p><strong>特点</strong></p>
<p>多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>
</li>
</ul>
<h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul>
<li>说明<ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li>
</ul>
</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/18.png"></p>
<p>​                                                                                <strong>运行流程图</strong></p>
<p><strong>CMS 收集器说明</strong></p>
<p><strong>Concurrent Mark Sweep</strong>，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代收集器</strong></p>
<ul>
<li><p><strong>特点</strong></p>
<p>基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片</p>
</li>
<li><p><strong>应用场景</strong></p>
<p>适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程 序、b/s服务</p>
</li>
</ul>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记：</strong>标记GC Roots能直接到的对象。速度很快但是仍存在<strong>Stop The World</strong>问题</p>
<p><strong>并发标记：</strong>进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
<p><strong>重新标记：</strong>为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在<strong>Stop The World</strong>问题</p>
<p><strong>并发清除：</strong>对标记的对象进行清除回收CMS收集器的内存回收过程是与用户线程一起并发执行的</p>
<p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a><strong>定义</strong></h5><p><strong>Garbage First</strong></p>
<p>JDK 9以后默认使用，而且替代了CMS 收集器</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/19.png"></p>
<h5 id="适用场景和特点"><a href="#适用场景和特点" class="headerlink" title="适用场景和特点"></a><strong>适用场景和特点</strong></h5><ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制算法</strong></li>
</ul>
<h5 id="相关参数-1"><a href="#相关参数-1" class="headerlink" title="相关参数"></a><strong>相关参数</strong></h5><p>JDK8 并不是默认开启的，所需要参数开启</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/21.png"></p>
<p>​                                                                    <strong>G1垃圾回收器相关参数</strong></p>
<h5 id="G1垃圾回收步骤"><a href="#G1垃圾回收步骤" class="headerlink" title="G1垃圾回收步骤"></a><strong>G1垃圾回收步骤</strong></h5><p><img src="/%E5%85%B3%E4%BA%8EJVM/22.png"></p>
<p>​                                                                           <strong>G1垃圾回收步骤</strong></p>
<p><strong>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记</strong></p>
<p><strong>—–&gt;回收新生代伊甸园、幸存区、老年代内存 ——&gt;新生代伊甸园垃圾回收(重新开始)</strong></p>
<h6 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a><strong>Young Collection</strong></h6><p><strong>分区算法region</strong></p>
<p>分代是<strong>按对象的生命周期划分</strong>，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<ul>
<li><strong>会产生STW</strong></li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/23.png"></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/24.png"></p>
<h6 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a><strong>Young Collection + CM</strong></h6><p>CM：并发标记</p>
<ul>
<li>在 Young GC 时会对 <strong>GC Root 进行初始标记</strong></li>
<li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/25.png"></p>
<h6 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a><strong>Mixed Collection</strong></h6><p>会对E S O 进行<strong>全面的回收</strong></p>
<ul>
<li>最终标记</li>
<li>拷贝<strong>存活</strong></li>
</ul>
<p><code>-XX:MaxGCPauseMills:xxx</code> 用于指定最长的停顿时间</p>
<p><strong>问：</strong>为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后能够得到更多内存）</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/26.png"></p>
<h6 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h6><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
<h6 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a><strong>Young Collection 跨代引用</strong></h6><ul>
<li>新生代回收的跨代引用（老年代引用新生代）问题</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/27.png"></p>
<ul>
<li>卡表与Remembered Set<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称 为脏卡</li>
</ul>
</li>
</ul>
</li>
<li>在引用变更时通过post-write barried + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/28.png"></p>
<h6 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a><strong>Remark</strong></h6><p>重新标记阶段</p>
<p>在垃圾回收时，收集器处理对象的过程中 :</p>
<p>黑色：已被处理，需要保留的</p>
<p>灰色：正在处理中的</p>
<p>白色：还未处理的</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/29.png"></p>
<p>但是在<strong>并发标记</strong>过程中，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用 了C，这时就会用到remark</p>
<p><strong>过程如下：</strong></p>
<ul>
<li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当 中，并将C变为 处理中 状态</li>
<li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用 引用它，就会处理它</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/30.png"></p>
<h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p><strong>过程</strong></p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们引用同一个字符串对象</li>
<li>注意，其与String.intern的区别<ul>
<li>intern关注的是字符串对象</li>
<li>字符串去重关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串标</li>
</ul>
</li>
</ul>
<p><strong>优点与缺点</strong></p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收 时处理掉</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/31.png"></p>
<h3 id="5、GC调优"><a href="#5、GC调优" class="headerlink" title="5、GC调优"></a>5、GC调优</h3><h4 id="查看虚拟机参数命令"><a href="#查看虚拟机参数命令" class="headerlink" title="查看虚拟机参数命令"></a><strong>查看虚拟机参数命令</strong></h4><pre class="language-none"><code class="language-none">"F:\JAVA\JDK8.0\bin\java" -XX:+PrintFlagsFinal -version | findstr "GC"</code></pre>

<p>可以根据参数去查询具体的信息</p>
<h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a><strong>调优领域</strong></h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a><strong>确定目标</strong></h4><p>低延迟/高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS G1 ZGC</li>
<li>ParallelGC</li>
<li>Zing</li>
</ul>
<p><strong>最快的GC是不发生GC</strong></p>
<p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<p>查看Full GC前后的内存占用，考虑以下几个问题</p>
<ul>
<li>数据是不是太多？</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a><strong>新生代调优</strong></h4><ul>
<li>新生代的特点<ul>
<li>所有的new操作分配内存都是非常廉价的<ul>
<li>TLAB</li>
</ul>
</li>
<li>死亡对象回收零代价</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于Full GC</li>
</ul>
</li>
<li>新生代内存越大越好么？<ul>
<li>不是<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时， 清理新生代所花费的时间会更长</li>
</ul>
</li>
<li>新生代内存设置为内容纳 [并发量*(请求-响应)] 的数据为宜</li>
</ul>
</li>
</ul>
<h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a><strong>幸存区调优</strong></h4><ul>
<li>幸存区需要能够保存 <strong>当前活跃对象+需要晋升的对象</strong></li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>
</ul>
<h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a><strong>老年代调优</strong></h4><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a><strong>结构图</strong></h3><p><img src="/%E5%85%B3%E4%BA%8EJVM/32.png"></p>
<h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a><strong>1、类文件结构</strong></h3><p>首先获得.class字节码文件</p>
<p>方法：</p>
<ul>
<li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li>
<li>java终端中，执行javac X:…\XXX.java</li>
</ul>
<p>根据 JVM 规范，<strong>类文件结构</strong>如下</p>
<pre class="language-none"><code class="language-none">u4 magic
u2 minor_version; 
u2 major_version; 
u2 constant_pool_count; 
cp_info constant_pool[constant_pool_count-1]; 
u2 access_flags; 
u2 this_class; 
u2 super_class; 
u2 interfaces_count; 
u2 interfaces[interfaces_count]; 
u2 fields_count; 
field_info fields[fields_count]; 
u2 methods_count; 
method_info methods[methods_count]; 
u2 attributes_count; 
attribute_info attributes[attributes_count];</code></pre>

<p><strong>魔数</strong></p>
<p>u4 magic</p>
<p>对应字节码文件的0~3个字节</p>
<p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p><strong>版本</strong></p>
<pre class="language-none"><code class="language-none">u2 minor_version;
u2 major_version;
0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
34H = 52，代表JDK8</code></pre>

<h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><p>可参考</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p>
<p>javap工具</p>
<p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p>
<pre class="language-none"><code class="language-none">javap -v C:\study\src\com\nyima\JVM\day01\Main.class</code></pre>

<h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a><strong>图解方法执行流程</strong></h4><h5 id="一、执行的方法代码"><a href="#一、执行的方法代码" class="headerlink" title="一、执行的方法代码"></a>一、执行的方法代码</h5><pre class="language-none"><code class="language-none">public class Demo3_1 {
            public static void main(String[] args) {
                int a = 10;
                int b = Short.MAX_VALUE + 1;
                int c = a + b;
                System.out.println(c);
            }
        }</code></pre>

<h5 id="二、常量池载入运行时常量池"><a href="#二、常量池载入运行时常量池" class="headerlink" title="二、常量池载入运行时常量池"></a><strong>二、常量池载入运行时常量池</strong></h5><p>常量池也属于方法区，只不过这里单独提出来了</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/33.png"></p>
<h5 id="三、方法字节码载入方法区"><a href="#三、方法字节码载入方法区" class="headerlink" title="三、方法字节码载入方法区"></a>三、方法字节码载入方法区</h5><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/34.png"></p>
<h5 id="四、执行引擎开始执行字节码"><a href="#四、执行引擎开始执行字节码" class="headerlink" title="四、执行引擎开始执行字节码"></a>四、执行引擎开始执行字节码</h5><p><strong>bipush 10</strong></p>
<ul>
<li>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/35.png"></p>
<p><strong>istore 1</strong></p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p>
<p>对应代码中的</p>
<pre class="language-none"><code class="language-none">a = 10</code></pre>

<p><img src="/%E5%85%B3%E4%BA%8EJVM/36.png"></p>
<p><strong>ldc #3</strong></p>
<p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数 栈中</p>
<p><strong>注意：</strong> Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/37.png"></p>
<p><strong>istore 2</strong></p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/38.png"></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/39.png"></p>
<p><strong>iload1 iload2</strong></p>
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p>
<ul>
<li>因为只能在操作数栈中执行运算操作</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/40.png"></p>
<p><strong>iadd</strong></p>
<p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/41.png"></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/42.png"></p>
<p><strong>istore 3</strong></p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/43.png"></p>
<p><strong>getstatic #4</strong></p>
<p>在运行时常量池中找到#4，发现是一个对象 在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/44.png"></p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/45.png"></p>
<p><strong>iload 3</strong></p>
<p>将局部变量表中3号位置的元素压入操作数栈中</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/46.png"></p>
<p><strong>invokevirtual 5</strong></p>
<p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p>
<p>生成新的栈帧（分配 locals、stack等）</p>
<p>传递参数，执行新栈帧中的字节码</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/47.png"></p>
<p>执行完毕，弹出栈帧 清除</p>
<p>main 操作数栈内容</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/48.png"></p>
<p><strong>return</strong></p>
<p>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
<h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a><strong>通过字节码指令来分析问题</strong></h4><p>代码</p>
<pre class="language-none"><code class="language-none">public class Demo2 {
            public static void main(String[] args) {
                int i=0;
                int x=0;
                while(i&lt;10) {
                    x = x++;
                    i++;
                }
                System.out.println(x); //接过为0
            }
        }</code></pre>

<p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=3, args_size=1 //操作数栈分配2个空间，局部变量表分配3个空间
 0: iconst_0 //准备一个常数0
 1: istore_1 //将常数0放入局部变量表的1号槽位 i=0
 2: iconst_0 //准备一个常数0
 3: istore_2 //将常数0放入局部变量的2号槽位 x=0 
 4: iload_1 //将局部变量表1号槽位的数放入操作数栈中
 5: bipush 10 //将数字10放入操作数栈中，此时操作数栈中有2个数
 7: if_icmpge 21 //比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。
 10: iload_2 //将局部变量2号槽位的数放入操作数栈中，放入的值是0
 11: iinc 2, 1 //将局部变量2号槽位的数加1，自增后，槽位中的值为1
 14: istore_2 //将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0
 15: iinc 1, 1 //1号槽位的值自增1
 18: goto 4 //跳转到第4条指令
 21: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream;
 24: iload_2
 25: invokevirtual #3 // Method java/io/PrintStream.println:(I)V
 28: return</code></pre>

<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h5><p><strong>cinit()V</strong></p>
<pre class="language-none"><code class="language-none">public class Demo3 {
            static int i = 10;
            static {
                i = 20;
            }
            static {
                i = 30;
            }
            public static void main(String[] args) {
                System.out.println(i); //结果为30
            }
        }</code></pre>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法 cinit()V</p>
<pre class="language-none"><code class="language-none">stack=1, locals=0, args_size=0
 0: bipush 10
 2: putstatic #3 // Field i:I
 5: bipush 20
 7: putstatic #3 // Field i:I
 10: bipush 30
 12: putstatic #3 // Field i:I
 15: return</code></pre>

<h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a><strong>init()V</strong></h5><pre class="language-none"><code class="language-none">public class Demo4 {
            private String a = "s1";
            {
                b = 20;
            }
            private int b = 10;
            {
                a = "s2";
            }
            public Demo4(String a, int b) {
                this.a = a;
                this.b = b;
            }
            public static void main(String[] args) {
                Demo4 d = new Demo4("s3", 30);
                System.out.println(d.a);
                System.out.println(d.b);
            }
        }</code></pre>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但原始构造方法内的代码<strong>总是在后</strong></p>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=3, args_size=3
 0: aload_0
 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V
 4: aload_0
 5: ldc #2 // String s1
 7: putfield #3 // Field a:Ljava/lang/String;
 10: aload_0
 11: bipush 20
 13: putfield #4 // Field b:I
 16: aload_0
 17: bipush 10
 19: putfield #4 // Field b:I
 22: aload_0
 23: ldc #5 // String s2
 25: putfield #3 // Field a:Ljava/lang/String;
 //原始构造方法在最后执行
 28: aload_0
 29: aload_1
 30: putfield #3 // Field a:Ljava/lang/String;
 33: aload_0
 34: iload_2
 35: putfield #4 // Field b:I
 38: return</code></pre>

<h5 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a><strong>方法调用</strong></h5><pre class="language-java" data-language="java"><code class="language-java">public class Demo5 {
            public Demo5() {
            }
            private void test1() {
            }
            private final void test2() {
            }
            public void test3() {
            }
            public static void test4() {
            }
            public static void main(String[] args) {
                Demo5 demo5 = new Demo5();
                demo5.test1();
                demo5.test2();
                demo5.test3();
                Demo5.test4();
            }
        }</code></pre>

<p>不同方法在调用时，对应的虚拟机指令有所区别</p>
<ul>
<li>私有、构造、被final修饰的方法，在调用时都使用invokespecial指令</li>
<li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期 间才能确定</li>
<li>静态方法在调用时使用invokestatic指令</li>
</ul>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=2, args_size=1
 0: new #2 // class com/nyima/JVM/day5/Demo5 
 3: dup
 4: invokespecial #3 // Method "&lt;init&gt;":()V
 7: astore_1
 8: aload_1
 9: invokespecial #4 // Method test1:()V
 12: aload_1
 13: invokespecial #5 // Method test2:()V
 16: aload_1
 17: invokevirtual #6 // Method test3:()V
 20: invokestatic #7 // Method test4:()V
 23: return</code></pre>

<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li>
<li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li>
<li>终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li>
<li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态成员方法与静态方法调用的另一个区 别是，执行方法前是否需要【对象引用】</li>
</ul>
<h5 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h5><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<code>invokevirtual</code>指令</p>
<p>在执行<code>invokevirtual</code>指令时，经历了以下几个步骤</p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong>(虚拟方法表)</li>
<li>查询<code>vtable</code>找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>try-catch</p>
<pre class="language-none"><code class="language-none">public class Demo1 {
            public static void main(String[] args) {
                int i = 0;
                try {
                    i = 10;
                }catch (Exception e) {
                    i = 20;
                }
            }
        }</code></pre>

<p>对应字节码指令</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=3, args_size=1
 0: iconst_0
 1: istore_1
 2: bipush 10
 4: istore_1
 5: goto 12
 8: astore_2
 9: bipush 20
 11: istore_1
 12: return
 //多出来一个异常表
 Exception table:
 from to target type
 2 5 8 Class java/lang/Exception</code></pre>

<ul>
<li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范 围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指 示行号</li>
<li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li>
</ul>
<p><strong>多个single-catch</strong></p>
<pre class="language-none"><code class="language-none">public class Demo1 {
            public static void main(String[] args) {
                int i = 0;
                try {
                    i = 10;
                }catch (ArithmeticException e) {
                    i = 20;
                }catch (Exception e) {
                    i = 30;
                }
            }
        }</code></pre>

<p>对应的字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=3, args_size=1
 0: iconst_0
 1: istore_1
 2: bipush 10
 4: istore_1
 5: goto 19
 8: astore_2
 9: bipush 20
 11: istore_1
 12: goto 19
 15: astore_2
 16: bipush 30
 18: istore_1
 19: return
 Exception table:
 from to target type
 2 5 8 Class java/lang/ArithmeticException
 2 5 15 Class java/lang/Exception</code></pre>

<ul>
<li>因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用</li>
</ul>
<p><strong>finally</strong></p>
<pre class="language-none"><code class="language-none">public class Demo2 {
            public static void main(String[] args) {
                int i = 0;
                try {
                    i = 10;
                } catch (Exception e) {
                    i = 20;
                } finally {
                    i = 30;
                }
            }
        }</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=4, args_size=1
 0: iconst_0
 1: istore_1
 //try块
 2: bipush 10
 4: istore_1
 //try块执行完后，会执行finally 
 5: bipush 30
 7: istore_1
 8: goto 27
 //catch块 
 11: astore_2 //异常信息放入局部变量表的2号槽位
 12: bipush 20
 14: istore_1
 //catch块执行完后，会执行finally 
 15: bipush 30
 17: istore_1
 18: goto 27
 //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码 
 21: astore_3
 22: bipush 30
 24: istore_1
 25: aload_3
 26: athrow //抛出异常
 27: return
 Exception table:
 from to target type
 2 5 11 Class java/lang/Exception
 2 5 21 any
 11 15 21 any</code></pre>

<p>可以看到 finally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p>
<p><strong>注意：</strong>虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码只会被执行一次</p>
<p><strong>finally中的return</strong></p>
<pre class="language-none"><code class="language-none">public class Demo3 {
            public static void main(String[] args) {
                int i = Demo3.test();
                //结果为20
                System.out.println(i);
            }
            public static int test() {
                int i;
                try {
                    i = 10;
                    return i;
                } finally {
                    i = 20;
                    return i;
                }
            }
        }</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=3, args_size=0
 0: bipush 10
 2: istore_0
 3: iload_0
 4: istore_1 //暂存返回值
 5: bipush 20
 7: istore_0
 8: iload_0
 9: ireturn //ireturn会返回操作数栈顶的整型值20
 //如果出现异常，还是会执行finally块中的内容，没有抛出异常
 10: astore_2
 11: bipush 20
 13: istore_0
 14: iload_0
 15: ireturn //这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！
 Exception table:
 from to target type
 0 5 10 any</code></pre>

<ul>
<li><p>由于 finally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以finally的为准</p>
</li>
<li><p>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</p>
</li>
<li><p>跟上例中的 finally 相比，发现<strong>没有 athrow</strong> 了，这告诉我们：<strong>如果在 finally 中出现了 return，会吞掉异常</strong></p>
<p>所以不要在<strong>finally中进行返回操作</strong></p>
</li>
</ul>
<p><strong>被吞掉的异常</strong></p>
<pre class="language-none"><code class="language-none">public class Demo3 {
            public static void main(String[] args) {
                int i = Demo3.test();
                //最终结果为20
                System.out.println(i);
            }
            public static int test() {
                int i;
                try {
                    i = 10;
                    //这里应该会抛出异常
                    i = i/0;
                    return i;
                } finally {
                    i = 20;
                    return i;
                }
            }
        }</code></pre>

<p>会发现打印结果为20，并未抛出异常</p>
<p><strong>finally不带return</strong></p>
<pre class="language-none"><code class="language-none">public class Demo4 {
    public static void main(String[] args) {
        int i = Demo4.test();
        System.out.println(i);
    }
    public static int test() {
        int i = 10;
        try {
            return i;
        } finally {
            i = 20;
        }
    }
}</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=1, locals=3, args_size=0
 0: bipush 10
 2: istore_0 //赋值给i 10
 3: iload_0 //加载到操作数栈顶
 4: istore_1 //加载到局部变量表的1号位置
 5: bipush 20
 7: istore_0 //赋值给i 20
 8: iload_1 //加载局部变量表1号位置的数10到操作数栈
 9: ireturn //返回操作数栈顶元素 10
 10: astore_2
 11: bipush 20
 13: istore_0
 14: aload_2 //加载异常
 15: athrow //抛出异常
 Exception table:
 from to target type
 3 5 10 any</code></pre>

<h5 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a><strong>Synchronized</strong></h5><pre class="language-none"><code class="language-none">public class Demo5 {
            public static void main(String[] args) {
                int i = 10;
                Lock lock = new Lock();
                synchronized (lock) {
                    System.out.println(i);
                }
            }
        }
class Lock{}</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=5, args_size=1
 0: bipush 10
 2: istore_1
 3: new #2 // class com/nyima/JVM/day06/Lock
 6: dup //复制一份，放到操作数栈顶，用于构造函数消耗
 7: invokespecial #3 // Method com/nyima/JVM/day06/Lock."&lt;init&gt;":()V
 10: astore_2 //剩下的一份放到局部变量表的2号位置
 11: aload_2 //加载到操作数栈
 12: dup //复制一份，放到操作数栈，用于加锁时消耗
 13: astore_3 //将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用
 14: monitorenter //加锁
 //锁住后代码块中的操作 
 15: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream;
 18: iload_1
 19: invokevirtual #5 // Method java/io/PrintStream.println:(I)V
 //加载局部变量表中三号槽位对象的引用，用于解锁 
 22: aload_3 
 23: monitorexit //解锁
 24: goto 34
 //异常操作 
 27: astore 4
 29: aload_3
 30: monitorexit //解锁
 31: aload 4
 33: athrow
 34: return
 //可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。 
 Exception table:
 from to target type
 15 24 27 any
 27 31 27 any</code></pre>

<h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 .java 源码编译为 .class 字节码的过程中，自动生成和转换**的一 些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p>
<p><strong>注意：</strong>以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a><strong>默认构造函数</strong></h4><pre class="language-none"><code class="language-none">public class Candy1 {
        }</code></pre>

<p>经过编译期优化后</p>
<pre class="language-none"><code class="language-none">public class Candy1 {
           //这个无参构造器是java编译器帮我们加上的
           public Candy1() {
               //即调用父类 Object 的无参构造方法，即调用 java/lang/Object." &lt;init&gt;":()V
               super();
           }
       }</code></pre>

<h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p>
<p>在JDK 5以后，它们的转换可以在编译期自动完成</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/49.png"></p>
<h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a><strong>泛型集合取值</strong></h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p>
<pre class="language-none"><code class="language-none">public class Demo3 {
            public static void main(String[] args) {
                List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                list.add(10);
                Integer x = list.get(0);
            }
        }</code></pre>

<p>对应字节码</p>
<pre class="language-none"><code class="language-none">Code:
 stack=2, locals=3, args_size=1
 0: new #2 // class java/util/ArrayList
 3: dup
 4: invokespecial #3 // Method java/util/ArrayList."&lt;init&gt;":()V
 7: astore_1
 8: aload_1
 9: bipush 10
 11: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
 //这里进行了泛型擦除，实际调用的是add(Objcet o)
 14: invokeinterface #5, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
 19: pop
 20: aload_1
 21: iconst_0
 //这里也进行了泛型擦除，实际调用的是get(Object o) 
 22: invokeinterface #6, 2 // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
//这里进行了类型转换，将Object转换成了Integer
 27: checkcast #7 // class java/lang/Integer
 30: astore_2
 31: return</code></pre>

<p>所以调用get函数取值时，有一个类型转换的操作</p>
<pre class="language-none"><code class="language-none">Integer x = (Integer) list.get(0);</code></pre>

<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p>
<pre class="language-none"><code class="language-none">int x = (Integer) list.get(0).intValue();</code></pre>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变参数</strong></h4><pre class="language-none"><code class="language-none">public class Demo4 {
            public static void foo(String... args) {
                //将args赋值给arr，可以看出String...实际就是String[] 
                String[] arr = args;
                System.out.println(arr.length);
            }
            public static void main(String[] args) {
                foo("hello", "world");
            }
        }</code></pre>

<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译 器会在编译期间将上述代码变换为：</p>
<pre class="language-none"><code class="language-none">public class Demo4 {
            public Demo4 {}

            public static void foo(String[] args) {
                String[] arr = args;
                System.out.println(arr.length);
            }
            public static void main(String[] args) {
                foo(new String[]{"hello", "world"});
            }
        }</code></pre>

<p>注意，如果调用的是foo()，即未传递参数时，等价代码为<code>foo(new String[]{})</code>，<strong>创建了一个空数组</strong>，而不是直接传递的null</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a><strong>foreach</strong></h4><pre class="language-none"><code class="language-none">public class Demo5 {
            public static void main(String[] args) {
                //数组赋初值的简化写法也是一种语法糖。
                int[] arr = {1, 2, 3, 4, 5};
                for(int x : arr) {
                    System.out.println(x);
                }
            }
        }</code></pre>

<p>编译器会帮我们转换为</p>
<pre class="language-none"><code class="language-none">public class Demo5 {
            public Demo5 {}
            public static void main(String[] args) {
                int[] arr = new int[]{1, 2, 3, 4, 5};
                for(int i=0; i&lt;arr.length; ++i) {
                    int x = arr[i];
                    System.out.println(x);
                }
            }
        }</code></pre>

<p>如果是集合使用foreach</p>
<pre class="language-none"><code class="language-none">public class Demo5 {
 public static void main(String[] args) {
 List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
 for (Integer x : list) {
 System.out.println(x);
 }
 }
}</code></pre>

<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>
<pre class="language-none"><code class="language-none">public class Demo5 {
            public Demo5 {}

            public static void main(String[] args) {
                List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
                //获得该集合的迭代器
                Iterator&lt;Integer&gt; iterator = list.iterator();
                while(iterator.hasNext()) {
                    Integer x = iterator.next();
                    System.out.println(x);
                }
            }
        }</code></pre>

<h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a><strong>switch字符串</strong></h4><pre class="language-none"><code class="language-none">public class Demo6 {
           public static void main(String[] args) {
               String str = "hello";
               switch (str) {
                   case "hello" :
                       System.out.println("h");
                       break;
                   case "world" :
                       System.out.println("w");
                       break;
                   default:
                       break;
               }
           }
       }</code></pre>

<p>在编译器中执行的操作</p>
<pre class="language-none"><code class="language-none">public class Demo6 {
           public Demo6() {

           }
           public static void main(String[] args) {
               String str = "hello";
               int x = -1;
               //通过字符串的hashCode+value来判断是否匹配
               switch (str.hashCode()) {
                   //hello的hashCode
                   case 99162322 :
                       //再次比较，因为字符串的hashCode有可能相等
                       if(str.equals("hello")) {
                           x = 0;
                       }
                       break;
                   //world的hashCode
                   case 11331880 :
                       if(str.equals("world")) {
                           x = 1;
                       }
                       break;
                   default:
                       break;
               }
               //用第二个switch在进行输出判断
               switch (x) {
                   case 0:
                       System.out.println("h");
                       break;
                   case 1:
                       System.out.println("w");
                       break;
                   default:
                       break;
               }
           }
       }</code></pre>

<p>过程说明：</p>
<ul>
<li>在编译期间，单个的switch被分为了两个<ul>
<li>第一个用来匹配字符串，并给x赋值<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>
</ul>
</li>
<li>第二个用来根据x的值来决定输出语句</li>
</ul>
</li>
</ul>
<h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a><strong>switch枚举</strong></h4><pre class="language-none"><code class="language-none">public class Demo7 {
           public static void main(String[] args) {
               SEX sex = SEX.MALE;
               switch (sex) {
                   case MALE:
                       System.out.println("man");
                       break;
                   case FEMALE:
                       System.out.println("woman");
                       break;
                   default:
                       break;
               }
           }
       }
       enum SEX {
           MALE, FEMALE;
       }</code></pre>

<p>编译器中执行的代码如下</p>
<pre class="language-none"><code class="language-none">public class Demo7 {
           /**
            * 定义一个合成类（仅 jvm 使用，对我们不可见） 
            * 用来映射枚举的 ordinal 与数组元素的关系 
            * 枚举的 ordinal 表示枚举对象的序号，从 0 开始 
            * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1 
            */
           static class $MAP {
               //数组大小即为枚举元素个数，里面存放了case用于比较的数字
               static int[] map = new int[2];
               static {
                   //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1
                   map[SEX.MALE.ordinal()] = 1;
                   map[SEX.FEMALE.ordinal()] = 2;
               }
           }
           public static void main(String[] args) {
               SEX sex = SEX.MALE;
               //将对应位置枚举元素的值赋给x，用于case操作
               int x = $MAP.map[sex.ordinal()];
               switch (x) {
                   case 1:
                       System.out.println("man");
                       break;
                   case 2:
                       System.out.println("woman");
                       break;
                   default:
                       break;
               }
           }
       }
       enum SEX {
           MALE, FEMALE;
       }</code></pre>

<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a><strong>枚举类</strong></h4><pre class="language-none"><code class="language-none">enum SEX {
 MALE, FEMALE;
}</code></pre>

<p>转换后的代码</p>
<pre class="language-none"><code class="language-none">public final class Sex extends Enum&lt;Sex&gt; {
           //对应枚举类中的元素
           public static final Sex MALE;
           public static final Sex FEMALE;
           private static final Sex[] $VALUES;

           static {
               //调用构造函数，传入枚举元素的值及ordinal
               MALE = new Sex("MALE", 0);
               FEMALE = new Sex("FEMALE", 1);
               $VALUES = new Sex[]{MALE, FEMALE};
           }

           //调用父类中的方法
           private Sex(String name, int ordinal) {
               super(name, ordinal);
           }

           public static Sex[] values() {
               return $VALUES.clone();
           }
           public static Sex valueOf(String name) {
               return Enum.valueOf(Sex.class, name);
           }

       }</code></pre>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><strong>匿名内部类</strong></h4><pre class="language-none"><code class="language-none">public class Demo8 {
            public static void main(String[] args) {
                Runnable runnable = new Runnable() {
                    @Override
                    public void run() {
                        System.out.println("running...");
                    }
                };
            }
        }</code></pre>

<p>转换后的代码</p>
<pre class="language-none"><code class="language-none">public class Demo8 {
           public static void main(String[] args) {
               //用额外创建的类来创建匿名内部类对象
               Runnable runnable = new Demo8$1();
           }
       }
       //创建了一个额外的类，实现了Runnable接口
       final class Demo8$1 implements Runnable {
           public Demo8$1() {}
           @Override
           public void run() {
               System.out.println("running...");
           }
       }</code></pre>

<p>如果匿名内部类中引用了<strong>局部变量</strong></p>
<pre class="language-none"><code class="language-none">public class Demo8 {
          public static void main(String[] args) {
              int x = 1;
              Runnable runnable = new Runnable() {
                  @Override
                  public void run() {
                      System.out.println(x);
                  }
              };
          }
      }</code></pre>

<p>转化后代码</p>
<pre class="language-none"><code class="language-none">public class Demo8 {
            public static void main(String[] args) {
                int x = 1;
                Runnable runnable = new Runnable() {
                    @Override
                    public void run() {
                        System.out.println(x);
                    }
                };
            }
        }
        final class Demo8$1 implements Runnable {
            //多创建了一个变量
            int val$x;
            //变为了有参构造器
            public Demo8$1(int x) {
                this.val$x = x;
            }
            @Override
            public void run() {
                System.out.println(val$x);
            }
        }</code></pre>

<h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h4><ul>
<li>将类的字节码载入<strong>方法区</strong>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 field 有：<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_fields 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li>如果这个类还有父类没有加载，<strong>先加载父类</strong></li>
<li>加载和链接可能是<strong>交替运行</strong>的</li>
</ul>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/50.png"></p>
<ul>
<li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>_java_mirror则是保存在<strong>堆内存</strong>中</li>
<li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>
<li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取 类的各种信息</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h4><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h4><p>验证类是否符合JVM规范，安全性检查</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h4><p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li>
<li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果 static 变量是 final 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>如果 static 变量是 final 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h4><ul>
<li><strong>HSDB的使用</strong></li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p>
<p>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块（static{}块）</strong>中的语句合并产生的</p>
<p>注意：编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的 变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p>
<p><img src="/%E5%85%B3%E4%BA%8EJVM/51.png"></p>
<p><strong>发生时机</strong></p>
<p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p>以下情况不会初始化</p>
<ul>
<li>访问类的 static final 静态常量（基本类型和字符串）</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类对象的数组</li>
<li>类加载器的.loadClass方法</li>
<li>Class.forNamed的参数2为false时</li>
</ul>
<p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p>
<h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的“<strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong>”这个动 作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称 为“<strong>类加载器</strong>”（ClassLoader）</p>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a><strong>类与类加载器</strong></h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p>
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个 类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在 这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一 个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p>
<p>以JDK 8为例</p>
<table>
<thead>
<tr>
<th align="center"><strong>名称</strong></th>
<th align="center"><strong>加载的类</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Bootstrap ClassLoader（启动类加载器）</td>
<td align="center">JAVA_HOME/jre/lib</td>
<td align="center">无法直接访问</td>
</tr>
<tr>
<td align="center">Extension ClassLoader (拓展类加载器)</td>
<td align="center">JAVA_HOME/jre/lib/ext</td>
<td align="center">上级为Bootstrap，显示为 null</td>
</tr>
<tr>
<td align="center">Application ClassLoader (应用程序类加载器)</td>
<td align="center">classpath</td>
<td align="center">上级为Extension</td>
</tr>
<tr>
<td align="center">自定义类加载器</td>
<td align="center">自定义</td>
<td align="center">上级为Application</td>
</tr>
</tbody></table>
<h5 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a><strong>启动类加载器</strong></h5><p>可通过在控制台输入指令，使得类被启动类加器加载</p>
<h5 id="拓展类加载"><a href="#拓展类加载" class="headerlink" title="拓展类加载"></a><strong>拓展类加载</strong></h5><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载 器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
<h5 id="双亲委派模式（经典面试题）"><a href="#双亲委派模式（经典面试题）" class="headerlink" title="双亲委派模式（经典面试题）"></a><strong>双亲委派模式（经典面试题）</strong></h5><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p>
<p>loadClass源码</p>
<pre class="language-none"><code class="language-none">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException
        {
            synchronized (getClassLoadingLock(name)) {
                // 首先查找该类是否已经被该类加载器加载过了
                Class&lt;?&gt; c = findLoadedClass(name);
                //如果没有被加载过
                if (c == null) {
                    long t0 = System.nanoTime();
                    try {
                        //看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null
                        if (parent != null) {
                            c = parent.loadClass(name, false);
                        } else {
                            //看是否被启动类加载器加载过
                            c = findBootstrapClassOrNull(name);
                        }
                    } catch (ClassNotFoundException e) {
                        // ClassNotFoundException thrown if class not found
                        // from the non-null parent class loader
                        //捕获异常，但不做任何处理
                    }
                    if (c == null) {
                        //如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常
                        //然后让应用类加载器去找classpath下找该类
                        long t1 = System.nanoTime();
                        c = findClass(name);
                        // 记录时间
                        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                        sun.misc.PerfCounter.getFindClasses().increment();
                    }
                }
                if (resolve) {
                    resolveClass(c);
                }
                return c;
            }
        }</code></pre>

<p><strong>总结：</strong>先由下到上询问，后由上到下加载</p>
<h5 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h5><p><strong>使用场景</strong></p>
<ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
<li></li>
</ul>
<p><strong>步骤</strong></p>
<ul>
<li><p>继承ClassLoader父类</p>
</li>
<li><p>要遵从双亲委派机制，重写 findClass 方法</p>
<p>不是重写loadClass方法，否则不会走双亲委派机制</p>
</li>
<li><p>读取类文件的字节码</p>
</li>
<li><p>调用父类的 defineClass 方法来加载类</p>
</li>
<li><p>使用者调用该类加载器的 loadClass 方法</p>
</li>
</ul>
<p><strong>破坏双亲委派模式</strong></p>
<ul>
<li><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远 古”时代</p>
<p>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</p>
</li>
<li><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的</p>
<p>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</p>
</li>
<li><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的</p>
<p>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署 （Hot Deployment）等</p>
</li>
</ul>
<h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a><strong>分层编译</strong></h4><p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 profiling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<p>profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】 等</p>
<p><strong>即时编译器（JIT）与解释器的区别</strong></p>
<ul>
<li><strong>解释器</strong><ul>
<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码<strong>编译</strong>为机器码，并<strong>存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方 面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简 单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a><strong>逃逸分析</strong></h4><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定 是否在 Java 堆上分配内存的一项技术</p>
<p>逃逸分析的 JVM 参数如下：</p>
<ul>
<li>开启逃逸分析：<code>-XX:+DoEscapeAnalysis</code></li>
<li>关闭逃逸分析：<code>-XX:-DoEscapeAnalysis</code></li>
<li>显示分析结果：<code>-XX:+PrintEscapeAnalysis</code></li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p>
<p><strong>对象逃逸状态</strong></p>
<ul>
<li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>
<li>对象是一个静态变量</li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
<p><strong>参数逃逸（ArgEscape）</strong></p>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被 调方法的字节码确定的</li>
</ul>
<p><strong>没有逃逸</strong></p>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被 调方法的字节码确定的</li>
</ul>
<p><strong>逃逸分析优化</strong></p>
<p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化：</p>
<p><strong>1、锁消除</strong></p>
<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前 线程中用到，这样编译器就会优化移除掉这些锁操作</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>开启锁消除：<code>-XX:+EliminateLocks</code></li>
<li>关闭锁消除：<code>-XX:-EliminateLocks</code></li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p><strong>2、标量替换</strong></p>
<p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为标量，它们不能被进一步分解。而能被进一步分 解的量就是聚合量，比如：对象</p>
<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节 省了内存空间，也提升了应用程序性能</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>开启标量替换：<code>-XX:+EliminateAllocations</code></li>
<li>关闭标量替换：<code>-XX:-EliminateAllocations</code></li>
<li>显示标量替换详情：<code>-XX:+PrintEliminateAllocations</code></li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p><strong>三、栈上分配</strong></p>
<p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一 致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a><strong>方法内联</strong></h4><h5 id="1、内联函数"><a href="#1、内联函数" class="headerlink" title="1、内联函数"></a><strong>1、内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<h5 id="2、JVM内联函数"><a href="#2、JVM内联函数" class="headerlink" title="2、JVM内联函数"></a><strong>2、JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器</strong>决定。Java不支持直接声明为内联函数的，如果想让他内 联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>
<pre class="language-none"><code class="language-none">public final void doSomething() {
           // to do something 
       }</code></pre>

<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>
<p>第二个原因则更重要：<strong>方法内联</strong></p>
<p>如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身，如：</p>
<pre class="language-none"><code class="language-none">private int add4(int x1, int x2, int x3, int x4) {
       //这里调用了add2方法
           return add2(x1, x2) + add2(x3, x4);
       }
       private int add2(int x1, int x2) {
           return x1 + x2;
       }</code></pre>

<p>方法调用被替换后</p>
<pre class="language-none"><code class="language-none">private int add4(int x1, int x2, int x3, int x4) {
           //被替换为了方法本身
           return x1 + x2 + x3 + x4;
       }</code></pre>

<h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a><strong>反射优化</strong></h4><pre class="language-none"><code class="language-none">public class Reflect1 {
           public static void foo() {
               System.out.println("foo...");
           }
           public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException{
           Method foo = Demo3.class.getMethod("foo");
                for(int i = 0; i&lt;=16; i++) {
                    foo.invoke(null);
                }
           }
       }</code></pre>

<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现， invoke方法源码</p>
<pre class="language-none"><code class="language-none">@CallerSensitive
      public Object invoke(Object obj, Object... args)throws IllegalAccessException, IllegalArgumentException,
              InvocationTargetException
      {
          if (!override) {
              if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                  Class&lt;?&gt; caller = Reflection.getCallerClass();
                  checkAccess(caller, clazz, obj, modifiers);
              }
          }
          //MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类
          MethodAccessor ma = methodAccessor; // read volatile
          if (ma == null) {
              ma = acquireMethodAccessor();
          }
          return ma.invoke(obj, args);
      }</code></pre>

<p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p>
<ul>
<li><p>一开始if条件不满足，就会调用本地方法invoke0</p>
</li>
<li><p>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率</p>
<p>这时会从反射调用变为正常调用，即直接调用 Reflect1.foo()</p>
</li>
</ul>
<h1 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h1><p><strong>以上就是对JVM的详细介绍了，</strong></p>
<p><strong>如果这篇文章对您有帮助，可以在下方进行留言;</strong></p>
<p><strong>下面的赏是对我最大的鼓励。</strong><br><strong>您的鼓励就是我最大的动力！</strong></p>
<p><strong>资料参考于课本，csdn开发者论坛，博客园开发者论坛…</strong></p>
<p><strong>转载请注明出处<a href="https://lil-sum.github.io/%EF%BC%8C">https://lil-sum.github.io/，</a> 感谢配合.</strong></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://Lil-sum.github.io" rel="external nofollow noreferrer">鵬0755</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://Lil-sum.github.io/2022/07/18/%E5%85%B3%E4%BA%8EJVM/">https://Lil-sum.github.io/2022/07/18/%E5%85%B3%E4%BA%8EJVM/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://Lil-sum.github.io" target="_blank">鵬0755</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9C%AF%E8%AF%AD%E5%AE%9A%E4%B9%89%E7%B1%BB/">
                                    <span class="chip bg-color">术语定义类</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/medias/reward/alipay.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }
    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }
    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }
    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }
    #vcomments blockquote p {
        text-indent: 0.2rem;
    }
    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }
    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }
    #vcomments ol li {
        list-style-type: decimal;
    }
    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }
    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }
    #vcomments ul li {
        list-style-type: disc;
    }
    #vcomments ul ul li {
        list-style-type: circle;
    }
    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }
    #vcomments table, th, td {
        border: 0;
    }
    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }
    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }
    #vcomments table td {
        min-width: 80px;
    }
    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }
    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }
    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }
    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }
    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }
    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }
    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }
    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }
    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }
    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }
    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }
    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }
    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }
    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }
    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
    #vcomments b,
    strong {
        font-weight: bold;
    }
    #vcomments dfn {
        font-style: italic;
    }
    #vcomments small {
        font-size: 85%;
    }
    #vcomments cite {
        font-style: normal;
    }
    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }
    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }
    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }
    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }
    #vcomments table td {
        min-width: 80px;
    }
    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
    .v[data-class="v"] .vwrap .vheader .vinput {
      width: 32%;
      border-bottom: 1px dashed #dedede;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/valine/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/valine/Valine.min.js"></script>
<script>

    let metaPlaceholder = {"nick":"昵称/QQ号(必填)","mail":"邮箱(必填，需要用到头像)","link":"商务广告网址(https://)(可不填)"} ;
    //这里要换行

    new Valine({
        el: '#vcomments',
        appId: 'dTgkXVNjiunckFH6GqExJxQW-9Nh9j0Va',
        appKey: 'scWzQCtamDMmHsmwhQSSED9c',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'monsterid',
        pageSize: '10',
        lang: 'zh-CN',
        placeholder: '留下你的足迹--',
        meta: ["nick", "mail", "link"],
        recordIP: 'true' === 'true',
        enableQQ: 'monsterid',
        requiredFields: ["1a1c2170543403965fa466dd94003ca5"],
        master: ["1a1c2170543403965fa466dd94003ca5"],
        tagMeta: ["主人", "访客"],
        metaPlaceholder: metaPlaceholder,

    });
    document.body.addEventListener('click', function(e) {
        if (e.target.classList.contains('vsubmit')) {
            const email = document.querySelector('input[type=email]');
            const nick = document.querySelector('input[name=nick]');
            const reg = /^[A-Za-z0-9_-\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;
            if (!email.value || !nick.value || !reg.test(email.value)) {
                const str = `<div class="valert txt-center"><div class="vtext">请填写正确的昵称和邮箱！</div></div>`;
                const vmark = document.querySelector('.vmark');
                vmark.innerHTML = str;
                vmark.style.display = 'block';
                e.stopPropagation();
                setTimeout(function() {
                    vmark.style.display = 'none';
                    vmark.innerHTML = '';
                }, 2500);
            }
        }
        }, true);
</script>

<!--酷Q推送-->


    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2022/07/18/%E5%85%B3%E4%BA%8EJVM/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/medias/featureimages/18.jpg" class="responsive-img" alt="关于JVM">
                        
                        <span class="card-title">关于JVM</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-07-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            鵬0755
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9C%AF%E8%AF%AD%E5%AE%9A%E4%B9%89%E7%B1%BB/">
                        <span class="chip bg-color">术语定义类</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/03/18/%E5%85%B3%E4%BA%8ESpark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/medias/featureimages/20.jpg" class="responsive-img" alt="关于Spark大数据开发">
                        
                        <span class="card-title">关于Spark大数据开发</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-03-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            鵬0755
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9C%AF%E8%AF%AD%E5%AE%9A%E4%B9%89%E7%B1%BB/">
                        <span class="chip bg-color">术语定义类</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('20')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Welcome*＾-＾*<br />'
            + '文章作者: 鵬0755<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="song"
                   id="1886371882"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='one'
                   order='list'
                   preload='metadata'
                   volume='0.6'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
    
             Copyright&nbsp;&copy;
             
            <span id="year">2020-2022</span>
            
            <a href="/about" target="_blank">鵬0755</a>
            |&nbsp;Powered by&nbsp;<a href="https://github.com/Lil-sum/SZsum-Profile" target="_blank">鵬0755</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">38.4k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 网站运行天数统计. -->
            
                <span id="sitetime"> 已运行..</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2020";
                        var startMonth = "6";
                        var startDate = "9";
                        var startHour = "14";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已安全运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已安全運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已安全运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已安全運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://Lil-sum.github.io/SZsum-Profile/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="https://mail.qq.com/" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://mobile.twitter.com/" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="http://asn.qq.com/" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1244675628" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/7259718006" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/7259718006" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://blog.csdn.net/Lil_sum0755" class="tooltipped" target="_blank" data-tooltip="关注我的CSDN: https://blog.csdn.net/Lil_sum0755" data-position="top" data-delay="50">
        <i class="fab fa-csdn">C</i>
    </a>




</div>
    </div>
</footer>

<div class="progress-bar"></div>



    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>


    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/others/sakura.js"><\/script>');
            }
        </script>
    

     <!-- 点击特效  -->
        <script src="/js/click_show_text.js"></script>
    
    

    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/Lil-sum/Lil-sum.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
